{"ast":null,"code":"import { liftTarget, replaceStep, canJoin, joinPoint, canSplit, ReplaceAroundStep, findWrapping } from 'prosemirror-transform';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { NodeSelection, Selection, AllSelection, TextSelection } from 'prosemirror-state'; // :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\n\nfunction deleteSelection(state, dispatch) {\n  if (state.selection.empty) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.deleteSelection().scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\n\n\nfunction joinBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0)) {\n    return false;\n  }\n\n  var $cut = findCutBefore($cursor); // If there is no node before this, try to lift\n\n  if (!$cut) {\n    var range = $cursor.blockRange(),\n        target = range && liftTarget(range);\n\n    if (target == null) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  var before = $cut.nodeBefore; // Apply the joining algorithm\n\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) {\n    return true;\n  } // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n\n\n  if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        var tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n        dispatch(tr.scrollIntoView());\n      }\n\n      return true;\n    }\n  } // If the node before is an atom, delete it\n\n\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) {\n      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction textblockAt(node, side, only) {\n  for (; node; node = side == \"start\" ? node.firstChild : node.lastChild) {\n    if (node.isTextblock) {\n      return true;\n    }\n\n    if (only && node.childCount != 1) {\n      return false;\n    }\n  }\n\n  return false;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\n\n\nfunction selectNodeBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  var $cut = $head;\n\n  if (!empty) {\n    return false;\n  }\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) {\n      return false;\n    }\n\n    $cut = findCutBefore($head);\n  }\n\n  var node = $cut && $cut.nodeBefore;\n\n  if (!node || !NodeSelection.isSelectable(node)) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) {\n    for (var i = $pos.depth - 1; i >= 0; i--) {\n      if ($pos.index(i) > 0) {\n        return $pos.doc.resolve($pos.before(i + 1));\n      }\n\n      if ($pos.node(i).type.spec.isolating) {\n        break;\n      }\n    }\n  }\n\n  return null;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\n\n\nfunction joinForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size)) {\n    return false;\n  }\n\n  var $cut = findCutAfter($cursor); // If there is no node after this, there's nothing to do\n\n  if (!$cut) {\n    return false;\n  }\n\n  var after = $cut.nodeAfter; // Try the joining algorithm\n\n  if (deleteBarrier(state, $cut, dispatch)) {\n    return true;\n  } // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n\n\n  if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    var delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        var tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n        dispatch(tr.scrollIntoView());\n      }\n\n      return true;\n    }\n  } // If the next node is an atom, delete it\n\n\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) {\n      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  return false;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\n\n\nfunction selectNodeForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  var $cut = $head;\n\n  if (!empty) {\n    return false;\n  }\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size) {\n      return false;\n    }\n\n    $cut = findCutAfter($head);\n  }\n\n  var node = $cut && $cut.nodeAfter;\n\n  if (!node || !NodeSelection.isSelectable(node)) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) {\n    for (var i = $pos.depth - 1; i >= 0; i--) {\n      var parent = $pos.node(i);\n\n      if ($pos.index(i) + 1 < parent.childCount) {\n        return $pos.doc.resolve($pos.after(i + 1));\n      }\n\n      if (parent.type.spec.isolating) {\n        break;\n      }\n    }\n  }\n\n  return null;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\n\n\nfunction joinUp(state, dispatch) {\n  var sel = state.selection,\n      nodeSel = sel instanceof NodeSelection,\n      point;\n\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) {\n      return false;\n    }\n\n    point = sel.from;\n  } else {\n    point = joinPoint(state.doc, sel.from, -1);\n\n    if (point == null) {\n      return false;\n    }\n  }\n\n  if (dispatch) {\n    var tr = state.tr.join(point);\n\n    if (nodeSel) {\n      tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n    }\n\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\n\n\nfunction joinDown(state, dispatch) {\n  var sel = state.selection,\n      point;\n\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) {\n      return false;\n    }\n\n    point = sel.to;\n  } else {\n    point = joinPoint(state.doc, sel.to, 1);\n\n    if (point == null) {\n      return false;\n    }\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.join(point).scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\n\n\nfunction lift(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var range = $from.blockRange($to),\n      target = range && liftTarget(range);\n\n  if (target == null) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.lift(range, target).scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\n\n\nfunction newlineInCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction defaultBlockAt(match) {\n  for (var i = 0; i < match.edgeCount; i++) {\n    var ref = match.edge(i);\n    var type = ref.type;\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n\n  return null;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\n\n\nfunction exitCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {\n    return false;\n  }\n\n  var above = $head.node(-1),\n      after = $head.indexAfter(-1),\n      type = defaultBlockAt(above.contentMatchAt(after));\n\n  if (!above.canReplaceWith(after, after, type)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var pos = $head.after(),\n        tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\n\n\nfunction createParagraphNear(state, dispatch) {\n  var sel = state.selection;\n  var $from = sel.$from;\n  var $to = sel.$to;\n\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) {\n    return false;\n  }\n\n  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n\n  if (!type || !type.isTextblock) {\n    return false;\n  }\n\n  if (dispatch) {\n    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    var tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\n\n\nfunction liftEmptyBlock(state, dispatch) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n\n  if (!$cursor || $cursor.parent.content.size) {\n    return false;\n  }\n\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    var before = $cursor.before();\n\n    if (canSplit(state.doc, before)) {\n      if (dispatch) {\n        dispatch(state.tr.split(before).scrollIntoView());\n      }\n\n      return true;\n    }\n  }\n\n  var range = $cursor.blockRange(),\n      target = range && liftTarget(range);\n\n  if (target == null) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.lift(range, target).scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\n\n\nfunction splitBlock(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.split($from.pos).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  if (!$from.parent.isBlock) {\n    return false;\n  }\n\n  if (dispatch) {\n    var atEnd = $to.parentOffset == $to.parent.content.size;\n    var tr = state.tr;\n\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) {\n      tr.deleteSelection();\n    }\n\n    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    var types = atEnd && deflt ? [{\n      type: deflt\n    }] : null;\n    var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{\n      type: deflt\n    }])) {\n      types = [{\n        type: deflt\n      }];\n      can = true;\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n        var first = tr.mapping.map($from.before()),\n            $first = tr.doc.resolve(first);\n\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n        }\n      }\n    }\n\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\n\n\nfunction splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && function (tr) {\n    var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n\n    if (marks) {\n      tr.ensureMarks(marks);\n    }\n\n    dispatch(tr);\n  });\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\n\n\nfunction selectParentNode(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var to = ref.to;\n  var pos;\n  var same = $from.sharedDepth(to);\n\n  if (same == 0) {\n    return false;\n  }\n\n  pos = $from.before(same);\n\n  if (dispatch) {\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\n\n\nfunction selectAll(state, dispatch) {\n  if (dispatch) {\n    dispatch(state.tr.setSelection(new AllSelection(state.doc)));\n  }\n\n  return true;\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  var before = $pos.nodeBefore,\n      after = $pos.nodeAfter,\n      index = $pos.index();\n\n  if (!before || !after || !before.type.compatibleContent(after.type)) {\n    return false;\n  }\n\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) {\n      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos))) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  var before = $cut.nodeBefore,\n      after = $cut.nodeAfter,\n      conn,\n      match;\n\n  if (before.type.spec.isolating || after.type.spec.isolating) {\n    return false;\n  }\n\n  if (joinMaybeClear(state, $cut, dispatch)) {\n    return true;\n  }\n\n  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n\n  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      var end = $cut.pos + after.nodeSize,\n          wrap = Fragment.empty;\n\n      for (var i = conn.length - 1; i >= 0; i--) {\n        wrap = Fragment.from(conn[i].create(null, wrap));\n      }\n\n      wrap = Fragment.from(before.copy(wrap));\n      var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));\n      var joinAt = end + 2 * conn.length;\n\n      if (canJoin(tr.doc, joinAt)) {\n        tr.join(joinAt);\n      }\n\n      dispatch(tr.scrollIntoView());\n    }\n\n    return true;\n  }\n\n  var selAfter = Selection.findFrom($cut, 1);\n  var range = selAfter && selAfter.$from.blockRange(selAfter.$to),\n      target = range && liftTarget(range);\n\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) {\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    var at = before,\n        wrap$1 = [];\n\n    for (;;) {\n      wrap$1.push(at);\n\n      if (at.isTextblock) {\n        break;\n      }\n\n      at = at.lastChild;\n    }\n\n    var afterText = after,\n        afterDepth = 1;\n\n    for (; !afterText.isTextblock; afterText = afterText.firstChild) {\n      afterDepth++;\n    }\n\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        var end$1 = Fragment.empty;\n\n        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) {\n          end$1 = Fragment.from(wrap$1[i$1].copy(end$1));\n        }\n\n        var tr$1 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end$1, wrap$1.length, 0), 0, true));\n        dispatch(tr$1.scrollIntoView());\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction selectTextblockSide(side) {\n  return function (state, dispatch) {\n    var sel = state.selection,\n        $pos = side < 0 ? sel.$from : sel.$to;\n    var depth = $pos.depth;\n\n    while ($pos.node(depth).isInline) {\n      if (!depth) {\n        return false;\n      }\n\n      depth--;\n    }\n\n    if (!$pos.node(depth).isTextblock) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n    }\n\n    return true;\n  };\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Moves the cursor to the start of current text block.\n\n\nvar selectTextblockStart = selectTextblockSide(-1); // :: (EditorState, ?(tr: Transaction)) → bool\n// Moves the cursor to the end of current text block.\n\nvar selectTextblockEnd = selectTextblockSide(1); // Parameterized commands\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\n\nfunction wrapIn(nodeType, attrs) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to),\n        wrapping = range && findWrapping(range, nodeType, attrs);\n\n    if (!wrapping) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n    }\n\n    return true;\n  };\n} // :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\n\n\nfunction setBlockType(nodeType, attrs) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var from = ref.from;\n    var to = ref.to;\n    var applicable = false;\n    state.doc.nodesBetween(from, to, function (node, pos) {\n      if (applicable) {\n        return false;\n      }\n\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) {\n        return;\n      }\n\n      if (node.type == nodeType) {\n        applicable = true;\n      } else {\n        var $pos = state.doc.resolve(pos),\n            index = $pos.index();\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n      }\n    });\n\n    if (!applicable) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView());\n    }\n\n    return true;\n  };\n}\n\nfunction markApplies(doc, ranges, type) {\n  var loop = function (i) {\n    var ref = ranges[i];\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, function (node) {\n      if (can) {\n        return false;\n      }\n\n      can = node.inlineContent && node.type.allowsMarkType(type);\n    });\n\n    if (can) {\n      return {\n        v: true\n      };\n    }\n  };\n\n  for (var i = 0; i < ranges.length; i++) {\n    var returned = loop(i);\n    if (returned) return returned.v;\n  }\n\n  return false;\n} // :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\n\n\nfunction toggleMark(markType, attrs) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var empty = ref.empty;\n    var $cursor = ref.$cursor;\n    var ranges = ref.ranges;\n\n    if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) {\n      return false;\n    }\n\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks())) {\n          dispatch(state.tr.removeStoredMark(markType));\n        } else {\n          dispatch(state.tr.addStoredMark(markType.create(attrs)));\n        }\n      } else {\n        var has = false,\n            tr = state.tr;\n\n        for (var i = 0; !has && i < ranges.length; i++) {\n          var ref$1 = ranges[i];\n          var $from = ref$1.$from;\n          var $to = ref$1.$to;\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n        }\n\n        for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n          var ref$2 = ranges[i$1];\n          var $from$1 = ref$2.$from;\n          var $to$1 = ref$2.$to;\n\n          if (has) {\n            tr.removeMark($from$1.pos, $to$1.pos, markType);\n          } else {\n            var from = $from$1.pos,\n                to = $to$1.pos,\n                start = $from$1.nodeAfter,\n                end = $to$1.nodeBefore;\n            var spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n            var spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n\n            if (from + spaceStart < to) {\n              from += spaceStart;\n              to -= spaceEnd;\n            }\n\n            tr.addMark(from, to, markType.create(attrs));\n          }\n        }\n\n        dispatch(tr.scrollIntoView());\n      }\n    }\n\n    return true;\n  };\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return function (tr) {\n    if (!tr.isGeneric) {\n      return dispatch(tr);\n    }\n\n    var ranges = [];\n\n    for (var i = 0; i < tr.mapping.maps.length; i++) {\n      var map = tr.mapping.maps[i];\n\n      for (var j = 0; j < ranges.length; j++) {\n        ranges[j] = map.map(ranges[j]);\n      }\n\n      map.forEach(function (_s, _e, from, to) {\n        return ranges.push(from, to);\n      });\n    } // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n\n\n    var joinable = [];\n\n    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {\n      var from = ranges[i$1],\n          to = ranges[i$1 + 1];\n      var $from = tr.doc.resolve(from),\n          depth = $from.sharedDepth(to),\n          parent = $from.node(depth);\n\n      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        var after = parent.maybeChild(index);\n\n        if (!after) {\n          break;\n        }\n\n        if (index && joinable.indexOf(pos) == -1) {\n          var before = parent.child(index - 1);\n\n          if (before.type == after.type && isJoinable(before, after)) {\n            joinable.push(pos);\n          }\n        }\n\n        pos += after.nodeSize;\n      }\n    } // Join the joinable points\n\n\n    joinable.sort(function (a, b) {\n      return a - b;\n    });\n\n    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {\n      if (canJoin(tr.doc, joinable[i$2])) {\n        tr.join(joinable[i$2]);\n      }\n    }\n\n    dispatch(tr);\n  };\n} // :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\n\n\nfunction autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    var types = isJoinable;\n\n    isJoinable = function (node) {\n      return types.indexOf(node.type.name) > -1;\n    };\n  }\n\n  return function (state, dispatch, view) {\n    return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view);\n  };\n} // :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\n\n\nfunction chainCommands() {\n  var commands = [],\n      len = arguments.length;\n\n  while (len--) commands[len] = arguments[len];\n\n  return function (state, dispatch, view) {\n    for (var i = 0; i < commands.length; i++) {\n      if (commands[i](state, dispatch, view)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n\nvar backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nvar del = chainCommands(deleteSelection, joinForward, selectNodeForward); // :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\n\nvar pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}; // :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\n\nvar macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n};\n\nfor (var key in pcBaseKeymap) {\n  macBaseKeymap[key] = pcBaseKeymap[key];\n}\n\npcBaseKeymap.Home = selectTextblockStart;\npcBaseKeymap.End = selectTextblockEnd; // declare global: os, navigator\n\nvar mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false; // :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\n\nvar baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, selectTextblockEnd, selectTextblockStart, setBlockType, splitBlock, splitBlockKeepMarks, toggleMark, wrapIn };","map":{"version":3,"mappings":"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","names":["deleteSelection","state","dispatch","selection","empty","tr","scrollIntoView","joinBackward","view","$cursor","endOfTextblock","parentOffset","let","$cut","findCutBefore","range","blockRange","target","liftTarget","lift","before","nodeBefore","type","spec","isolating","deleteBarrier","parent","content","size","textblockAt","NodeSelection","isSelectable","delStep","replaceStep","doc","after","Slice","slice","to","from","step","setSelection","Selection","findFrom","resolve","mapping","map","pos","create","nodeSize","isAtom","depth","delete","node","side","only","firstChild","lastChild","isTextblock","childCount","selectNodeBackward","$head","$pos","i","index","joinForward","findCutAfter","nodeAfter","selectNodeForward","joinUp","sel","nodeSel","point","canJoin","joinPoint","join","joinDown","$from","$to","newlineInCode","code","sameParent","$anchor","insertText","defaultBlockAt","match","edgeCount","edge","hasRequiredAttrs","exitCode","above","indexAfter","contentMatchAt","canReplaceWith","replaceWith","createAndFill","near","createParagraphNear","AllSelection","inlineContent","insert","TextSelection","liftEmptyBlock","end","canSplit","split","splitBlock","isBlock","atEnd","deflt","types","can","first","$first","setNodeMarkup","splitBlockKeepMarks","marks","storedMarks","ensureMarks","selectParentNode","same","sharedDepth","selectAll","joinMaybeClear","compatibleContent","canReplace","clearIncompatible","conn","canDelAfter","findWrapping","matchType","validEnd","wrap","Fragment","length","copy","ReplaceAroundStep","joinAt","selAfter","at","push","afterText","afterDepth","selectTextblockSide","isInline","start","selectTextblockStart","selectTextblockEnd","wrapIn","nodeType","attrs","wrapping","setBlockType","applicable","nodesBetween","hasMarkup","markApplies","ranges","allowsMarkType","v","toggleMark","markType","isInSet","removeStoredMark","addStoredMark","has","rangeHasMark","removeMark","spaceStart","isText","exec","text","spaceEnd","addMark","wrapDispatchForJoin","isJoinable","isGeneric","maps","j","forEach","_s","_e","joinable","maybeChild","indexOf","child","sort","a","b","autoJoin","command","Array","isArray","name","chainCommands","commands","backspace","del","pcBaseKeymap","macBaseKeymap","key","Home","End","const","mac","navigator","test","platform","os","baseKeymap"],"sources":["/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-commands/src/commands.js"],"sourcesContent":["import {joinPoint, canJoin, findWrapping, liftTarget, canSplit, ReplaceAroundStep, replaceStep} from \"prosemirror-transform\"\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection, NodeSelection, AllSelection} from \"prosemirror-state\"\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\nexport function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nexport function joinBackward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    return false\n\n  let $cut = findCutBefore($cursor)\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && liftTarget(range)\n    if (target == null) return false\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  let before = $cut.nodeBefore\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    return true\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty)\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep)\n        tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                        : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side, only) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild)) {\n    if (node.isTextblock) return true\n    if (only && node.childCount != 1) return false\n  }\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nexport function selectNodeBackward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false\n    $cut = findCutBefore($head)\n  }\n  let node = $cut && $cut.nodeBefore\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView())\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1))\n    if ($pos.node(i).type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nexport function joinForward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    return false\n\n  let $cut = findCutAfter($cursor)\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) return false\n\n  let after = $cut.nodeAfter\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) return true\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty)\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep)\n        tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                        : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nexport function selectNodeForward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false\n    $cut = findCutAfter($head)\n  }\n  let node = $cut && $cut.nodeAfter\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView())\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    let parent = $pos.node(i)\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1))\n    if (parent.type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nexport function joinUp(state, dispatch) {\n  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false\n    point = sel.from\n  } else {\n    point = joinPoint(state.doc, sel.from, -1)\n    if (point == null) return false\n  }\n  if (dispatch) {\n    let tr = state.tr.join(point)\n    if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nexport function joinDown(state, dispatch) {\n  let sel = state.selection, point\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false\n    point = sel.to\n  } else {\n    point = joinPoint(state.doc, sel.to, 1)\n    if (point == null) return false\n  }\n  if (dispatch)\n    dispatch(state.tr.join(point).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nexport function lift(state, dispatch) {\n  let {$from, $to} = state.selection\n  let range = $from.blockRange($to), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nexport function newlineInCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView())\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let {type} = match.edge(i)\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nexport function exitCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after))\n  if (!above.canReplaceWith(after, after, type)) return false\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nexport function createParagraphNear(state, dispatch) {\n  let sel = state.selection, {$from, $to} = sel\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false\n  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()))\n  if (!type || !type.isTextblock) return false\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos\n    let tr = state.tr.insert(side, type.createAndFill())\n    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nexport function liftEmptyBlock(state, dispatch) {\n  let {$cursor} = state.selection\n  if (!$cursor || $cursor.parent.content.size) return false\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before()\n    if (canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView())\n      return true\n    }\n  }\n  let range = $cursor.blockRange(), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nexport function splitBlock(state, dispatch) {\n  let {$from, $to} = state.selection\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false\n    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView())\n    return true\n  }\n\n  if (!$from.parent.isBlock) return false\n\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size\n    let tr = state.tr\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) tr.deleteSelection()\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n    let types = atEnd && deflt ? [{type: deflt}] : null\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}]\n      can = true\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n        let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first)\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n      }\n    }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nexport function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (tr => {\n    let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n    if (marks) tr.ensureMarks(marks)\n    dispatch(tr)\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nexport function selectParentNode(state, dispatch) {\n  let {$from, to} = state.selection, pos\n  let same = $from.sharedDepth(to)\n  if (same == 0) return false\n  pos = $from.before(same)\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)))\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\nexport function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)))\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView())\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    return false\n  if (dispatch)\n    dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView())\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n  if (before.type.spec.isolating || after.type.spec.isolating) return false\n  if (joinMaybeClear(state, $cut, dispatch)) return true\n\n  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1)\n  if (canDelAfter &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap = Fragment.empty\n      for (let i = conn.length - 1; i >= 0; i--)\n        wrap = Fragment.from(conn[i].create(null, wrap))\n      wrap = Fragment.from(before.copy(wrap))\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true))\n      let joinAt = end + 2 * conn.length\n      if (canJoin(tr.doc, joinAt)) tr.join(joinAt)\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  let selAfter = Selection.findFrom($cut, 1)\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    let at = before, wrap = []\n    for (;;) {\n      wrap.push(at)\n      if (at.isTextblock) break\n      at = at.lastChild\n    }\n    let afterText = after, afterDepth = 1\n    for (; !afterText.isTextblock; afterText = afterText.firstChild) afterDepth++\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        let end = Fragment.empty\n        for (let i = wrap.length - 1; i >= 0; i--) end = Fragment.from(wrap[i].copy(end))\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize,\n                                                     $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth,\n                                                     new Slice(end, wrap.length, 0), 0, true))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction selectTextblockSide(side) {\n  return function(state, dispatch) {\n    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to\n    let depth = $pos.depth\n    while ($pos.node(depth).isInline) {\n      if (!depth) return false\n      depth--\n    }\n    if (!$pos.node(depth).isTextblock) return false\n    if (dispatch)\n      dispatch(state.tr.setSelection(TextSelection.create(\n        state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))))\n    return true\n  }\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Moves the cursor to the start of current text block.\nexport const selectTextblockStart = selectTextblockSide(-1)\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Moves the cursor to the end of current text block.\nexport const selectTextblockEnd = selectTextblockSide(1)\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nexport function wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return false\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nexport function setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {from, to} = state.selection\n    let applicable = false\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable) return false\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return\n      if (node.type == nodeType) {\n        applicable = true\n      } else {\n        let $pos = state.doc.resolve(pos), index = $pos.index()\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType)\n      }\n    })\n    if (!applicable) return false\n    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView())\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let {$from, $to} = ranges[i]\n    let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (can) return false\n      can = node.inlineContent && node.type.allowsMarkType(type)\n    })\n    if (can) return true\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nexport function toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    let {empty, $cursor, ranges} = state.selection\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          dispatch(state.tr.removeStoredMark(markType))\n        else\n          dispatch(state.tr.addStoredMark(markType.create(attrs)))\n      } else {\n        let has = false, tr = state.tr\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType)\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          if (has) {\n            tr.removeMark($from.pos, $to.pos, markType)\n          } else {\n            let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore\n            let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0\n            let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0\n            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd }\n            tr.addMark(from, to, markType.create(attrs))\n          }\n        }\n        dispatch(tr.scrollIntoView())\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return tr => {\n    if (!tr.isGeneric) return dispatch(tr)\n\n    let ranges = []\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i]\n      for (let j = 0; j < ranges.length; j++)\n        ranges[j] = map.map(ranges[j])\n      map.forEach((_s, _e, from, to) => ranges.push(from, to))\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    let joinable = []\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i], to = ranges[i + 1]\n      let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index)\n        if (!after) break\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1)\n          if (before.type == after.type && isJoinable(before, after))\n            joinable.push(pos)\n        }\n        pos += after.nodeSize\n      }\n    }\n    // Join the joinable points\n    joinable.sort((a, b) => a - b)\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if (canJoin(tr.doc, joinable[i])) tr.join(joinable[i])\n    }\n    dispatch(tr)\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nexport function autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    let types = isJoinable\n    isJoinable = node => types.indexOf(node.type.name) > -1\n  }\n  return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view)\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nexport function chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++)\n      if (commands[i](state, dispatch, view)) return true\n    return false\n  }\n}\n\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward)\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward)\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nexport let pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nexport let macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n}\nfor (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key]\n\npcBaseKeymap.Home = selectTextblockStart\npcBaseKeymap.End = selectTextblockEnd\n\n// declare global: os, navigator\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nexport let baseKeymap = mac ? macBaseKeymap : pcBaseKeymap\n"]},"metadata":{},"sourceType":"module"}