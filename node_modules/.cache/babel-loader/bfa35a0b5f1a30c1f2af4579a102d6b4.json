{"ast":null,"code":"import { keyName, base } from 'w3c-keyname';\nimport { Plugin } from 'prosemirror-state'; // declare global: navigator\n\nvar mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/),\n      result = parts[parts.length - 1];\n\n  if (result == \"Space\") {\n    result = \" \";\n  }\n\n  var alt, ctrl, shift, meta;\n\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (mac) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n  }\n\n  if (alt) {\n    result = \"Alt-\" + result;\n  }\n\n  if (ctrl) {\n    result = \"Ctrl-\" + result;\n  }\n\n  if (meta) {\n    result = \"Meta-\" + result;\n  }\n\n  if (shift) {\n    result = \"Shift-\" + result;\n  }\n\n  return result;\n}\n\nfunction normalize(map) {\n  var copy = Object.create(null);\n\n  for (var prop in map) {\n    copy[normalizeKeyName(prop)] = map[prop];\n  }\n\n  return copy;\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) {\n    name = \"Alt-\" + name;\n  }\n\n  if (event.ctrlKey) {\n    name = \"Ctrl-\" + name;\n  }\n\n  if (event.metaKey) {\n    name = \"Meta-\" + name;\n  }\n\n  if (shift !== false && event.shiftKey) {\n    name = \"Shift-\" + name;\n  }\n\n  return name;\n} // :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`—a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\n\n\nfunction keymap(bindings) {\n  return new Plugin({\n    props: {\n      handleKeyDown: keydownHandler(bindings)\n    }\n  });\n} // :: (Object) → (view: EditorView, event: dom.Event) → bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap)), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) that handles them.\n\n\nfunction keydownHandler(bindings) {\n  var map = normalize(bindings);\n  return function (view, event) {\n    var name = keyName(event),\n        isChar = name.length == 1 && name != \" \",\n        baseName;\n    var direct = map[modifiers(name, event, !isChar)];\n\n    if (direct && direct(view.state, view.dispatch, view)) {\n      return true;\n    }\n\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {\n      // Try falling back to the keyCode when there's a modifier\n      // active or the character produced isn't ASCII, and our table\n      // produces a different name from the the keyCode. See #668,\n      // #1060\n      var fromCode = map[modifiers(baseName, event, true)];\n\n      if (fromCode && fromCode(view.state, view.dispatch, view)) {\n        return true;\n      }\n    } else if (isChar && event.shiftKey) {\n      // Otherwise, if shift is active, also try the binding with the\n      // Shift- prefix enabled. See #997\n      var withShift = map[modifiers(name, event, true)];\n\n      if (withShift && withShift(view.state, view.dispatch, view)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n\nexport { keydownHandler, keymap };","map":{"version":3,"mappings":";4CAGA;;AAEAA,IAAMC,GAAG,GAAG,OAAOC,SAAP,IAAoB,WAApB,GAAkC,qBAAqBC,IAArB,CAA0BD,SAAS,CAACE,QAApC,CAAlC,GAAkF,KAA9FJ;;AAEA,SAASK,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9BC,MAAIC,KAAK,GAAGF,IAAI,CAACG,KAAL,CAAW,QAAX,CAAZF;AAAAA,MAAkCG,MAAM,GAAGF,KAAK,CAACA,KAAK,CAACG,MAAN,GAAe,CAAhB,CAAhDJ;;AACA,MAAIG,MAAM,IAAI,OAAd,EAAqB;AAAEA,UAAM,GAAG,GAAT;AAAY;;AACnCH,MAAIK,GAAJL,EAASM,IAATN,EAAeO,KAAfP,EAAsBQ,IAAtBR;;AACA,OAAKA,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,KAAK,CAACG,MAAN,GAAe,CAAnC,EAAsCK,CAAC,EAAvC,EAA2C;AACzCT,QAAIU,GAAG,GAAGT,KAAK,CAACQ,CAAD,CAAfT;;AACA,QAAI,kBAAkBJ,IAAlB,CAAuBc,GAAvB,CAAJ,EAA+B;AAAEF,UAAI,GAAG,IAAP;AAAW,KAA5C,MACK,IAAI,YAAYZ,IAAZ,CAAiBc,GAAjB,CAAJ,EAAyB;AAAEL,SAAG,GAAG,IAAN;AAAU,KAArC,MACA,IAAI,sBAAsBT,IAAtB,CAA2Bc,GAA3B,CAAJ,EAAmC;AAAEJ,UAAI,GAAG,IAAP;AAAW,KAAhD,MACA,IAAI,cAAcV,IAAd,CAAmBc,GAAnB,CAAJ,EAA2B;AAAEH,WAAK,GAAG,IAAR;AAAY,KAAzC,MACA,IAAI,SAASX,IAAT,CAAcc,GAAd,CAAJ,EAAwB;AAAE,UAAIhB,GAAJ,EAAO;AAAEc,YAAI,GAAG,IAAP;AAAY,OAArB,MAAqB;AAAMF,YAAI,GAAG,IAAP;AAAW;AAAE,KAAlE,MACT;AAAS,YAAM,IAAIK,KAAJ,CAAU,iCAAiCD,GAA3C,CAAN;AAAqD;AAC3D;;AACD,MAAIL,GAAJ,EAAO;AAAEF,UAAM,GAAG,SAASA,MAAlB;AAAwB;;AACjC,MAAIG,IAAJ,EAAQ;AAAEH,UAAM,GAAG,UAAUA,MAAnB;AAAyB;;AACnC,MAAIK,IAAJ,EAAQ;AAAEL,UAAM,GAAG,UAAUA,MAAnB;AAAyB;;AACnC,MAAII,KAAJ,EAAS;AAAEJ,UAAM,GAAG,WAAWA,MAApB;AAA0B;;AACrC,SAAOA,MAAP;AACD;;AAED,SAASS,SAAT,CAAmBC,GAAnB,EAAwB;AACtBb,MAAIc,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAXhB;;AACA,OAAKA,IAAIiB,IAAT,IAAiBJ,GAAjB,EAAoB;AAAEC,QAAI,CAAChB,gBAAgB,CAACmB,IAAD,CAAjB,CAAJ,GAA+BJ,GAAG,CAACI,IAAD,CAAlC;AAAwC;;AAC9D,SAAOH,IAAP;AACD;;AAED,SAASI,SAAT,CAAmBnB,IAAnB,EAAyBoB,KAAzB,EAAgCZ,KAAhC,EAAuC;AACrC,MAAIY,KAAK,CAACC,MAAV,EAAgB;AAAErB,QAAI,GAAG,SAASA,IAAhB;AAAoB;;AACtC,MAAIoB,KAAK,CAACE,OAAV,EAAiB;AAAEtB,QAAI,GAAG,UAAUA,IAAjB;AAAqB;;AACxC,MAAIoB,KAAK,CAACG,OAAV,EAAiB;AAAEvB,QAAI,GAAG,UAAUA,IAAjB;AAAqB;;AACxC,MAAIQ,KAAK,KAAK,KAAV,IAAmBY,KAAK,CAACI,QAA7B,EAAqC;AAAExB,QAAI,GAAG,WAAWA,IAAlB;AAAsB;;AAC7D,SAAOA,IAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASyB,MAAT,CAAgBC,QAAhB,EAA0B;AAC/B,SAAO,IAAIC,MAAJ,CAAW;AAACC,SAAK,EAAE;AAACC,mBAAa,EAAEC,cAAc,CAACJ,QAAD;AAA9B;AAAR,GAAX,CAAP;AACD,C,CAED;AACA;AACA;AACA;;;AACO,SAASI,cAAT,CAAwBJ,QAAxB,EAAkC;AACvCzB,MAAIa,GAAG,GAAGD,SAAS,CAACa,QAAD,CAAnBzB;AACA,SAAO,UAAS8B,IAAT,EAAeX,KAAf,EAAsB;AAC3BnB,QAAID,IAAI,GAAGgC,OAAO,CAACZ,KAAD,CAAlBnB;AAAAA,QAA2BgC,MAAM,GAAGjC,IAAI,CAACK,MAAL,IAAe,CAAf,IAAoBL,IAAI,IAAI,GAAhEC;AAAAA,QAAqEiC,QAArEjC;AACAA,QAAIkC,MAAM,GAAGrB,GAAG,CAACK,SAAS,CAACnB,IAAD,EAAOoB,KAAP,EAAc,CAACa,MAAf,CAAV,CAAhBhC;;AACA,QAAIkC,MAAM,IAAIA,MAAM,CAACJ,IAAI,CAACK,KAAN,EAAaL,IAAI,CAACM,QAAlB,EAA4BN,IAA5B,CAApB,EAAqD;AAAE,aAAO,IAAP;AAAW;;AAClE,QAAIE,MAAM,KAAKb,KAAK,CAACI,QAAN,IAAkBJ,KAAK,CAACC,MAAxB,IAAkCD,KAAK,CAACG,OAAxC,IAAmDvB,IAAI,CAACsC,UAAL,CAAgB,CAAhB,IAAqB,GAA7E,CAAN,KACCJ,QAAQ,GAAGK,IAAI,CAACnB,KAAK,CAACoB,OAAP,CADhB,KACoCN,QAAQ,IAAIlC,IADpD,EAC0D;AAC9D;AACA;AACA;AACA;AACMC,UAAIwC,QAAQ,GAAG3B,GAAG,CAACK,SAAS,CAACe,QAAD,EAAWd,KAAX,EAAkB,IAAlB,CAAV,CAAlBnB;;AACA,UAAIwC,QAAQ,IAAIA,QAAQ,CAACV,IAAI,CAACK,KAAN,EAAaL,IAAI,CAACM,QAAlB,EAA4BN,IAA5B,CAAxB,EAAyD;AAAE,eAAO,IAAP;AAAW;AACvE,KARD,MAQO,IAAIE,MAAM,IAAIb,KAAK,CAACI,QAApB,EAA8B;AACzC;AACA;AACMvB,UAAIyC,SAAS,GAAG5B,GAAG,CAACK,SAAS,CAACnB,IAAD,EAAOoB,KAAP,EAAc,IAAd,CAAV,CAAnBnB;;AACA,UAAIyC,SAAS,IAAIA,SAAS,CAACX,IAAI,CAACK,KAAN,EAAaL,IAAI,CAACM,QAAlB,EAA4BN,IAA5B,CAA1B,EAA2D;AAAE,eAAO,IAAP;AAAW;AACzE;;AACD,WAAO,KAAP;AACD,GAnBD;AAoBF","names":["const","mac","navigator","test","platform","normalizeKeyName","name","let","parts","split","result","length","alt","ctrl","shift","meta","i","mod","Error","normalize","map","copy","Object","create","prop","modifiers","event","altKey","ctrlKey","metaKey","shiftKey","keymap","bindings","Plugin","props","handleKeyDown","keydownHandler","view","keyName","isChar","baseName","direct","state","dispatch","charCodeAt","base","keyCode","fromCode","withShift"],"sources":["/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-keymap/src/keymap.js"],"sourcesContent":["import {base, keyName} from \"w3c-keyname\"\nimport {Plugin} from \"prosemirror-state\"\n\n// declare global: navigator\n\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false\n\nfunction normalizeKeyName(name) {\n  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1]\n  if (result == \"Space\") result = \" \"\n  let alt, ctrl, shift, meta\n  for (let i = 0; i < parts.length - 1; i++) {\n    let mod = parts[i]\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true\n    else if (/^a(lt)?$/i.test(mod)) alt = true\n    else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true\n    else if (/^s(hift)?$/i.test(mod)) shift = true\n    else if (/^mod$/i.test(mod)) { if (mac) meta = true; else ctrl = true }\n    else throw new Error(\"Unrecognized modifier name: \" + mod)\n  }\n  if (alt) result = \"Alt-\" + result\n  if (ctrl) result = \"Ctrl-\" + result\n  if (meta) result = \"Meta-\" + result\n  if (shift) result = \"Shift-\" + result\n  return result\n}\n\nfunction normalize(map) {\n  let copy = Object.create(null)\n  for (let prop in map) copy[normalizeKeyName(prop)] = map[prop]\n  return copy\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name\n  if (event.ctrlKey) name = \"Ctrl-\" + name\n  if (event.metaKey) name = \"Meta-\" + name\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name\n  return name\n}\n\n// :: (Object) → Plugin\n// Create a keymap plugin for the given set of bindings.\n//\n// Bindings should map key names to [command](#commands)-style\n// functions, which will be called with `(EditorState, dispatch,\n// EditorView)` arguments, and should return true when they've handled\n// the key. Note that the view argument isn't part of the command\n// protocol, but can be used as an escape hatch if a binding needs to\n// directly interact with the UI.\n//\n// Key names may be strings like `\"Shift-Ctrl-Enter\"`—a key\n// identifier prefixed with zero or more modifiers. Key identifiers\n// are based on the strings that can appear in\n// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n// Use lowercase letters to refer to letter keys (or uppercase letters\n// if you want shift to be held). You may use `\"Space\"` as an alias\n// for the `\" \"` name.\n//\n// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n// `Meta-`) are recognized. For characters that are created by holding\n// shift, the `Shift-` prefix is implied, and should not be added\n// explicitly.\n//\n// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n// other platforms.\n//\n// You can add multiple keymap plugins to an editor. The order in\n// which they appear determines their precedence (the ones early in\n// the array get to dispatch first).\nexport function keymap(bindings) {\n  return new Plugin({props: {handleKeyDown: keydownHandler(bindings)}})\n}\n\n// :: (Object) → (view: EditorView, event: dom.Event) → bool\n// Given a set of bindings (using the same format as\n// [`keymap`](#keymap.keymap)), return a [keydown\n// handler](#view.EditorProps.handleKeyDown) that handles them.\nexport function keydownHandler(bindings) {\n  let map = normalize(bindings)\n  return function(view, event) {\n    let name = keyName(event), isChar = name.length == 1 && name != \" \", baseName\n    let direct = map[modifiers(name, event, !isChar)]\n    if (direct && direct(view.state, view.dispatch, view)) return true\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n        (baseName = base[event.keyCode]) && baseName != name) {\n      // Try falling back to the keyCode when there's a modifier\n      // active or the character produced isn't ASCII, and our table\n      // produces a different name from the the keyCode. See #668,\n      // #1060\n      let fromCode = map[modifiers(baseName, event, true)]\n      if (fromCode && fromCode(view.state, view.dispatch, view)) return true\n    } else if (isChar && event.shiftKey) {\n      // Otherwise, if shift is active, also try the binding with the\n      // Shift- prefix enabled. See #997\n      let withShift = map[modifiers(name, event, true)]\n      if (withShift && withShift(view.state, view.dispatch, view)) return true\n    }\n    return false\n  }\n}\n"]},"metadata":{},"sourceType":"module"}