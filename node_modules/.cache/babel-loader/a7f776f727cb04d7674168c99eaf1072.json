{"ast":null,"code":"import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state'; // ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\n\nvar max_empty_items = 500;\n\nvar Branch = function Branch(items, eventCount) {\n  this.items = items;\n  this.eventCount = eventCount;\n}; // : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n// Pop the latest event off the branch's history and apply it\n// to a document transform.\n\n\nBranch.prototype.popEvent = function popEvent(state, preserveItems) {\n  var this$1 = this;\n\n  if (this.eventCount == 0) {\n    return null;\n  }\n\n  var end = this.items.length;\n\n  for (;; end--) {\n    var next = this.items.get(end - 1);\n\n    if (next.selection) {\n      --end;\n      break;\n    }\n  }\n\n  var remap, mapFrom;\n\n  if (preserveItems) {\n    remap = this.remapping(end, this.items.length);\n    mapFrom = remap.maps.length;\n  }\n\n  var transform = state.tr;\n  var selection, remaining;\n  var addAfter = [],\n      addBefore = [];\n  this.items.forEach(function (item, i) {\n    if (!item.step) {\n      if (!remap) {\n        remap = this$1.remapping(end, i + 1);\n        mapFrom = remap.maps.length;\n      }\n\n      mapFrom--;\n      addBefore.push(item);\n      return;\n    }\n\n    if (remap) {\n      addBefore.push(new Item(item.map));\n      var step = item.step.map(remap.slice(mapFrom)),\n          map;\n\n      if (step && transform.maybeStep(step).doc) {\n        map = transform.mapping.maps[transform.mapping.maps.length - 1];\n        addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length));\n      }\n\n      mapFrom--;\n\n      if (map) {\n        remap.appendMap(map, mapFrom);\n      }\n    } else {\n      transform.maybeStep(item.step);\n    }\n\n    if (item.selection) {\n      selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n      remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);\n      return false;\n    }\n  }, this.items.length, 0);\n  return {\n    remaining: remaining,\n    transform: transform,\n    selection: selection\n  };\n}; // : (Transform, ?SelectionBookmark, Object) → Branch\n// Create a new branch with the given transform added.\n\n\nBranch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {\n  var newItems = [],\n      eventCount = this.eventCount;\n  var oldItems = this.items,\n      lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n\n  for (var i = 0; i < transform.steps.length; i++) {\n    var step = transform.steps[i].invert(transform.docs[i]);\n    var item = new Item(transform.mapping.maps[i], step, selection),\n        merged = void 0;\n\n    if (merged = lastItem && lastItem.merge(item)) {\n      item = merged;\n\n      if (i) {\n        newItems.pop();\n      } else {\n        oldItems = oldItems.slice(0, oldItems.length - 1);\n      }\n    }\n\n    newItems.push(item);\n\n    if (selection) {\n      eventCount++;\n      selection = null;\n    }\n\n    if (!preserveItems) {\n      lastItem = item;\n    }\n  }\n\n  var overflow = eventCount - histOptions.depth;\n\n  if (overflow > DEPTH_OVERFLOW) {\n    oldItems = cutOffEvents(oldItems, overflow);\n    eventCount -= overflow;\n  }\n\n  return new Branch(oldItems.append(newItems), eventCount);\n};\n\nBranch.prototype.remapping = function remapping(from, to) {\n  var maps = new Mapping();\n  this.items.forEach(function (item, i) {\n    var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : null;\n    maps.appendMap(item.map, mirrorPos);\n  }, from, to);\n  return maps;\n};\n\nBranch.prototype.addMaps = function addMaps(array) {\n  if (this.eventCount == 0) {\n    return this;\n  }\n\n  return new Branch(this.items.append(array.map(function (map) {\n    return new Item(map);\n  })), this.eventCount);\n}; // : (Transform, number)\n// When the collab module receives remote changes, the history has\n// to know about those, so that it can adjust the steps that were\n// rebased on top of the remote changes, and include the position\n// maps for the remote changes in its array of items.\n\n\nBranch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {\n  if (!this.eventCount) {\n    return this;\n  }\n\n  var rebasedItems = [],\n      start = Math.max(0, this.items.length - rebasedCount);\n  var mapping = rebasedTransform.mapping;\n  var newUntil = rebasedTransform.steps.length;\n  var eventCount = this.eventCount;\n  this.items.forEach(function (item) {\n    if (item.selection) {\n      eventCount--;\n    }\n  }, start);\n  var iRebased = rebasedCount;\n  this.items.forEach(function (item) {\n    var pos = mapping.getMirror(--iRebased);\n\n    if (pos == null) {\n      return;\n    }\n\n    newUntil = Math.min(newUntil, pos);\n    var map = mapping.maps[pos];\n\n    if (item.step) {\n      var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n      var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n\n      if (selection) {\n        eventCount++;\n      }\n\n      rebasedItems.push(new Item(map, step, selection));\n    } else {\n      rebasedItems.push(new Item(map));\n    }\n  }, start);\n  var newMaps = [];\n\n  for (var i = rebasedCount; i < newUntil; i++) {\n    newMaps.push(new Item(mapping.maps[i]));\n  }\n\n  var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n  var branch = new Branch(items, eventCount);\n\n  if (branch.emptyItemCount() > max_empty_items) {\n    branch = branch.compress(this.items.length - rebasedItems.length);\n  }\n\n  return branch;\n};\n\nBranch.prototype.emptyItemCount = function emptyItemCount() {\n  var count = 0;\n  this.items.forEach(function (item) {\n    if (!item.step) {\n      count++;\n    }\n  });\n  return count;\n}; // Compressing a branch means rewriting it to push the air (map-only\n// items) out. During collaboration, these naturally accumulate\n// because each remote change adds one. The `upto` argument is used\n// to ensure that only the items below a given level are compressed,\n// because `rebased` relies on a clean, untouched set of items in\n// order to associate old items with rebased steps.\n\n\nBranch.prototype.compress = function compress(upto) {\n  if (upto === void 0) upto = this.items.length;\n  var remap = this.remapping(0, upto),\n      mapFrom = remap.maps.length;\n  var items = [],\n      events = 0;\n  this.items.forEach(function (item, i) {\n    if (i >= upto) {\n      items.push(item);\n\n      if (item.selection) {\n        events++;\n      }\n    } else if (item.step) {\n      var step = item.step.map(remap.slice(mapFrom)),\n          map = step && step.getMap();\n      mapFrom--;\n\n      if (map) {\n        remap.appendMap(map, mapFrom);\n      }\n\n      if (step) {\n        var selection = item.selection && item.selection.map(remap.slice(mapFrom));\n\n        if (selection) {\n          events++;\n        }\n\n        var newItem = new Item(map.invert(), step, selection),\n            merged,\n            last = items.length - 1;\n\n        if (merged = items.length && items[last].merge(newItem)) {\n          items[last] = merged;\n        } else {\n          items.push(newItem);\n        }\n      }\n    } else if (item.map) {\n      mapFrom--;\n    }\n  }, this.items.length, 0);\n  return new Branch(RopeSequence.from(items.reverse()), events);\n};\n\nBranch.empty = new Branch(RopeSequence.empty, 0);\n\nfunction cutOffEvents(items, n) {\n  var cutPoint;\n  items.forEach(function (item, i) {\n    if (item.selection && n-- == 0) {\n      cutPoint = i;\n      return false;\n    }\n  });\n  return items.slice(cutPoint);\n}\n\nvar Item = function Item(map, step, selection, mirrorOffset) {\n  // The (forward) step map for this item.\n  this.map = map; // The inverted step\n\n  this.step = step; // If this is non-null, this item is the start of a group, and\n  // this selection is the starting selection for the group (the one\n  // that was active before the first step was applied)\n\n  this.selection = selection; // If this item is the inverse of a previous mapping on the stack,\n  // this points at the inverse's offset\n\n  this.mirrorOffset = mirrorOffset;\n};\n\nItem.prototype.merge = function merge(other) {\n  if (this.step && other.step && !other.selection) {\n    var step = other.step.merge(this.step);\n\n    if (step) {\n      return new Item(step.getMap().invert(), step, this.selection);\n    }\n  }\n}; // The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\n\n\nvar HistoryState = function HistoryState(done, undone, prevRanges, prevTime) {\n  this.done = done;\n  this.undone = undone;\n  this.prevRanges = prevRanges;\n  this.prevTime = prevTime;\n};\n\nvar DEPTH_OVERFLOW = 20; // : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\n\nfunction applyTransaction(history, state, tr, options) {\n  var historyTr = tr.getMeta(historyKey),\n      rebased;\n\n  if (historyTr) {\n    return historyTr.historyState;\n  }\n\n  if (tr.getMeta(closeHistoryKey)) {\n    history = new HistoryState(history.done, history.undone, null, 0);\n  }\n\n  var appended = tr.getMeta(\"appendedTransaction\");\n\n  if (tr.steps.length == 0) {\n    return history;\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo) {\n      return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);\n    } else {\n      return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)), null, history.prevTime);\n    }\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    var newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) {\n    return false;\n  }\n\n  if (!transform.docChanged) {\n    return true;\n  }\n\n  var adjacent = false;\n  transform.mapping.maps[0].forEach(function (start, end) {\n    for (var i = 0; i < prevRanges.length; i += 2) {\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i]) {\n        adjacent = true;\n      }\n    }\n  });\n  return adjacent;\n}\n\nfunction rangesFor(map) {\n  var result = [];\n  map.forEach(function (_from, _to, from, to) {\n    return result.push(from, to);\n  });\n  return result;\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) {\n    return null;\n  }\n\n  var result = [];\n\n  for (var i = 0; i < ranges.length; i += 2) {\n    var from = mapping.map(ranges[i], 1),\n        to = mapping.map(ranges[i + 1], -1);\n\n    if (from <= to) {\n      result.push(from, to);\n    }\n  }\n\n  return result;\n} // : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\n\n\nfunction histTransaction(history, state, dispatch, redo) {\n  var preserveItems = mustPreserveItems(state),\n      histOptions = historyKey.get(state).spec.config;\n  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n\n  if (!pop) {\n    return;\n  }\n\n  var selection = pop.selection.resolve(pop.transform.doc);\n  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {\n    redo: redo,\n    historyState: newHist\n  }).scrollIntoView());\n}\n\nvar cachedPreserveItems = false,\n    cachedPreserveItemsPlugins = null; // Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\n\nfunction mustPreserveItems(state) {\n  var plugins = state.plugins;\n\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n\n    for (var i = 0; i < plugins.length; i++) {\n      if (plugins[i].spec.historyPreserveItems) {\n        cachedPreserveItems = true;\n        break;\n      }\n    }\n  }\n\n  return cachedPreserveItems;\n} // :: (Transaction) → Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\n\n\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true);\n}\n\nvar historyKey = new PluginKey(\"history\");\nvar closeHistoryKey = new PluginKey(\"closeHistory\"); // :: (?Object) → Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\n\nfunction history(config) {\n  config = {\n    depth: config && config.depth || 100,\n    newGroupDelay: config && config.newGroupDelay || 500\n  };\n  return new Plugin({\n    key: historyKey,\n    state: {\n      init: function init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0);\n      },\n      apply: function apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config);\n      }\n    },\n    config: config,\n    props: {\n      handleDOMEvents: {\n        beforeinput: function beforeinput(view, e) {\n          var handled = e.inputType == \"historyUndo\" ? undo(view.state, view.dispatch) : e.inputType == \"historyRedo\" ? redo(view.state, view.dispatch) : false;\n\n          if (handled) {\n            e.preventDefault();\n          }\n\n          return handled;\n        }\n      }\n    }\n  });\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that undoes the last change, if any.\n\n\nfunction undo(state, dispatch) {\n  var hist = historyKey.getState(state);\n\n  if (!hist || hist.done.eventCount == 0) {\n    return false;\n  }\n\n  if (dispatch) {\n    histTransaction(hist, state, dispatch, false);\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that redoes the last undone change, if any.\n\n\nfunction redo(state, dispatch) {\n  var hist = historyKey.getState(state);\n\n  if (!hist || hist.undone.eventCount == 0) {\n    return false;\n  }\n\n  if (dispatch) {\n    histTransaction(hist, state, dispatch, true);\n  }\n\n  return true;\n} // :: (EditorState) → number\n// The amount of undoable events available in a given state.\n\n\nfunction undoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0;\n} // :: (EditorState) → number\n// The amount of redoable events available in a given editor state.\n\n\nfunction redoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0;\n}\n\nexport { HistoryState, closeHistory, history, redo, redoDepth, undo, undoDepth };","map":{"version":3,"mappings":"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","names":["const","max_empty_items","Branch","items","eventCount","popEvent","state","preserveItems","let","end","length","next","get","selection","remap","mapFrom","remapping","maps","transform","tr","remaining","addAfter","addBefore","forEach","item","i","step","this","push","Item","map","slice","maybeStep","doc","mapping","appendMap","append","reverse","concat","addTransform","histOptions","newItems","oldItems","lastItem","steps","invert","docs","merged","merge","pop","overflow","depth","DEPTH_OVERFLOW","cutOffEvents","from","to","Mapping","mirrorPos","mirrorOffset","addMaps","array","rebased","rebasedTransform","rebasedCount","rebasedItems","start","Math","max","newUntil","iRebased","pos","getMirror","min","newMaps","branch","emptyItemCount","compress","count","upto","events","getMap","newItem","last","RopeSequence","empty","n","cutPoint","other","HistoryState","done","undone","prevRanges","prevTime","applyTransaction","history","options","historyTr","getMeta","historyKey","historyState","closeHistoryKey","appended","redo","mustPreserveItems","rangesFor","newGroup","time","newGroupDelay","isAdjacentTo","mapRanges","getBookmark","docChanged","adjacent","result","_from","_to","ranges","histTransaction","dispatch","spec","config","resolve","added","newHist","setSelection","setMeta","scrollIntoView","cachedPreserveItems","cachedPreserveItemsPlugins","plugins","historyPreserveItems","closeHistory","PluginKey","Plugin","key","init","apply","hist","props","handleDOMEvents","beforeinput","view","e","handled","inputType","undo","preventDefault","getState","undoDepth","redoDepth"],"sources":["/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-history/src/history.js"],"sourcesContent":["import RopeSequence from \"rope-sequence\"\nimport {Mapping} from \"prosemirror-transform\"\nimport {Plugin, PluginKey} from \"prosemirror-state\"\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n\n// Used to schedule history compression\nconst max_empty_items = 500\n\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items\n    this.eventCount = eventCount\n  }\n\n  // : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null\n\n    let end = this.items.length\n    for (;; end--) {\n      let next = this.items.get(end - 1)\n      if (next.selection) { --end; break }\n    }\n\n    let remap, mapFrom\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length)\n      mapFrom = remap.maps.length\n    }\n    let transform = state.tr\n    let selection, remaining\n    let addAfter = [], addBefore = []\n\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1)\n          mapFrom = remap.maps.length\n        }\n        mapFrom--\n        addBefore.push(item)\n        return\n      }\n\n      if (remap) {\n        addBefore.push(new Item(item.map))\n        let step = item.step.map(remap.slice(mapFrom)), map\n\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1]\n          addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length))\n        }\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n      } else {\n        transform.maybeStep(item.step)\n      }\n\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1)\n        return false\n      }\n    }, this.items.length, 0)\n\n    return {remaining, transform, selection}\n  }\n\n  // : (Transform, ?SelectionBookmark, Object) → Branch\n  // Create a new branch with the given transform added.\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [], eventCount = this.eventCount\n    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null\n\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i])\n      let item = new Item(transform.mapping.maps[i], step, selection), merged\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged\n        if (i) newItems.pop()\n        else oldItems = oldItems.slice(0, oldItems.length - 1)\n      }\n      newItems.push(item)\n      if (selection) {\n        eventCount++\n        selection = null\n      }\n      if (!preserveItems) lastItem = item\n    }\n    let overflow = eventCount - histOptions.depth\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow)\n      eventCount -= overflow\n    }\n    return new Branch(oldItems.append(newItems), eventCount)\n  }\n\n  remapping(from, to) {\n    let maps = new Mapping\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n          ? maps.maps.length - item.mirrorOffset : null\n      maps.appendMap(item.map, mirrorPos)\n    }, from, to)\n    return maps\n  }\n\n  addMaps(array) {\n    if (this.eventCount == 0) return this\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount)\n  }\n\n  // : (Transform, number)\n  // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this\n\n    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount)\n\n    let mapping = rebasedTransform.mapping\n    let newUntil = rebasedTransform.steps.length\n    let eventCount = this.eventCount\n    this.items.forEach(item => { if (item.selection) eventCount-- }, start)\n\n    let iRebased = rebasedCount\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased)\n      if (pos == null) return\n      newUntil = Math.min(newUntil, pos)\n      let map = mapping.maps[pos]\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos])\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos))\n        if (selection) eventCount++\n        rebasedItems.push(new Item(map, step, selection))\n      } else {\n        rebasedItems.push(new Item(map))\n      }\n    }, start)\n\n    let newMaps = []\n    for (let i = rebasedCount; i < newUntil; i++)\n      newMaps.push(new Item(mapping.maps[i]))\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems)\n    let branch = new Branch(items, eventCount)\n\n    if (branch.emptyItemCount() > max_empty_items)\n      branch = branch.compress(this.items.length - rebasedItems.length)\n    return branch\n  }\n\n  emptyItemCount() {\n    let count = 0\n    this.items.forEach(item => { if (!item.step) count++ })\n    return count\n  }\n\n  // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n  compress(upto = this.items.length) {\n    let remap = this.remapping(0, upto), mapFrom = remap.maps.length\n    let items = [], events = 0\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item)\n        if (item.selection) events++\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap()\n        mapFrom--\n        if (map) remap.appendMap(map, mapFrom)\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom))\n          if (selection) events++\n          let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1\n          if (merged = items.length && items[last].merge(newItem))\n            items[last] = merged\n          else\n            items.push(newItem)\n        }\n      } else if (item.map) {\n        mapFrom--\n      }\n    }, this.items.length, 0)\n    return new Branch(RopeSequence.from(items.reverse()), events)\n  }\n}\n\nBranch.empty = new Branch(RopeSequence.empty, 0)\n\nfunction cutOffEvents(items, n) {\n  let cutPoint\n  items.forEach((item, i) => {\n    if (item.selection && (n-- == 0)) {\n      cutPoint = i\n      return false\n    }\n  })\n  return items.slice(cutPoint)\n}\n\nclass Item {\n  constructor(map, step, selection, mirrorOffset) {\n    // The (forward) step map for this item.\n    this.map = map\n    // The inverted step\n    this.step = step\n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    this.selection = selection\n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    this.mirrorOffset = mirrorOffset\n  }\n\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step)\n      if (step) return new Item(step.getMap().invert(), step, this.selection)\n    }\n  }\n}\n\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nexport class HistoryState {\n  constructor(done, undone, prevRanges, prevTime) {\n    this.done = done\n    this.undone = undone\n    this.prevRanges = prevRanges\n    this.prevTime = prevTime\n  }\n}\n\nconst DEPTH_OVERFLOW = 20\n\n// : (HistoryState, EditorState, Transaction, Object)\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey), rebased\n  if (historyTr) return historyTr.historyState\n\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0)\n\n  let appended = tr.getMeta(\"appendedTransaction\")\n\n  if (tr.steps.length == 0) {\n    return history\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),\n                              history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime)\n    else\n      return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),\n                              null, history.prevTime)\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n                                                          !isAdjacentTo(tr, history.prevRanges))\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1])\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,\n                                                      options, mustPreserveItems(state)),\n                            Branch.empty, prevRanges, tr.time)\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased),\n                            history.undone.rebased(tr, rebased),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps),\n                            history.undone.addMaps(tr.mapping.maps),\n                            mapRanges(history.prevRanges, tr.mapping), history.prevTime)\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false\n  if (!transform.docChanged) return true\n  let adjacent = false\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2)\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        adjacent = true\n  })\n  return adjacent\n}\n\nfunction rangesFor(map) {\n  let result = []\n  map.forEach((_from, _to, from, to) => result.push(from, to))\n  return result\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null\n  let result = []\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1)\n    if (from <= to) result.push(from, to)\n  }\n  return result\n}\n\n// : (HistoryState, EditorState, (tr: Transaction), bool)\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  let preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems)\n  if (!pop) return\n\n  let selection = pop.selection.resolve(pop.transform.doc)\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),\n                                                                  histOptions, preserveItems)\n\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0)\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo, historyState: newHist}).scrollIntoView())\n}\n\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false\n    cachedPreserveItemsPlugins = plugins\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true\n      break\n    }\n  }\n  return cachedPreserveItems\n}\n\n// :: (Transaction) → Transaction\n// Set a flag on the given transaction that will prevent further steps\n// from being appended to an existing history event (so that they\n// require a separate undo command to undo).\nexport function closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true)\n}\n\nconst historyKey = new PluginKey(\"history\")\nconst closeHistoryKey = new PluginKey(\"closeHistory\")\n\n// :: (?Object) → Plugin\n// Returns a plugin that enables the undo history for an editor. The\n// plugin will track undo and redo stacks, which can be used with the\n// [`undo`](#history.undo) and [`redo`](#history.redo) commands.\n//\n// You can set an `\"addToHistory\"` [metadata\n// property](#state.Transaction.setMeta) of `false` on a transaction\n// to prevent it from being rolled back by undo.\n//\n//   config::-\n//   Supports the following configuration options:\n//\n//     depth:: ?number\n//     The amount of history events that are collected before the\n//     oldest events are discarded. Defaults to 100.\n//\n//     newGroupDelay:: ?number\n//     The delay between changes after which a new group should be\n//     started. Defaults to 500 (milliseconds). Note that when changes\n//     aren't adjacent, a new group is always started.\nexport function history(config) {\n  config = {depth: config && config.depth || 100,\n            newGroupDelay: config && config.newGroupDelay || 500}\n  return new Plugin({\n    key: historyKey,\n\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0)\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config)\n      }\n    },\n\n    config,\n\n    props: {\n      handleDOMEvents: {\n        beforeinput(view, e) {\n          let handled = e.inputType == \"historyUndo\" ? undo(view.state, view.dispatch) :\n              e.inputType == \"historyRedo\" ? redo(view.state, view.dispatch) : false\n          if (handled) e.preventDefault()\n          return handled\n        }\n      }\n    }\n  })\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that undoes the last change, if any.\nexport function undo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.done.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, false)\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// A command function that redoes the last undone change, if any.\nexport function redo(state, dispatch) {\n  let hist = historyKey.getState(state)\n  if (!hist || hist.undone.eventCount == 0) return false\n  if (dispatch) histTransaction(hist, state, dispatch, true)\n  return true\n}\n\n// :: (EditorState) → number\n// The amount of undoable events available in a given state.\nexport function undoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.done.eventCount : 0\n}\n\n// :: (EditorState) → number\n// The amount of redoable events available in a given editor state.\nexport function redoDepth(state) {\n  let hist = historyKey.getState(state)\n  return hist ? hist.undone.eventCount : 0\n}\n"]},"metadata":{},"sourceType":"module"}