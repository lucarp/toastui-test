{"ast":null,"code":"import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform'; // ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\n\nvar InputRule = function InputRule(match, handler) {\n  this.match = match;\n  this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n};\n\nfunction stringHandler(string) {\n  return function (state, match, start, end) {\n    var insert = string;\n\n    if (match[1]) {\n      var offset = match[0].lastIndexOf(match[1]);\n      insert += match[0].slice(offset + match[1].length);\n      start += offset;\n      var cutOff = start - end;\n\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert;\n        start = end;\n      }\n    }\n\n    return state.tr.insertText(insert, start, end);\n  };\n}\n\nvar MAX_MATCH = 500; // :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\n\nfunction inputRules(ref) {\n  var rules = ref.rules;\n  var plugin = new Plugin({\n    state: {\n      init: function init() {\n        return null;\n      },\n      apply: function apply(tr, prev) {\n        var stored = tr.getMeta(this);\n\n        if (stored) {\n          return stored;\n        }\n\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput: function handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin);\n      },\n      handleDOMEvents: {\n        compositionend: function (view) {\n          setTimeout(function () {\n            var ref = view.state.selection;\n            var $cursor = ref.$cursor;\n\n            if ($cursor) {\n              run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n            }\n          });\n        }\n      }\n    },\n    isInputRules: true\n  });\n  return plugin;\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) {\n    return false;\n  }\n\n  var state = view.state,\n      $from = state.doc.resolve(from);\n\n  if ($from.parent.type.spec.code) {\n    return false;\n  }\n\n  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n\n  for (var i = 0; i < rules.length; i++) {\n    var match = rules[i].match.exec(textBefore);\n    var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n\n    if (!tr) {\n      continue;\n    }\n\n    view.dispatch(tr.setMeta(plugin, {\n      transform: tr,\n      from: from,\n      to: to,\n      text: text\n    }));\n    return true;\n  }\n\n  return false;\n} // :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\n\n\nfunction undoInputRule(state, dispatch) {\n  var plugins = state.plugins;\n\n  for (var i = 0; i < plugins.length; i++) {\n    var plugin = plugins[i],\n        undoable = void 0;\n\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        var tr = state.tr,\n            toUndo = undoable.transform;\n\n        for (var j = toUndo.steps.length - 1; j >= 0; j--) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n\n        if (undoable.text) {\n          var marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n\n        dispatch(tr);\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // :: InputRule Converts double dashes to an emdash.\n\n\nvar emDash = new InputRule(/--$/, \"—\"); // :: InputRule Converts three dots to an ellipsis character.\n\nvar ellipsis = new InputRule(/\\.\\.\\.$/, \"…\"); // :: InputRule “Smart” opening double quotes.\n\nvar openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\"); // :: InputRule “Smart” closing double quotes.\n\nvar closeDoubleQuote = new InputRule(/\"$/, \"”\"); // :: InputRule “Smart” opening single quotes.\n\nvar openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\"); // :: InputRule “Smart” closing single quotes.\n\nvar closeSingleQuote = new InputRule(/'$/, \"’\"); // :: [InputRule] Smart-quote related input rules.\n\nvar smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]; // :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\n\nfunction wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    var tr = state.tr.delete(start, end);\n    var $start = tr.doc.resolve(start),\n        range = $start.blockRange(),\n        wrapping = range && findWrapping(range, nodeType, attrs);\n\n    if (!wrapping) {\n      return null;\n    }\n\n    tr.wrap(range, wrapping);\n    var before = tr.doc.resolve(start - 1).nodeBefore;\n\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) {\n      tr.join(start - 1);\n    }\n\n    return tr;\n  });\n} // :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\n\n\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var $start = state.doc.resolve(start);\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) {\n      return null;\n    }\n\n    return state.tr.delete(start, end).setBlockType(start, start, nodeType, attrs);\n  });\n}\n\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };","map":{"version":3,"mappings":"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","names":["InputRule","match","handler","stringHandler","string","state","start","end","let","insert","offset","lastIndexOf","slice","length","cutOff","tr","insertText","const","MAX_MATCH","inputRules","ref","plugin","Plugin","init","apply","prev","stored","getMeta","selectionSet","docChanged","props","handleTextInput","view","from","to","text","run","rules","handleDOMEvents","compositionend","setTimeout","selection","$cursor","pos","isInputRules","composing","$from","doc","resolve","parent","type","spec","code","textBefore","textBetween","Math","max","parentOffset","i","exec","dispatch","setMeta","transform","undoInputRule","plugins","undoable","getState","toUndo","j","steps","step","invert","docs","marks","replaceWith","schema","delete","emDash","ellipsis","openDoubleQuote","closeDoubleQuote","openSingleQuote","closeSingleQuote","smartQuotes","wrappingInputRule","regexp","nodeType","getAttrs","joinPredicate","attrs","Function","$start","range","blockRange","wrapping","findWrapping","wrap","before","nodeBefore","canJoin","join","textblockTypeInputRule","node","canReplaceWith","index","indexAfter","setBlockType"],"sources":["/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-inputrules/src/inputrules.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-inputrules/src/rules.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-inputrules/src/rulebuilders.js"],"sourcesContent":["import {Plugin} from \"prosemirror-state\"\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nexport class InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n  // Create an input rule. The rule applies when the user typed\n  // something and the text directly in front of the cursor matches\n  // `match`, which should end with `$`.\n  //\n  // The `handler` can be a string, in which case the matched text, or\n  // the first matched group in the regexp, is replaced by that\n  // string.\n  //\n  // Or a it can be a function, which will be called with the match\n  // array produced by\n  // [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  // as well as the start and end of the matched range, and which can\n  // return a [transaction](#state.Transaction) that describes the\n  // rule's effect, or null to indicate the input was not handled.\n  constructor(match, handler) {\n    this.match = match\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n  }\n}\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    let insert = string\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1])\n      insert += match[0].slice(offset + match[1].length)\n      start += offset\n      let cutOff = start - end\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert\n        start = end\n      }\n    }\n    return state.tr.insertText(insert, start, end)\n  }\n}\n\nconst MAX_MATCH = 500\n\n// :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\nexport function inputRules({rules}) {\n  let plugin = new Plugin({\n    state: {\n      init() { return null },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this)\n        if (stored) return stored\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin)\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            let {$cursor} = view.state.selection\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin)\n          })\n        }\n      }\n    },\n\n    isInputRules: true\n  })\n  return plugin\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false\n  let state = view.state, $from = state.doc.resolve(from)\n  if ($from.parent.type.spec.code) return false\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                            null, \"\\ufffc\") + text\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore)\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n    if (!tr) continue\n    view.dispatch(tr.setMeta(plugin, {transform: tr, from, to, text}))\n    return true\n  }\n  return false\n}\n\n// :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\nexport function undoInputRule(state, dispatch) {\n  let plugins = state.plugins\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i], undoable\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr, toUndo = undoable.transform\n        for (let j = toUndo.steps.length - 1; j >= 0; j--)\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks()\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n        dispatch(tr)\n      }\n      return true\n    }\n  }\n  return false\n}\n","import {InputRule} from \"./inputrules\"\n\n// :: InputRule Converts double dashes to an emdash.\nexport const emDash = new InputRule(/--$/, \"—\")\n// :: InputRule Converts three dots to an ellipsis character.\nexport const ellipsis = new InputRule(/\\.\\.\\.$/, \"…\")\n// :: InputRule “Smart” opening double quotes.\nexport const openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\")\n// :: InputRule “Smart” closing double quotes.\nexport const closeDoubleQuote = new InputRule(/\"$/, \"”\")\n// :: InputRule “Smart” opening single quotes.\nexport const openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\")\n// :: InputRule “Smart” closing single quotes.\nexport const closeSingleQuote = new InputRule(/'$/, \"’\")\n\n// :: [InputRule] Smart-quote related input rules.\nexport const smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]\n","import {InputRule} from \"./inputrules\"\nimport {findWrapping, canJoin} from \"prosemirror-transform\"\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\nexport function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    let tr = state.tr.delete(start, end)\n    let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return null\n    tr.wrap(range, wrapping)\n    let before = tr.doc.resolve(start - 1).nodeBefore\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n        (!joinPredicate || joinPredicate(match, before)))\n      tr.join(start - 1)\n    return tr\n  })\n}\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\nexport function textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start)\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null\n    return state.tr\n      .delete(start, end)\n      .setBlockType(start, start, nodeType, attrs)\n  })\n}\n"]},"metadata":{},"sourceType":"module"}