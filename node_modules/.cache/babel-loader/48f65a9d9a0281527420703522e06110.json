{"ast":null,"code":"import OrderedMap from 'orderedmap';\n\nfunction findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount) {\n      return a.childCount == b.childCount ? null : pos;\n    }\n\n    var childA = a.child(i),\n        childB = b.child(i);\n\n    if (childA == childB) {\n      pos += childA.nodeSize;\n      continue;\n    }\n\n    if (!childA.sameMarkup(childB)) {\n      return pos;\n    }\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++) {\n        pos++;\n      }\n\n      return pos;\n    }\n\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffStart(childA.content, childB.content, pos + 1);\n\n      if (inner != null) {\n        return inner;\n      }\n    }\n\n    pos += childA.nodeSize;\n  }\n}\n\nfunction findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0) {\n      return iA == iB ? null : {\n        a: posA,\n        b: posB\n      };\n    }\n\n    var childA = a.child(--iA),\n        childB = b.child(--iB),\n        size = childA.nodeSize;\n\n    if (childA == childB) {\n      posA -= size;\n      posB -= size;\n      continue;\n    }\n\n    if (!childA.sameMarkup(childB)) {\n      return {\n        a: posA,\n        b: posB\n      };\n    }\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0,\n          minSize = Math.min(childA.text.length, childB.text.length);\n\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++;\n        posA--;\n        posB--;\n      }\n\n      return {\n        a: posA,\n        b: posB\n      };\n    }\n\n    if (childA.content.size || childB.content.size) {\n      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n\n      if (inner) {\n        return inner;\n      }\n    }\n\n    posA -= size;\n    posB -= size;\n  }\n} // ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\n\n\nvar Fragment = function Fragment(content, size) {\n  this.content = content; // :: number\n  // The size of the fragment, which is the total of the size of its\n  // content nodes.\n\n  this.size = size || 0;\n\n  if (size == null) {\n    for (var i = 0; i < content.length; i++) {\n      this.size += content[i].nodeSize;\n    }\n  }\n};\n\nvar prototypeAccessors = {\n  firstChild: {\n    configurable: true\n  },\n  lastChild: {\n    configurable: true\n  },\n  childCount: {\n    configurable: true\n  }\n}; // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes between the given two\n// positions (relative to start of this fragment). Doesn't descend\n// into a node when the callback returns `false`.\n\nFragment.prototype.nodesBetween = function nodesBetween(from, to, f, nodeStart, parent) {\n  if (nodeStart === void 0) nodeStart = 0;\n\n  for (var i = 0, pos = 0; pos < to; i++) {\n    var child = this.content[i],\n        end = pos + child.nodeSize;\n\n    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n      var start = pos + 1;\n      child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n    }\n\n    pos = end;\n  }\n}; // :: ((node: Node, pos: number, parent: Node) → ?bool)\n// Call the given callback for every descendant node. The callback\n// may return `false` to prevent traversal of a given node's children.\n\n\nFragment.prototype.descendants = function descendants(f) {\n  this.nodesBetween(0, this.size, f);\n}; // :: (number, number, ?string, ?union<string, (leafNode: Node) → string>) → string\n// Extract the text between `from` and `to`. See the same method on\n// [`Node`](#model.Node.textBetween).\n\n\nFragment.prototype.textBetween = function textBetween(from, to, blockSeparator, leafText) {\n  var text = \"\",\n      separated = true;\n  this.nodesBetween(from, to, function (node, pos) {\n    if (node.isText) {\n      text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n      separated = !blockSeparator;\n    } else if (node.isLeaf && leafText) {\n      text += typeof leafText === 'function' ? leafText(node) : leafText;\n      separated = !blockSeparator;\n    } else if (!separated && node.isBlock) {\n      text += blockSeparator;\n      separated = true;\n    }\n  }, 0);\n  return text;\n}; // :: (Fragment) → Fragment\n// Create a new fragment containing the combined content of this\n// fragment and the other.\n\n\nFragment.prototype.append = function append(other) {\n  if (!other.size) {\n    return this;\n  }\n\n  if (!this.size) {\n    return other;\n  }\n\n  var last = this.lastChild,\n      first = other.firstChild,\n      content = this.content.slice(),\n      i = 0;\n\n  if (last.isText && last.sameMarkup(first)) {\n    content[content.length - 1] = last.withText(last.text + first.text);\n    i = 1;\n  }\n\n  for (; i < other.content.length; i++) {\n    content.push(other.content[i]);\n  }\n\n  return new Fragment(content, this.size + other.size);\n}; // :: (number, ?number) → Fragment\n// Cut out the sub-fragment between the two given positions.\n\n\nFragment.prototype.cut = function cut(from, to) {\n  if (to == null) {\n    to = this.size;\n  }\n\n  if (from == 0 && to == this.size) {\n    return this;\n  }\n\n  var result = [],\n      size = 0;\n\n  if (to > from) {\n    for (var i = 0, pos = 0; pos < to; i++) {\n      var child = this.content[i],\n          end = pos + child.nodeSize;\n\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText) {\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n          } else {\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n          }\n        }\n\n        result.push(child);\n        size += child.nodeSize;\n      }\n\n      pos = end;\n    }\n  }\n\n  return new Fragment(result, size);\n};\n\nFragment.prototype.cutByIndex = function cutByIndex(from, to) {\n  if (from == to) {\n    return Fragment.empty;\n  }\n\n  if (from == 0 && to == this.content.length) {\n    return this;\n  }\n\n  return new Fragment(this.content.slice(from, to));\n}; // :: (number, Node) → Fragment\n// Create a new fragment in which the node at the given index is\n// replaced by the given node.\n\n\nFragment.prototype.replaceChild = function replaceChild(index, node) {\n  var current = this.content[index];\n\n  if (current == node) {\n    return this;\n  }\n\n  var copy = this.content.slice();\n  var size = this.size + node.nodeSize - current.nodeSize;\n  copy[index] = node;\n  return new Fragment(copy, size);\n}; // : (Node) → Fragment\n// Create a new fragment by prepending the given node to this\n// fragment.\n\n\nFragment.prototype.addToStart = function addToStart(node) {\n  return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n}; // : (Node) → Fragment\n// Create a new fragment by appending the given node to this\n// fragment.\n\n\nFragment.prototype.addToEnd = function addToEnd(node) {\n  return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n}; // :: (Fragment) → bool\n// Compare this fragment to another one.\n\n\nFragment.prototype.eq = function eq(other) {\n  if (this.content.length != other.content.length) {\n    return false;\n  }\n\n  for (var i = 0; i < this.content.length; i++) {\n    if (!this.content[i].eq(other.content[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}; // :: ?Node\n// The first child of the fragment, or `null` if it is empty.\n\n\nprototypeAccessors.firstChild.get = function () {\n  return this.content.length ? this.content[0] : null;\n}; // :: ?Node\n// The last child of the fragment, or `null` if it is empty.\n\n\nprototypeAccessors.lastChild.get = function () {\n  return this.content.length ? this.content[this.content.length - 1] : null;\n}; // :: number\n// The number of child nodes in this fragment.\n\n\nprototypeAccessors.childCount.get = function () {\n  return this.content.length;\n}; // :: (number) → Node\n// Get the child node at the given index. Raise an error when the\n// index is out of range.\n\n\nFragment.prototype.child = function child(index) {\n  var found = this.content[index];\n\n  if (!found) {\n    throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n  }\n\n  return found;\n}; // :: (number) → ?Node\n// Get the child node at the given index, if it exists.\n\n\nFragment.prototype.maybeChild = function maybeChild(index) {\n  return this.content[index];\n}; // :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\n\n\nFragment.prototype.forEach = function forEach(f) {\n  for (var i = 0, p = 0; i < this.content.length; i++) {\n    var child = this.content[i];\n    f(child, p, i);\n    p += child.nodeSize;\n  }\n}; // :: (Fragment) → ?number\n// Find the first position at which this fragment and another\n// fragment differ, or `null` if they are the same.\n\n\nFragment.prototype.findDiffStart = function findDiffStart$1(other, pos) {\n  if (pos === void 0) pos = 0;\n  return findDiffStart(this, other, pos);\n}; // :: (Fragment) → ?{a: number, b: number}\n// Find the first position, searching from the end, at which this\n// fragment and the given fragment differ, or `null` if they are the\n// same. Since this position will not be the same in both nodes, an\n// object with two separate positions is returned.\n\n\nFragment.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {\n  if (pos === void 0) pos = this.size;\n  if (otherPos === void 0) otherPos = other.size;\n  return findDiffEnd(this, other, pos, otherPos);\n}; // : (number, ?number) → {index: number, offset: number}\n// Find the index and inner offset corresponding to a given relative\n// position in this fragment. The result object will be reused\n// (overwritten) the next time the function is called. (Not public.)\n\n\nFragment.prototype.findIndex = function findIndex(pos, round) {\n  if (round === void 0) round = -1;\n\n  if (pos == 0) {\n    return retIndex(0, pos);\n  }\n\n  if (pos == this.size) {\n    return retIndex(this.content.length, pos);\n  }\n\n  if (pos > this.size || pos < 0) {\n    throw new RangeError(\"Position \" + pos + \" outside of fragment (\" + this + \")\");\n  }\n\n  for (var i = 0, curPos = 0;; i++) {\n    var cur = this.child(i),\n        end = curPos + cur.nodeSize;\n\n    if (end >= pos) {\n      if (end == pos || round > 0) {\n        return retIndex(i + 1, end);\n      }\n\n      return retIndex(i, curPos);\n    }\n\n    curPos = end;\n  }\n}; // :: () → string\n// Return a debugging string that describes this fragment.\n\n\nFragment.prototype.toString = function toString() {\n  return \"<\" + this.toStringInner() + \">\";\n};\n\nFragment.prototype.toStringInner = function toStringInner() {\n  return this.content.join(\", \");\n}; // :: () → ?Object\n// Create a JSON-serializeable representation of this fragment.\n\n\nFragment.prototype.toJSON = function toJSON() {\n  return this.content.length ? this.content.map(function (n) {\n    return n.toJSON();\n  }) : null;\n}; // :: (Schema, ?Object) → Fragment\n// Deserialize a fragment from its JSON representation.\n\n\nFragment.fromJSON = function fromJSON(schema, value) {\n  if (!value) {\n    return Fragment.empty;\n  }\n\n  if (!Array.isArray(value)) {\n    throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n  }\n\n  return new Fragment(value.map(schema.nodeFromJSON));\n}; // :: ([Node]) → Fragment\n// Build a fragment from an array of nodes. Ensures that adjacent\n// text nodes with the same marks are joined together.\n\n\nFragment.fromArray = function fromArray(array) {\n  if (!array.length) {\n    return Fragment.empty;\n  }\n\n  var joined,\n      size = 0;\n\n  for (var i = 0; i < array.length; i++) {\n    var node = array[i];\n    size += node.nodeSize;\n\n    if (i && node.isText && array[i - 1].sameMarkup(node)) {\n      if (!joined) {\n        joined = array.slice(0, i);\n      }\n\n      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n    } else if (joined) {\n      joined.push(node);\n    }\n  }\n\n  return new Fragment(joined || array, size);\n}; // :: (?union<Fragment, Node, [Node]>) → Fragment\n// Create a fragment from something that can be interpreted as a set\n// of nodes. For `null`, it returns the empty fragment. For a\n// fragment, the fragment itself. For a node or array of nodes, a\n// fragment containing those nodes.\n\n\nFragment.from = function from(nodes) {\n  if (!nodes) {\n    return Fragment.empty;\n  }\n\n  if (nodes instanceof Fragment) {\n    return nodes;\n  }\n\n  if (Array.isArray(nodes)) {\n    return this.fromArray(nodes);\n  }\n\n  if (nodes.attrs) {\n    return new Fragment([nodes], nodes.nodeSize);\n  }\n\n  throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n};\n\nObject.defineProperties(Fragment.prototype, prototypeAccessors);\nvar found = {\n  index: 0,\n  offset: 0\n};\n\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found;\n} // :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\n\n\nFragment.empty = new Fragment([], 0);\n\nfunction compareDeep(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!(a && typeof a == \"object\") || !(b && typeof b == \"object\")) {\n    return false;\n  }\n\n  var array = Array.isArray(a);\n\n  if (Array.isArray(b) != array) {\n    return false;\n  }\n\n  if (array) {\n    if (a.length != b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length; i++) {\n      if (!compareDeep(a[i], b[i])) {\n        return false;\n      }\n    }\n  } else {\n    for (var p in a) {\n      if (!(p in b) || !compareDeep(a[p], b[p])) {\n        return false;\n      }\n    }\n\n    for (var p$1 in b) {\n      if (!(p$1 in a)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n} // ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\n\n\nvar Mark = function Mark(type, attrs) {\n  // :: MarkType\n  // The type of this mark.\n  this.type = type; // :: Object\n  // The attributes associated with this mark.\n\n  this.attrs = attrs;\n}; // :: ([Mark]) → [Mark]\n// Given a set of marks, create a new set which contains this one as\n// well, in the right position. If this mark is already in the set,\n// the set itself is returned. If any marks that are set to be\n// [exclusive](#model.MarkSpec.excludes) with this mark are present,\n// those are replaced by this one.\n\n\nMark.prototype.addToSet = function addToSet(set) {\n  var copy,\n      placed = false;\n\n  for (var i = 0; i < set.length; i++) {\n    var other = set[i];\n\n    if (this.eq(other)) {\n      return set;\n    }\n\n    if (this.type.excludes(other.type)) {\n      if (!copy) {\n        copy = set.slice(0, i);\n      }\n    } else if (other.type.excludes(this.type)) {\n      return set;\n    } else {\n      if (!placed && other.type.rank > this.type.rank) {\n        if (!copy) {\n          copy = set.slice(0, i);\n        }\n\n        copy.push(this);\n        placed = true;\n      }\n\n      if (copy) {\n        copy.push(other);\n      }\n    }\n  }\n\n  if (!copy) {\n    copy = set.slice();\n  }\n\n  if (!placed) {\n    copy.push(this);\n  }\n\n  return copy;\n}; // :: ([Mark]) → [Mark]\n// Remove this mark from the given set, returning a new set. If this\n// mark is not in the set, the set itself is returned.\n\n\nMark.prototype.removeFromSet = function removeFromSet(set) {\n  for (var i = 0; i < set.length; i++) {\n    if (this.eq(set[i])) {\n      return set.slice(0, i).concat(set.slice(i + 1));\n    }\n  }\n\n  return set;\n}; // :: ([Mark]) → bool\n// Test whether this mark is in the given set of marks.\n\n\nMark.prototype.isInSet = function isInSet(set) {\n  for (var i = 0; i < set.length; i++) {\n    if (this.eq(set[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}; // :: (Mark) → bool\n// Test whether this mark has the same type and attributes as\n// another mark.\n\n\nMark.prototype.eq = function eq(other) {\n  return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n}; // :: () → Object\n// Convert this mark to a JSON-serializeable representation.\n\n\nMark.prototype.toJSON = function toJSON() {\n  var obj = {\n    type: this.type.name\n  };\n\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break;\n  }\n\n  return obj;\n}; // :: (Schema, Object) → Mark\n\n\nMark.fromJSON = function fromJSON(schema, json) {\n  if (!json) {\n    throw new RangeError(\"Invalid input for Mark.fromJSON\");\n  }\n\n  var type = schema.marks[json.type];\n\n  if (!type) {\n    throw new RangeError(\"There is no mark type \" + json.type + \" in this schema\");\n  }\n\n  return type.create(json.attrs);\n}; // :: ([Mark], [Mark]) → bool\n// Test whether two sets of marks are identical.\n\n\nMark.sameSet = function sameSet(a, b) {\n  if (a == b) {\n    return true;\n  }\n\n  if (a.length != b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    if (!a[i].eq(b[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}; // :: (?union<Mark, [Mark]>) → [Mark]\n// Create a properly sorted mark set from null, a single mark, or an\n// unsorted array of marks.\n\n\nMark.setFrom = function setFrom(marks) {\n  if (!marks || marks.length == 0) {\n    return Mark.none;\n  }\n\n  if (marks instanceof Mark) {\n    return [marks];\n  }\n\n  var copy = marks.slice();\n  copy.sort(function (a, b) {\n    return a.type.rank - b.type.rank;\n  });\n  return copy;\n}; // :: [Mark] The empty set of marks.\n\n\nMark.none = []; // ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nfunction ReplaceError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = ReplaceError.prototype;\n  return err;\n}\n\nReplaceError.prototype = Object.create(Error.prototype);\nReplaceError.prototype.constructor = ReplaceError;\nReplaceError.prototype.name = \"ReplaceError\"; // ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\n\nvar Slice = function Slice(content, openStart, openEnd) {\n  // :: Fragment The slice's content.\n  this.content = content; // :: number The open depth at the start.\n\n  this.openStart = openStart; // :: number The open depth at the end.\n\n  this.openEnd = openEnd;\n};\n\nvar prototypeAccessors$1 = {\n  size: {\n    configurable: true\n  }\n}; // :: number\n// The size this slice would add when inserted into a document.\n\nprototypeAccessors$1.size.get = function () {\n  return this.content.size - this.openStart - this.openEnd;\n};\n\nSlice.prototype.insertAt = function insertAt(pos, fragment) {\n  var content = insertInto(this.content, pos + this.openStart, fragment, null);\n  return content && new Slice(content, this.openStart, this.openEnd);\n};\n\nSlice.prototype.removeBetween = function removeBetween(from, to) {\n  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n}; // :: (Slice) → bool\n// Tests whether this slice is equal to another slice.\n\n\nSlice.prototype.eq = function eq(other) {\n  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n};\n\nSlice.prototype.toString = function toString() {\n  return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n}; // :: () → ?Object\n// Convert a slice to a JSON-serializable representation.\n\n\nSlice.prototype.toJSON = function toJSON() {\n  if (!this.content.size) {\n    return null;\n  }\n\n  var json = {\n    content: this.content.toJSON()\n  };\n\n  if (this.openStart > 0) {\n    json.openStart = this.openStart;\n  }\n\n  if (this.openEnd > 0) {\n    json.openEnd = this.openEnd;\n  }\n\n  return json;\n}; // :: (Schema, ?Object) → Slice\n// Deserialize a slice from its JSON representation.\n\n\nSlice.fromJSON = function fromJSON(schema, json) {\n  if (!json) {\n    return Slice.empty;\n  }\n\n  var openStart = json.openStart || 0,\n      openEnd = json.openEnd || 0;\n\n  if (typeof openStart != \"number\" || typeof openEnd != \"number\") {\n    throw new RangeError(\"Invalid input for Slice.fromJSON\");\n  }\n\n  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n}; // :: (Fragment, ?bool) → Slice\n// Create a slice from a fragment by taking the maximum possible\n// open value on both side of the fragment.\n\n\nSlice.maxOpen = function maxOpen(fragment, openIsolating) {\n  if (openIsolating === void 0) openIsolating = true;\n  var openStart = 0,\n      openEnd = 0;\n\n  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {\n    openStart++;\n  }\n\n  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {\n    openEnd++;\n  }\n\n  return new Slice(fragment, openStart, openEnd);\n};\n\nObject.defineProperties(Slice.prototype, prototypeAccessors$1);\n\nfunction removeRange(content, from, to) {\n  var ref = content.findIndex(from);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n  var ref$1 = content.findIndex(to);\n  var indexTo = ref$1.index;\n  var offsetTo = ref$1.offset;\n\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) {\n      throw new RangeError(\"Removing non-flat range\");\n    }\n\n    return content.cut(0, from).append(content.cut(to));\n  }\n\n  if (index != indexTo) {\n    throw new RangeError(\"Removing non-flat range\");\n  }\n\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var ref = content.findIndex(dist);\n  var index = ref.index;\n  var offset = ref.offset;\n  var child = content.maybeChild(index);\n\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) {\n      return null;\n    }\n\n    return content.cut(0, dist).append(insert).append(content.cut(dist));\n  }\n\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner));\n} // :: Slice\n// The empty slice.\n\n\nSlice.empty = new Slice(Fragment.empty, 0, 0);\n\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth) {\n    throw new ReplaceError(\"Inserted content deeper than insertion position\");\n  }\n\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd) {\n    throw new ReplaceError(\"Inconsistent open depths\");\n  }\n\n  return replaceOuter($from, $to, slice, 0);\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth),\n      node = $from.node(depth);\n\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner));\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth));\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n    // Simple, flat case\n    var parent = $from.parent,\n        content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n  } else {\n    var ref = prepareSliceForReplace(slice, $from);\n    var start = ref.start;\n    var end = ref.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth));\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type)) {\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n  }\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node;\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n\n  if (last >= 0 && child.isText && child.sameMarkup(target[last])) {\n    target[last] = child.withText(target[last].text + child.text);\n  } else {\n    target.push(child);\n  }\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0,\n      endIndex = $end ? $end.index(depth) : node.childCount;\n\n  if ($start) {\n    startIndex = $start.index(depth);\n\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n\n  for (var i = startIndex; i < endIndex; i++) {\n    addNode(node.child(i), target);\n  }\n\n  if ($end && $end.depth == depth && $end.textOffset) {\n    addNode($end.nodeBefore, target);\n  }\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content)) {\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name);\n  }\n\n  return node.copy(content);\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n  var content = [];\n  addRange(null, $from, depth, content);\n\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart) {\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n    }\n\n    addRange($start, $end, depth, content);\n\n    if (openEnd) {\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n    }\n  }\n\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart,\n      parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n\n  for (var i = extra - 1; i >= 0; i--) {\n    node = $along.node(i).copy(Fragment.from(node));\n  }\n\n  return {\n    start: node.resolveNoCache(slice.openStart + extra),\n    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n  };\n} // ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\n\n\nvar ResolvedPos = function ResolvedPos(pos, path, parentOffset) {\n  // :: number The position that was resolved.\n  this.pos = pos;\n  this.path = path; // :: number\n  // The number of levels the parent node is from the root. If this\n  // position points directly into the root node, it is 0. If it\n  // points into a top-level paragraph, 1, and so on.\n\n  this.depth = path.length / 3 - 1; // :: number The offset this position has into its parent node.\n\n  this.parentOffset = parentOffset;\n};\n\nvar prototypeAccessors$2 = {\n  parent: {\n    configurable: true\n  },\n  doc: {\n    configurable: true\n  },\n  textOffset: {\n    configurable: true\n  },\n  nodeAfter: {\n    configurable: true\n  },\n  nodeBefore: {\n    configurable: true\n  }\n};\n\nResolvedPos.prototype.resolveDepth = function resolveDepth(val) {\n  if (val == null) {\n    return this.depth;\n  }\n\n  if (val < 0) {\n    return this.depth + val;\n  }\n\n  return val;\n}; // :: Node\n// The parent node that the position points into. Note that even if\n// a position points into a text node, that node is not considered\n// the parent—text nodes are ‘flat’ in this model, and have no content.\n\n\nprototypeAccessors$2.parent.get = function () {\n  return this.node(this.depth);\n}; // :: Node\n// The root node in which the position was resolved.\n\n\nprototypeAccessors$2.doc.get = function () {\n  return this.node(0);\n}; // :: (?number) → Node\n// The ancestor node at the given level. `p.node(p.depth)` is the\n// same as `p.parent`.\n\n\nResolvedPos.prototype.node = function node(depth) {\n  return this.path[this.resolveDepth(depth) * 3];\n}; // :: (?number) → number\n// The index into the ancestor at the given level. If this points at\n// the 3rd node in the 2nd paragraph on the top level, for example,\n// `p.index(0)` is 1 and `p.index(1)` is 2.\n\n\nResolvedPos.prototype.index = function index(depth) {\n  return this.path[this.resolveDepth(depth) * 3 + 1];\n}; // :: (?number) → number\n// The index pointing after this position into the ancestor at the\n// given level.\n\n\nResolvedPos.prototype.indexAfter = function indexAfter(depth) {\n  depth = this.resolveDepth(depth);\n  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n}; // :: (?number) → number\n// The (absolute) position at the start of the node at the given\n// level.\n\n\nResolvedPos.prototype.start = function start(depth) {\n  depth = this.resolveDepth(depth);\n  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n}; // :: (?number) → number\n// The (absolute) position at the end of the node at the given\n// level.\n\n\nResolvedPos.prototype.end = function end(depth) {\n  depth = this.resolveDepth(depth);\n  return this.start(depth) + this.node(depth).content.size;\n}; // :: (?number) → number\n// The (absolute) position directly before the wrapping node at the\n// given level, or, when `depth` is `this.depth + 1`, the original\n// position.\n\n\nResolvedPos.prototype.before = function before(depth) {\n  depth = this.resolveDepth(depth);\n\n  if (!depth) {\n    throw new RangeError(\"There is no position before the top-level node\");\n  }\n\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n}; // :: (?number) → number\n// The (absolute) position directly after the wrapping node at the\n// given level, or the original position when `depth` is `this.depth + 1`.\n\n\nResolvedPos.prototype.after = function after(depth) {\n  depth = this.resolveDepth(depth);\n\n  if (!depth) {\n    throw new RangeError(\"There is no position after the top-level node\");\n  }\n\n  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n}; // :: number\n// When this position points into a text node, this returns the\n// distance between the position and the start of the text node.\n// Will be zero for positions that point between nodes.\n\n\nprototypeAccessors$2.textOffset.get = function () {\n  return this.pos - this.path[this.path.length - 1];\n}; // :: ?Node\n// Get the node directly after the position, if any. If the position\n// points into a text node, only the part of that node after the\n// position is returned.\n\n\nprototypeAccessors$2.nodeAfter.get = function () {\n  var parent = this.parent,\n      index = this.index(this.depth);\n\n  if (index == parent.childCount) {\n    return null;\n  }\n\n  var dOff = this.pos - this.path[this.path.length - 1],\n      child = parent.child(index);\n  return dOff ? parent.child(index).cut(dOff) : child;\n}; // :: ?Node\n// Get the node directly before the position, if any. If the\n// position points into a text node, only the part of that node\n// before the position is returned.\n\n\nprototypeAccessors$2.nodeBefore.get = function () {\n  var index = this.index(this.depth);\n  var dOff = this.pos - this.path[this.path.length - 1];\n\n  if (dOff) {\n    return this.parent.child(index).cut(0, dOff);\n  }\n\n  return index == 0 ? null : this.parent.child(index - 1);\n}; // :: (number, ?number) → number\n// Get the position at the given index in the parent node at the\n// given depth (which defaults to `this.depth`).\n\n\nResolvedPos.prototype.posAtIndex = function posAtIndex(index, depth) {\n  depth = this.resolveDepth(depth);\n  var node = this.path[depth * 3],\n      pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n\n  for (var i = 0; i < index; i++) {\n    pos += node.child(i).nodeSize;\n  }\n\n  return pos;\n}; // :: () → [Mark]\n// Get the marks at this position, factoring in the surrounding\n// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n// position is at the start of a non-empty node, the marks of the\n// node after it (if any) are returned.\n\n\nResolvedPos.prototype.marks = function marks() {\n  var parent = this.parent,\n      index = this.index(); // In an empty parent, return the empty array\n\n  if (parent.content.size == 0) {\n    return Mark.none;\n  } // When inside a text node, just return the text node's marks\n\n\n  if (this.textOffset) {\n    return parent.child(index).marks;\n  }\n\n  var main = parent.maybeChild(index - 1),\n      other = parent.maybeChild(index); // If the `after` flag is true of there is no node before, make\n  // the node after this position the main reference.\n\n  if (!main) {\n    var tmp = main;\n    main = other;\n    other = tmp;\n  } // Use all marks in the main node, except those that have\n  // `inclusive` set to false and are not present in the other node.\n\n\n  var marks = main.marks;\n\n  for (var i = 0; i < marks.length; i++) {\n    if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) {\n      marks = marks[i--].removeFromSet(marks);\n    }\n  }\n\n  return marks;\n}; // :: (ResolvedPos) → ?[Mark]\n// Get the marks after the current position, if any, except those\n// that are non-inclusive and not present at position `$end`. This\n// is mostly useful for getting the set of marks to preserve after a\n// deletion. Will return `null` if this position is at the end of\n// its parent node or its parent node isn't a textblock (in which\n// case no marks should be preserved).\n\n\nResolvedPos.prototype.marksAcross = function marksAcross($end) {\n  var after = this.parent.maybeChild(this.index());\n\n  if (!after || !after.isInline) {\n    return null;\n  }\n\n  var marks = after.marks,\n      next = $end.parent.maybeChild($end.index());\n\n  for (var i = 0; i < marks.length; i++) {\n    if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) {\n      marks = marks[i--].removeFromSet(marks);\n    }\n  }\n\n  return marks;\n}; // :: (number) → number\n// The depth up to which this position and the given (non-resolved)\n// position share the same parent nodes.\n\n\nResolvedPos.prototype.sharedDepth = function sharedDepth(pos) {\n  for (var depth = this.depth; depth > 0; depth--) {\n    if (this.start(depth) <= pos && this.end(depth) >= pos) {\n      return depth;\n    }\n  }\n\n  return 0;\n}; // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n// Returns a range based on the place where this position and the\n// given position diverge around block content. If both point into\n// the same textblock, for example, a range around that textblock\n// will be returned. If they point into different blocks, the range\n// around those blocks in their shared ancestor is returned. You can\n// pass in an optional predicate that will be called with a parent\n// node to see if a range into that parent is acceptable.\n\n\nResolvedPos.prototype.blockRange = function blockRange(other, pred) {\n  if (other === void 0) other = this;\n\n  if (other.pos < this.pos) {\n    return other.blockRange(this);\n  }\n\n  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {\n    if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {\n      return new NodeRange(this, other, d);\n    }\n  }\n}; // :: (ResolvedPos) → bool\n// Query whether the given position shares the same parent node.\n\n\nResolvedPos.prototype.sameParent = function sameParent(other) {\n  return this.pos - this.parentOffset == other.pos - other.parentOffset;\n}; // :: (ResolvedPos) → ResolvedPos\n// Return the greater of this and the given position.\n\n\nResolvedPos.prototype.max = function max(other) {\n  return other.pos > this.pos ? other : this;\n}; // :: (ResolvedPos) → ResolvedPos\n// Return the smaller of this and the given position.\n\n\nResolvedPos.prototype.min = function min(other) {\n  return other.pos < this.pos ? other : this;\n};\n\nResolvedPos.prototype.toString = function toString() {\n  var str = \"\";\n\n  for (var i = 1; i <= this.depth; i++) {\n    str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n  }\n\n  return str + \":\" + this.parentOffset;\n};\n\nResolvedPos.resolve = function resolve(doc, pos) {\n  if (!(pos >= 0 && pos <= doc.content.size)) {\n    throw new RangeError(\"Position \" + pos + \" out of range\");\n  }\n\n  var path = [];\n  var start = 0,\n      parentOffset = pos;\n\n  for (var node = doc;;) {\n    var ref = node.content.findIndex(parentOffset);\n    var index = ref.index;\n    var offset = ref.offset;\n    var rem = parentOffset - offset;\n    path.push(node, index, start + offset);\n\n    if (!rem) {\n      break;\n    }\n\n    node = node.child(index);\n\n    if (node.isText) {\n      break;\n    }\n\n    parentOffset = rem - 1;\n    start += offset + 1;\n  }\n\n  return new ResolvedPos(pos, path, parentOffset);\n};\n\nResolvedPos.resolveCached = function resolveCached(doc, pos) {\n  for (var i = 0; i < resolveCache.length; i++) {\n    var cached = resolveCache[i];\n\n    if (cached.pos == pos && cached.doc == doc) {\n      return cached;\n    }\n  }\n\n  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n  return result;\n};\n\nObject.defineProperties(ResolvedPos.prototype, prototypeAccessors$2);\nvar resolveCache = [],\n    resolveCachePos = 0,\n    resolveCacheSize = 12; // ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\n\nvar NodeRange = function NodeRange($from, $to, depth) {\n  // :: ResolvedPos A resolved position along the start of the\n  // content. May have a `depth` greater than this object's `depth`\n  // property, since these are the positions that were used to\n  // compute the range, not re-resolved positions directly at its\n  // boundaries.\n  this.$from = $from; // :: ResolvedPos A position along the end of the content. See\n  // caveat for [`$from`](#model.NodeRange.$from).\n\n  this.$to = $to; // :: number The depth of the node that this range points into.\n\n  this.depth = depth;\n};\n\nvar prototypeAccessors$1$1 = {\n  start: {\n    configurable: true\n  },\n  end: {\n    configurable: true\n  },\n  parent: {\n    configurable: true\n  },\n  startIndex: {\n    configurable: true\n  },\n  endIndex: {\n    configurable: true\n  }\n}; // :: number The position at the start of the range.\n\nprototypeAccessors$1$1.start.get = function () {\n  return this.$from.before(this.depth + 1);\n}; // :: number The position at the end of the range.\n\n\nprototypeAccessors$1$1.end.get = function () {\n  return this.$to.after(this.depth + 1);\n}; // :: Node The parent node that the range points into.\n\n\nprototypeAccessors$1$1.parent.get = function () {\n  return this.$from.node(this.depth);\n}; // :: number The start index of the range in the parent node.\n\n\nprototypeAccessors$1$1.startIndex.get = function () {\n  return this.$from.index(this.depth);\n}; // :: number The end index of the range in the parent node.\n\n\nprototypeAccessors$1$1.endIndex.get = function () {\n  return this.$to.indexAfter(this.depth);\n};\n\nObject.defineProperties(NodeRange.prototype, prototypeAccessors$1$1);\nvar emptyAttrs = Object.create(null); // ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\n\nvar Node = function Node(type, attrs, content, marks) {\n  // :: NodeType\n  // The type of node that this is.\n  this.type = type; // :: Object\n  // An object mapping attribute names to values. The kind of\n  // attributes allowed and required are\n  // [determined](#model.NodeSpec.attrs) by the node type.\n\n  this.attrs = attrs; // :: Fragment\n  // A container holding the node's children.\n\n  this.content = content || Fragment.empty; // :: [Mark]\n  // The marks (things like whether it is emphasized or part of a\n  // link) applied to this node.\n\n  this.marks = marks || Mark.none;\n};\n\nvar prototypeAccessors$3 = {\n  nodeSize: {\n    configurable: true\n  },\n  childCount: {\n    configurable: true\n  },\n  textContent: {\n    configurable: true\n  },\n  firstChild: {\n    configurable: true\n  },\n  lastChild: {\n    configurable: true\n  },\n  isBlock: {\n    configurable: true\n  },\n  isTextblock: {\n    configurable: true\n  },\n  inlineContent: {\n    configurable: true\n  },\n  isInline: {\n    configurable: true\n  },\n  isText: {\n    configurable: true\n  },\n  isLeaf: {\n    configurable: true\n  },\n  isAtom: {\n    configurable: true\n  }\n}; // text:: ?string\n// For text nodes, this contains the node's text content.\n// :: number\n// The size of this node, as defined by the integer-based [indexing\n// scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n// amount of characters. For other leaf nodes, it is one. For\n// non-leaf nodes, it is the size of the content plus two (the start\n// and end token).\n\nprototypeAccessors$3.nodeSize.get = function () {\n  return this.isLeaf ? 1 : 2 + this.content.size;\n}; // :: number\n// The number of children that the node has.\n\n\nprototypeAccessors$3.childCount.get = function () {\n  return this.content.childCount;\n}; // :: (number) → Node\n// Get the child node at the given index. Raises an error when the\n// index is out of range.\n\n\nNode.prototype.child = function child(index) {\n  return this.content.child(index);\n}; // :: (number) → ?Node\n// Get the child node at the given index, if it exists.\n\n\nNode.prototype.maybeChild = function maybeChild(index) {\n  return this.content.maybeChild(index);\n}; // :: ((node: Node, offset: number, index: number))\n// Call `f` for every child node, passing the node, its offset\n// into this parent node, and its index.\n\n\nNode.prototype.forEach = function forEach(f) {\n  this.content.forEach(f);\n}; // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n// Invoke a callback for all descendant nodes recursively between\n// the given two positions that are relative to start of this node's\n// content. The callback is invoked with the node, its\n// parent-relative position, its parent node, and its child index.\n// When the callback returns false for a given node, that node's\n// children will not be recursed over. The last parameter can be\n// used to specify a starting position to count from.\n\n\nNode.prototype.nodesBetween = function nodesBetween(from, to, f, startPos) {\n  if (startPos === void 0) startPos = 0;\n  this.content.nodesBetween(from, to, f, startPos, this);\n}; // :: ((node: Node, pos: number, parent: Node, index: number) → ?bool)\n// Call the given callback for every descendant node. Doesn't\n// descend into a node when the callback returns `false`.\n\n\nNode.prototype.descendants = function descendants(f) {\n  this.nodesBetween(0, this.content.size, f);\n}; // :: string\n// Concatenates all the text nodes found in this fragment and its\n// children.\n\n\nprototypeAccessors$3.textContent.get = function () {\n  return this.textBetween(0, this.content.size, \"\");\n}; // :: (number, number, ?string, ?union<string, ?(leafNode: Node) -> string>) → string\n// Get all text between positions `from` and `to`. When\n// `blockSeparator` is given, it will be inserted to separate text\n// from different block nodes. When `leafText` is given, it'll be\n// inserted for every non-text leaf node encountered.\n\n\nNode.prototype.textBetween = function textBetween(from, to, blockSeparator, leafText) {\n  return this.content.textBetween(from, to, blockSeparator, leafText);\n}; // :: ?Node\n// Returns this node's first child, or `null` if there are no\n// children.\n\n\nprototypeAccessors$3.firstChild.get = function () {\n  return this.content.firstChild;\n}; // :: ?Node\n// Returns this node's last child, or `null` if there are no\n// children.\n\n\nprototypeAccessors$3.lastChild.get = function () {\n  return this.content.lastChild;\n}; // :: (Node) → bool\n// Test whether two nodes represent the same piece of document.\n\n\nNode.prototype.eq = function eq(other) {\n  return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n}; // :: (Node) → bool\n// Compare the markup (type, attributes, and marks) of this node to\n// those of another. Returns `true` if both have the same markup.\n\n\nNode.prototype.sameMarkup = function sameMarkup(other) {\n  return this.hasMarkup(other.type, other.attrs, other.marks);\n}; // :: (NodeType, ?Object, ?[Mark]) → bool\n// Check whether this node's markup correspond to the given type,\n// attributes, and marks.\n\n\nNode.prototype.hasMarkup = function hasMarkup(type, attrs, marks) {\n  return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n}; // :: (?Fragment) → Node\n// Create a new node with the same markup as this node, containing\n// the given content (or empty, if no content is given).\n\n\nNode.prototype.copy = function copy(content) {\n  if (content === void 0) content = null;\n\n  if (content == this.content) {\n    return this;\n  }\n\n  return new this.constructor(this.type, this.attrs, content, this.marks);\n}; // :: ([Mark]) → Node\n// Create a copy of this node, with the given set of marks instead\n// of the node's own marks.\n\n\nNode.prototype.mark = function mark(marks) {\n  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks);\n}; // :: (number, ?number) → Node\n// Create a copy of this node with only the content between the\n// given positions. If `to` is not given, it defaults to the end of\n// the node.\n\n\nNode.prototype.cut = function cut(from, to) {\n  if (from == 0 && to == this.content.size) {\n    return this;\n  }\n\n  return this.copy(this.content.cut(from, to));\n}; // :: (number, ?number) → Slice\n// Cut out the part of the document between the given positions, and\n// return it as a `Slice` object.\n\n\nNode.prototype.slice = function slice(from, to, includeParents) {\n  if (to === void 0) to = this.content.size;\n  if (includeParents === void 0) includeParents = false;\n\n  if (from == to) {\n    return Slice.empty;\n  }\n\n  var $from = this.resolve(from),\n      $to = this.resolve(to);\n  var depth = includeParents ? 0 : $from.sharedDepth(to);\n  var start = $from.start(depth),\n      node = $from.node(depth);\n  var content = node.content.cut($from.pos - start, $to.pos - start);\n  return new Slice(content, $from.depth - depth, $to.depth - depth);\n}; // :: (number, number, Slice) → Node\n// Replace the part of the document between the given positions with\n// the given slice. The slice must 'fit', meaning its open sides\n// must be able to connect to the surrounding content, and its\n// content nodes must be valid children for the node they are placed\n// into. If any of this is violated, an error of type\n// [`ReplaceError`](#model.ReplaceError) is thrown.\n\n\nNode.prototype.replace = function replace$1(from, to, slice) {\n  return replace(this.resolve(from), this.resolve(to), slice);\n}; // :: (number) → ?Node\n// Find the node directly after the given position.\n\n\nNode.prototype.nodeAt = function nodeAt(pos) {\n  for (var node = this;;) {\n    var ref = node.content.findIndex(pos);\n    var index = ref.index;\n    var offset = ref.offset;\n    node = node.maybeChild(index);\n\n    if (!node) {\n      return null;\n    }\n\n    if (offset == pos || node.isText) {\n      return node;\n    }\n\n    pos -= offset + 1;\n  }\n}; // :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node after the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\n\n\nNode.prototype.childAfter = function childAfter(pos) {\n  var ref = this.content.findIndex(pos);\n  var index = ref.index;\n  var offset = ref.offset;\n  return {\n    node: this.content.maybeChild(index),\n    index: index,\n    offset: offset\n  };\n}; // :: (number) → {node: ?Node, index: number, offset: number}\n// Find the (direct) child node before the given offset, if any,\n// and return it along with its index and offset relative to this\n// node.\n\n\nNode.prototype.childBefore = function childBefore(pos) {\n  if (pos == 0) {\n    return {\n      node: null,\n      index: 0,\n      offset: 0\n    };\n  }\n\n  var ref = this.content.findIndex(pos);\n  var index = ref.index;\n  var offset = ref.offset;\n\n  if (offset < pos) {\n    return {\n      node: this.content.child(index),\n      index: index,\n      offset: offset\n    };\n  }\n\n  var node = this.content.child(index - 1);\n  return {\n    node: node,\n    index: index - 1,\n    offset: offset - node.nodeSize\n  };\n}; // :: (number) → ResolvedPos\n// Resolve the given position in the document, returning an\n// [object](#model.ResolvedPos) with information about its context.\n\n\nNode.prototype.resolve = function resolve(pos) {\n  return ResolvedPos.resolveCached(this, pos);\n};\n\nNode.prototype.resolveNoCache = function resolveNoCache(pos) {\n  return ResolvedPos.resolve(this, pos);\n}; // :: (number, number, union<Mark, MarkType>) → bool\n// Test whether a given mark or mark type occurs in this document\n// between the two given positions.\n\n\nNode.prototype.rangeHasMark = function rangeHasMark(from, to, type) {\n  var found = false;\n\n  if (to > from) {\n    this.nodesBetween(from, to, function (node) {\n      if (type.isInSet(node.marks)) {\n        found = true;\n      }\n\n      return !found;\n    });\n  }\n\n  return found;\n}; // :: bool\n// True when this is a block (non-inline node)\n\n\nprototypeAccessors$3.isBlock.get = function () {\n  return this.type.isBlock;\n}; // :: bool\n// True when this is a textblock node, a block node with inline\n// content.\n\n\nprototypeAccessors$3.isTextblock.get = function () {\n  return this.type.isTextblock;\n}; // :: bool\n// True when this node allows inline content.\n\n\nprototypeAccessors$3.inlineContent.get = function () {\n  return this.type.inlineContent;\n}; // :: bool\n// True when this is an inline node (a text node or a node that can\n// appear among text).\n\n\nprototypeAccessors$3.isInline.get = function () {\n  return this.type.isInline;\n}; // :: bool\n// True when this is a text node.\n\n\nprototypeAccessors$3.isText.get = function () {\n  return this.type.isText;\n}; // :: bool\n// True when this is a leaf node.\n\n\nprototypeAccessors$3.isLeaf.get = function () {\n  return this.type.isLeaf;\n}; // :: bool\n// True when this is an atom, i.e. when it does not have directly\n// editable content. This is usually the same as `isLeaf`, but can\n// be configured with the [`atom` property](#model.NodeSpec.atom) on\n// a node's spec (typically used when the node is displayed as an\n// uneditable [node view](#view.NodeView)).\n\n\nprototypeAccessors$3.isAtom.get = function () {\n  return this.type.isAtom;\n}; // :: () → string\n// Return a string representation of this node for debugging\n// purposes.\n\n\nNode.prototype.toString = function toString() {\n  if (this.type.spec.toDebugString) {\n    return this.type.spec.toDebugString(this);\n  }\n\n  var name = this.type.name;\n\n  if (this.content.size) {\n    name += \"(\" + this.content.toStringInner() + \")\";\n  }\n\n  return wrapMarks(this.marks, name);\n}; // :: (number) → ContentMatch\n// Get the content match in this node at the given index.\n\n\nNode.prototype.contentMatchAt = function contentMatchAt(index) {\n  var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n\n  if (!match) {\n    throw new Error(\"Called contentMatchAt on a node with invalid content\");\n  }\n\n  return match;\n}; // :: (number, number, ?Fragment, ?number, ?number) → bool\n// Test whether replacing the range between `from` and `to` (by\n// child index) with the given replacement fragment (which defaults\n// to the empty fragment) would leave the node's content valid. You\n// can optionally pass `start` and `end` indices into the\n// replacement fragment.\n\n\nNode.prototype.canReplace = function canReplace(from, to, replacement, start, end) {\n  if (replacement === void 0) replacement = Fragment.empty;\n  if (start === void 0) start = 0;\n  if (end === void 0) end = replacement.childCount;\n  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n  var two = one && one.matchFragment(this.content, to);\n\n  if (!two || !two.validEnd) {\n    return false;\n  }\n\n  for (var i = start; i < end; i++) {\n    if (!this.type.allowsMarks(replacement.child(i).marks)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // :: (number, number, NodeType, ?[Mark]) → bool\n// Test whether replacing the range `from` to `to` (by index) with a\n// node of the given type would leave the node's content valid.\n\n\nNode.prototype.canReplaceWith = function canReplaceWith(from, to, type, marks) {\n  if (marks && !this.type.allowsMarks(marks)) {\n    return false;\n  }\n\n  var start = this.contentMatchAt(from).matchType(type);\n  var end = start && start.matchFragment(this.content, to);\n  return end ? end.validEnd : false;\n}; // :: (Node) → bool\n// Test whether the given node's content could be appended to this\n// node. If that node is empty, this will only return true if there\n// is at least one node type that can appear in both nodes (to avoid\n// merging completely incompatible nodes).\n\n\nNode.prototype.canAppend = function canAppend(other) {\n  if (other.content.size) {\n    return this.canReplace(this.childCount, this.childCount, other.content);\n  } else {\n    return this.type.compatibleContent(other.type);\n  }\n}; // :: ()\n// Check whether this node and its descendants conform to the\n// schema, and raise error when they do not.\n\n\nNode.prototype.check = function check() {\n  if (!this.type.validContent(this.content)) {\n    throw new RangeError(\"Invalid content for node \" + this.type.name + \": \" + this.content.toString().slice(0, 50));\n  }\n\n  var copy = Mark.none;\n\n  for (var i = 0; i < this.marks.length; i++) {\n    copy = this.marks[i].addToSet(copy);\n  }\n\n  if (!Mark.sameSet(copy, this.marks)) {\n    throw new RangeError(\"Invalid collection of marks for node \" + this.type.name + \": \" + this.marks.map(function (m) {\n      return m.type.name;\n    }));\n  }\n\n  this.content.forEach(function (node) {\n    return node.check();\n  });\n}; // :: () → Object\n// Return a JSON-serializeable representation of this node.\n\n\nNode.prototype.toJSON = function toJSON() {\n  var obj = {\n    type: this.type.name\n  };\n\n  for (var _ in this.attrs) {\n    obj.attrs = this.attrs;\n    break;\n  }\n\n  if (this.content.size) {\n    obj.content = this.content.toJSON();\n  }\n\n  if (this.marks.length) {\n    obj.marks = this.marks.map(function (n) {\n      return n.toJSON();\n    });\n  }\n\n  return obj;\n}; // :: (Schema, Object) → Node\n// Deserialize a node from its JSON representation.\n\n\nNode.fromJSON = function fromJSON(schema, json) {\n  if (!json) {\n    throw new RangeError(\"Invalid input for Node.fromJSON\");\n  }\n\n  var marks = null;\n\n  if (json.marks) {\n    if (!Array.isArray(json.marks)) {\n      throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n    }\n\n    marks = json.marks.map(schema.markFromJSON);\n  }\n\n  if (json.type == \"text\") {\n    if (typeof json.text != \"string\") {\n      throw new RangeError(\"Invalid text node in JSON\");\n    }\n\n    return schema.text(json.text, marks);\n  }\n\n  var content = Fragment.fromJSON(schema, json.content);\n  return schema.nodeType(json.type).create(json.attrs, content, marks);\n};\n\nObject.defineProperties(Node.prototype, prototypeAccessors$3);\n\nvar TextNode = /*@__PURE__*/function (Node) {\n  function TextNode(type, attrs, content, marks) {\n    Node.call(this, type, attrs, null, marks);\n\n    if (!content) {\n      throw new RangeError(\"Empty text nodes are not allowed\");\n    }\n\n    this.text = content;\n  }\n\n  if (Node) TextNode.__proto__ = Node;\n  TextNode.prototype = Object.create(Node && Node.prototype);\n  TextNode.prototype.constructor = TextNode;\n  var prototypeAccessors$1 = {\n    textContent: {\n      configurable: true\n    },\n    nodeSize: {\n      configurable: true\n    }\n  };\n\n  TextNode.prototype.toString = function toString() {\n    if (this.type.spec.toDebugString) {\n      return this.type.spec.toDebugString(this);\n    }\n\n    return wrapMarks(this.marks, JSON.stringify(this.text));\n  };\n\n  prototypeAccessors$1.textContent.get = function () {\n    return this.text;\n  };\n\n  TextNode.prototype.textBetween = function textBetween(from, to) {\n    return this.text.slice(from, to);\n  };\n\n  prototypeAccessors$1.nodeSize.get = function () {\n    return this.text.length;\n  };\n\n  TextNode.prototype.mark = function mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n  };\n\n  TextNode.prototype.withText = function withText(text) {\n    if (text == this.text) {\n      return this;\n    }\n\n    return new TextNode(this.type, this.attrs, text, this.marks);\n  };\n\n  TextNode.prototype.cut = function cut(from, to) {\n    if (from === void 0) from = 0;\n    if (to === void 0) to = this.text.length;\n\n    if (from == 0 && to == this.text.length) {\n      return this;\n    }\n\n    return this.withText(this.text.slice(from, to));\n  };\n\n  TextNode.prototype.eq = function eq(other) {\n    return this.sameMarkup(other) && this.text == other.text;\n  };\n\n  TextNode.prototype.toJSON = function toJSON() {\n    var base = Node.prototype.toJSON.call(this);\n    base.text = this.text;\n    return base;\n  };\n\n  Object.defineProperties(TextNode.prototype, prototypeAccessors$1);\n  return TextNode;\n}(Node);\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--) {\n    str = marks[i].type.name + \"(\" + str + \")\";\n  }\n\n  return str;\n} // ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\n\n\nvar ContentMatch = function ContentMatch(validEnd) {\n  // :: bool\n  // True when this match state represents a valid end of the node.\n  this.validEnd = validEnd;\n  this.next = [];\n  this.wrapCache = [];\n};\n\nvar prototypeAccessors$4 = {\n  inlineContent: {\n    configurable: true\n  },\n  defaultType: {\n    configurable: true\n  },\n  edgeCount: {\n    configurable: true\n  }\n};\n\nContentMatch.parse = function parse(string, nodeTypes) {\n  var stream = new TokenStream(string, nodeTypes);\n\n  if (stream.next == null) {\n    return ContentMatch.empty;\n  }\n\n  var expr = parseExpr(stream);\n\n  if (stream.next) {\n    stream.err(\"Unexpected trailing text\");\n  }\n\n  var match = dfa(nfa(expr));\n  checkForDeadEnds(match, stream);\n  return match;\n}; // :: (NodeType) → ?ContentMatch\n// Match a node type, returning a match after that node if\n// successful.\n\n\nContentMatch.prototype.matchType = function matchType(type) {\n  for (var i = 0; i < this.next.length; i += 2) {\n    if (this.next[i] == type) {\n      return this.next[i + 1];\n    }\n  }\n\n  return null;\n}; // :: (Fragment, ?number, ?number) → ?ContentMatch\n// Try to match a fragment. Returns the resulting match when\n// successful.\n\n\nContentMatch.prototype.matchFragment = function matchFragment(frag, start, end) {\n  if (start === void 0) start = 0;\n  if (end === void 0) end = frag.childCount;\n  var cur = this;\n\n  for (var i = start; cur && i < end; i++) {\n    cur = cur.matchType(frag.child(i).type);\n  }\n\n  return cur;\n};\n\nprototypeAccessors$4.inlineContent.get = function () {\n  var first = this.next[0];\n  return first ? first.isInline : false;\n}; // :: ?NodeType\n// Get the first matching node type at this match position that can\n// be generated.\n\n\nprototypeAccessors$4.defaultType.get = function () {\n  for (var i = 0; i < this.next.length; i += 2) {\n    var type = this.next[i];\n\n    if (!(type.isText || type.hasRequiredAttrs())) {\n      return type;\n    }\n  }\n};\n\nContentMatch.prototype.compatible = function compatible(other) {\n  for (var i = 0; i < this.next.length; i += 2) {\n    for (var j = 0; j < other.next.length; j += 2) {\n      if (this.next[i] == other.next[j]) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // :: (Fragment, bool, ?number) → ?Fragment\n// Try to match the given fragment, and if that fails, see if it can\n// be made to match by inserting nodes in front of it. When\n// successful, return a fragment of inserted nodes (which may be\n// empty if nothing had to be inserted). When `toEnd` is true, only\n// return a fragment if the resulting match goes to the end of the\n// content expression.\n\n\nContentMatch.prototype.fillBefore = function fillBefore(after, toEnd, startIndex) {\n  if (toEnd === void 0) toEnd = false;\n  if (startIndex === void 0) startIndex = 0;\n  var seen = [this];\n\n  function search(match, types) {\n    var finished = match.matchFragment(after, startIndex);\n\n    if (finished && (!toEnd || finished.validEnd)) {\n      return Fragment.from(types.map(function (tp) {\n        return tp.createAndFill();\n      }));\n    }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i],\n          next = match.next[i + 1];\n\n      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n        seen.push(next);\n        var found = search(next, types.concat(type));\n\n        if (found) {\n          return found;\n        }\n      }\n    }\n  }\n\n  return search(this, []);\n}; // :: (NodeType) → ?[NodeType]\n// Find a set of wrapping node types that would allow a node of the\n// given type to appear at this position. The result may be empty\n// (when it fits directly) and will be null when no such wrapping\n// exists.\n\n\nContentMatch.prototype.findWrapping = function findWrapping(target) {\n  for (var i = 0; i < this.wrapCache.length; i += 2) {\n    if (this.wrapCache[i] == target) {\n      return this.wrapCache[i + 1];\n    }\n  }\n\n  var computed = this.computeWrapping(target);\n  this.wrapCache.push(target, computed);\n  return computed;\n};\n\nContentMatch.prototype.computeWrapping = function computeWrapping(target) {\n  var seen = Object.create(null),\n      active = [{\n    match: this,\n    type: null,\n    via: null\n  }];\n\n  while (active.length) {\n    var current = active.shift(),\n        match = current.match;\n\n    if (match.matchType(target)) {\n      var result = [];\n\n      for (var obj = current; obj.type; obj = obj.via) {\n        result.push(obj.type);\n      }\n\n      return result.reverse();\n    }\n\n    for (var i = 0; i < match.next.length; i += 2) {\n      var type = match.next[i];\n\n      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n        active.push({\n          match: type.contentMatch,\n          type: type,\n          via: current\n        });\n        seen[type.name] = true;\n      }\n    }\n  }\n}; // :: number\n// The number of outgoing edges this node has in the finite\n// automaton that describes the content expression.\n\n\nprototypeAccessors$4.edgeCount.get = function () {\n  return this.next.length >> 1;\n}; // :: (number) → {type: NodeType, next: ContentMatch}\n// Get the _n_​th outgoing edge from this node in the finite\n// automaton that describes the content expression.\n\n\nContentMatch.prototype.edge = function edge(n) {\n  var i = n << 1;\n\n  if (i >= this.next.length) {\n    throw new RangeError(\"There's no \" + n + \"th edge in this content match\");\n  }\n\n  return {\n    type: this.next[i],\n    next: this.next[i + 1]\n  };\n};\n\nContentMatch.prototype.toString = function toString() {\n  var seen = [];\n\n  function scan(m) {\n    seen.push(m);\n\n    for (var i = 1; i < m.next.length; i += 2) {\n      if (seen.indexOf(m.next[i]) == -1) {\n        scan(m.next[i]);\n      }\n    }\n  }\n\n  scan(this);\n  return seen.map(function (m, i) {\n    var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n\n    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {\n      out += (i$1 ? \", \" : \"\") + m.next[i$1].name + \"->\" + seen.indexOf(m.next[i$1 + 1]);\n    }\n\n    return out;\n  }).join(\"\\n\");\n};\n\nObject.defineProperties(ContentMatch.prototype, prototypeAccessors$4);\nContentMatch.empty = new ContentMatch(true);\n\nvar TokenStream = function TokenStream(string, nodeTypes) {\n  this.string = string;\n  this.nodeTypes = nodeTypes;\n  this.inline = null;\n  this.pos = 0;\n  this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n\n  if (this.tokens[this.tokens.length - 1] == \"\") {\n    this.tokens.pop();\n  }\n\n  if (this.tokens[0] == \"\") {\n    this.tokens.shift();\n  }\n};\n\nvar prototypeAccessors$1$2 = {\n  next: {\n    configurable: true\n  }\n};\n\nprototypeAccessors$1$2.next.get = function () {\n  return this.tokens[this.pos];\n};\n\nTokenStream.prototype.eat = function eat(tok) {\n  return this.next == tok && (this.pos++ || true);\n};\n\nTokenStream.prototype.err = function err(str) {\n  throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n};\n\nObject.defineProperties(TokenStream.prototype, prototypeAccessors$1$2);\n\nfunction parseExpr(stream) {\n  var exprs = [];\n\n  do {\n    exprs.push(parseExprSeq(stream));\n  } while (stream.eat(\"|\"));\n\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"choice\",\n    exprs: exprs\n  };\n}\n\nfunction parseExprSeq(stream) {\n  var exprs = [];\n\n  do {\n    exprs.push(parseExprSubscript(stream));\n  } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"seq\",\n    exprs: exprs\n  };\n}\n\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n\n  for (;;) {\n    if (stream.eat(\"+\")) {\n      expr = {\n        type: \"plus\",\n        expr: expr\n      };\n    } else if (stream.eat(\"*\")) {\n      expr = {\n        type: \"star\",\n        expr: expr\n      };\n    } else if (stream.eat(\"?\")) {\n      expr = {\n        type: \"opt\",\n        expr: expr\n      };\n    } else if (stream.eat(\"{\")) {\n      expr = parseExprRange(stream, expr);\n    } else {\n      break;\n    }\n  }\n\n  return expr;\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) {\n    stream.err(\"Expected number, got '\" + stream.next + \"'\");\n  }\n\n  var result = Number(stream.next);\n  stream.pos++;\n  return result;\n}\n\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream),\n      max = min;\n\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") {\n      max = parseNum(stream);\n    } else {\n      max = -1;\n    }\n  }\n\n  if (!stream.eat(\"}\")) {\n    stream.err(\"Unclosed braced range\");\n  }\n\n  return {\n    type: \"range\",\n    min: min,\n    max: max,\n    expr: expr\n  };\n}\n\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes,\n      type = types[name];\n\n  if (type) {\n    return [type];\n  }\n\n  var result = [];\n\n  for (var typeName in types) {\n    var type$1 = types[typeName];\n\n    if (type$1.groups.indexOf(name) > -1) {\n      result.push(type$1);\n    }\n  }\n\n  if (result.length == 0) {\n    stream.err(\"No node type or group '\" + name + \"' found\");\n  }\n\n  return result;\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n\n    if (!stream.eat(\")\")) {\n      stream.err(\"Missing closing paren\");\n    }\n\n    return expr;\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) {\n        stream.inline = type.isInline;\n      } else if (stream.inline != type.isInline) {\n        stream.err(\"Mixing inline and block content\");\n      }\n\n      return {\n        type: \"name\",\n        value: type\n      };\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {\n      type: \"choice\",\n      exprs: exprs\n    };\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n} // The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\n\n\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa;\n\n  function node() {\n    return nfa.push([]) - 1;\n  }\n\n  function edge(from, to, term) {\n    var edge = {\n      term: term,\n      to: to\n    };\n    nfa[from].push(edge);\n    return edge;\n  }\n\n  function connect(edges, to) {\n    edges.forEach(function (edge) {\n      return edge.to = to;\n    });\n  }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) {\n        return out.concat(compile(expr, from));\n      }, []);\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n\n        if (i == expr.exprs.length - 1) {\n          return next;\n        }\n\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)];\n    } else if (expr.type == \"plus\") {\n      var loop$1 = node();\n      connect(compile(expr.expr, from), loop$1);\n      connect(compile(expr.expr, loop$1), loop$1);\n      return [edge(loop$1)];\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from));\n    } else if (expr.type == \"range\") {\n      var cur = from;\n\n      for (var i$1 = 0; i$1 < expr.min; i$1++) {\n        var next$1 = node();\n        connect(compile(expr.expr, cur), next$1);\n        cur = next$1;\n      }\n\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {\n          var next$2 = node();\n          edge(cur, next$2);\n          connect(compile(expr.expr, cur), next$2);\n          cur = next$2;\n        }\n      }\n\n      return [edge(cur)];\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)];\n    }\n  }\n}\n\nfunction cmp(a, b) {\n  return b - a;\n} // Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\n\n\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp);\n\n  function scan(node) {\n    var edges = nfa[node];\n\n    if (edges.length == 1 && !edges[0].term) {\n      return scan(edges[0].to);\n    }\n\n    result.push(node);\n\n    for (var i = 0; i < edges.length; i++) {\n      var ref = edges[i];\n      var term = ref.term;\n      var to = ref.to;\n\n      if (!term && result.indexOf(to) == -1) {\n        scan(to);\n      }\n    }\n  }\n} // : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\n\n\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0));\n\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (ref) {\n        var term = ref.term;\n        var to = ref.to;\n\n        if (!term) {\n          return;\n        }\n\n        var known = out.indexOf(term),\n            set = known > -1 && out[known + 1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) {\n            out.push(term, set = []);\n          }\n\n          if (set.indexOf(node) == -1) {\n            set.push(node);\n          }\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n\n    for (var i = 0; i < out.length; i += 2) {\n      var states$1 = out[i + 1].sort(cmp);\n      state.next.push(out[i], labeled[states$1.join(\",\")] || explore(states$1));\n    }\n\n    return state;\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i],\n        dead = !state.validEnd,\n        nodes = [];\n\n    for (var j = 0; j < state.next.length; j += 2) {\n      var node = state.next[j],\n          next = state.next[j + 1];\n      nodes.push(node.name);\n\n      if (dead && !(node.isText || node.hasRequiredAttrs())) {\n        dead = false;\n      }\n\n      if (work.indexOf(next) == -1) {\n        work.push(next);\n      }\n    }\n\n    if (dead) {\n      stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n    }\n  }\n} // For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\n\n\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n\n    if (!attr.hasDefault) {\n      return null;\n    }\n\n    defaults[attrName] = attr.default;\n  }\n\n  return defaults;\n}\n\nfunction computeAttrs(attrs, value) {\n  var built = Object.create(null);\n\n  for (var name in attrs) {\n    var given = value && value[name];\n\n    if (given === undefined) {\n      var attr = attrs[name];\n\n      if (attr.hasDefault) {\n        given = attr.default;\n      } else {\n        throw new RangeError(\"No value supplied for attribute \" + name);\n      }\n    }\n\n    built[name] = given;\n  }\n\n  return built;\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null);\n\n  if (attrs) {\n    for (var name in attrs) {\n      result[name] = new Attribute(attrs[name]);\n    }\n  }\n\n  return result;\n} // ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\n\n\nvar NodeType = function NodeType(name, schema, spec) {\n  // :: string\n  // The name the node type has in this schema.\n  this.name = name; // :: Schema\n  // A link back to the `Schema` the node type belongs to.\n\n  this.schema = schema; // :: NodeSpec\n  // The spec that this type is based on\n\n  this.spec = spec;\n  this.groups = spec.group ? spec.group.split(\" \") : [];\n  this.attrs = initAttrs(spec.attrs);\n  this.defaultAttrs = defaultAttrs(this.attrs); // :: ContentMatch\n  // The starting match of the node type's content expression.\n\n  this.contentMatch = null; // : ?[MarkType]\n  // The set of marks allowed in this node. `null` means all marks\n  // are allowed.\n\n  this.markSet = null; // :: bool\n  // True if this node type has inline content.\n\n  this.inlineContent = null; // :: bool\n  // True if this is a block type\n\n  this.isBlock = !(spec.inline || name == \"text\"); // :: bool\n  // True if this is the text node type.\n\n  this.isText = name == \"text\";\n};\n\nvar prototypeAccessors$5 = {\n  isInline: {\n    configurable: true\n  },\n  isTextblock: {\n    configurable: true\n  },\n  isLeaf: {\n    configurable: true\n  },\n  isAtom: {\n    configurable: true\n  },\n  whitespace: {\n    configurable: true\n  }\n}; // :: bool\n// True if this is an inline type.\n\nprototypeAccessors$5.isInline.get = function () {\n  return !this.isBlock;\n}; // :: bool\n// True if this is a textblock type, a block that contains inline\n// content.\n\n\nprototypeAccessors$5.isTextblock.get = function () {\n  return this.isBlock && this.inlineContent;\n}; // :: bool\n// True for node types that allow no content.\n\n\nprototypeAccessors$5.isLeaf.get = function () {\n  return this.contentMatch == ContentMatch.empty;\n}; // :: bool\n// True when this node is an atom, i.e. when it does not have\n// directly editable content.\n\n\nprototypeAccessors$5.isAtom.get = function () {\n  return this.isLeaf || this.spec.atom;\n}; // :: union<\"pre\", \"normal\">\n// The node type's [whitespace](#view.NodeSpec.whitespace) option.\n\n\nprototypeAccessors$5.whitespace.get = function () {\n  return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n}; // :: () → bool\n// Tells you whether this node type has any required attributes.\n\n\nNodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs() {\n  for (var n in this.attrs) {\n    if (this.attrs[n].isRequired) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nNodeType.prototype.compatibleContent = function compatibleContent(other) {\n  return this == other || this.contentMatch.compatible(other.contentMatch);\n};\n\nNodeType.prototype.computeAttrs = function computeAttrs$1(attrs) {\n  if (!attrs && this.defaultAttrs) {\n    return this.defaultAttrs;\n  } else {\n    return computeAttrs(this.attrs, attrs);\n  }\n}; // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a `Node` of this type. The given attributes are\n// checked and defaulted (you can pass `null` to use the type's\n// defaults entirely, if no required attributes exist). `content`\n// may be a `Fragment`, a node, an array of nodes, or\n// `null`. Similarly `marks` may be `null` to default to the empty\n// set of marks.\n\n\nNodeType.prototype.create = function create(attrs, content, marks) {\n  if (this.isText) {\n    throw new Error(\"NodeType.create can't construct text nodes\");\n  }\n\n  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n}; // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Like [`create`](#model.NodeType.create), but check the given content\n// against the node type's content restrictions, and throw an error\n// if it doesn't match.\n\n\nNodeType.prototype.createChecked = function createChecked(attrs, content, marks) {\n  content = Fragment.from(content);\n\n  if (!this.validContent(content)) {\n    throw new RangeError(\"Invalid content for node \" + this.name);\n  }\n\n  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n}; // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n// Like [`create`](#model.NodeType.create), but see if it is necessary to\n// add nodes to the start or end of the given fragment to make it\n// fit the node. If no fitting wrapping can be found, return null.\n// Note that, due to the fact that required nodes can always be\n// created, this will always succeed if you pass null or\n// `Fragment.empty` as content.\n\n\nNodeType.prototype.createAndFill = function createAndFill(attrs, content, marks) {\n  attrs = this.computeAttrs(attrs);\n  content = Fragment.from(content);\n\n  if (content.size) {\n    var before = this.contentMatch.fillBefore(content);\n\n    if (!before) {\n      return null;\n    }\n\n    content = before.append(content);\n  }\n\n  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);\n\n  if (!after) {\n    return null;\n  }\n\n  return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n}; // :: (Fragment) → bool\n// Returns true if the given fragment is valid content for this node\n// type with the given attributes.\n\n\nNodeType.prototype.validContent = function validContent(content) {\n  var result = this.contentMatch.matchFragment(content);\n\n  if (!result || !result.validEnd) {\n    return false;\n  }\n\n  for (var i = 0; i < content.childCount; i++) {\n    if (!this.allowsMarks(content.child(i).marks)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // :: (MarkType) → bool\n// Check whether the given mark type is allowed in this node.\n\n\nNodeType.prototype.allowsMarkType = function allowsMarkType(markType) {\n  return this.markSet == null || this.markSet.indexOf(markType) > -1;\n}; // :: ([Mark]) → bool\n// Test whether the given set of marks are allowed in this node.\n\n\nNodeType.prototype.allowsMarks = function allowsMarks(marks) {\n  if (this.markSet == null) {\n    return true;\n  }\n\n  for (var i = 0; i < marks.length; i++) {\n    if (!this.allowsMarkType(marks[i].type)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // :: ([Mark]) → [Mark]\n// Removes the marks that are not allowed in this node from the given set.\n\n\nNodeType.prototype.allowedMarks = function allowedMarks(marks) {\n  if (this.markSet == null) {\n    return marks;\n  }\n\n  var copy;\n\n  for (var i = 0; i < marks.length; i++) {\n    if (!this.allowsMarkType(marks[i].type)) {\n      if (!copy) {\n        copy = marks.slice(0, i);\n      }\n    } else if (copy) {\n      copy.push(marks[i]);\n    }\n  }\n\n  return !copy ? marks : copy.length ? copy : Mark.empty;\n};\n\nNodeType.compile = function compile(nodes, schema) {\n  var result = Object.create(null);\n  nodes.forEach(function (name, spec) {\n    return result[name] = new NodeType(name, schema, spec);\n  });\n  var topType = schema.spec.topNode || \"doc\";\n\n  if (!result[topType]) {\n    throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n  }\n\n  if (!result.text) {\n    throw new RangeError(\"Every schema needs a 'text' type\");\n  }\n\n  for (var _ in result.text.attrs) {\n    throw new RangeError(\"The text node type should not have attributes\");\n  }\n\n  return result;\n};\n\nObject.defineProperties(NodeType.prototype, prototypeAccessors$5); // Attribute descriptors\n\nvar Attribute = function Attribute(options) {\n  this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n  this.default = options.default;\n};\n\nvar prototypeAccessors$1$3 = {\n  isRequired: {\n    configurable: true\n  }\n};\n\nprototypeAccessors$1$3.isRequired.get = function () {\n  return !this.hasDefault;\n};\n\nObject.defineProperties(Attribute.prototype, prototypeAccessors$1$3); // Marks\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\n\nvar MarkType = function MarkType(name, rank, schema, spec) {\n  // :: string\n  // The name of the mark type.\n  this.name = name; // :: Schema\n  // The schema that this mark type instance is part of.\n\n  this.schema = schema; // :: MarkSpec\n  // The spec on which the type is based.\n\n  this.spec = spec;\n  this.attrs = initAttrs(spec.attrs);\n  this.rank = rank;\n  this.excluded = null;\n  var defaults = defaultAttrs(this.attrs);\n  this.instance = defaults && new Mark(this, defaults);\n}; // :: (?Object) → Mark\n// Create a mark of this type. `attrs` may be `null` or an object\n// containing only some of the mark's attributes. The others, if\n// they have defaults, will be added.\n\n\nMarkType.prototype.create = function create(attrs) {\n  if (!attrs && this.instance) {\n    return this.instance;\n  }\n\n  return new Mark(this, computeAttrs(this.attrs, attrs));\n};\n\nMarkType.compile = function compile(marks, schema) {\n  var result = Object.create(null),\n      rank = 0;\n  marks.forEach(function (name, spec) {\n    return result[name] = new MarkType(name, rank++, schema, spec);\n  });\n  return result;\n}; // :: ([Mark]) → [Mark]\n// When there is a mark of this type in the given set, a new set\n// without it is returned. Otherwise, the input set is returned.\n\n\nMarkType.prototype.removeFromSet = function removeFromSet(set) {\n  for (var i = 0; i < set.length; i++) {\n    if (set[i].type == this) {\n      set = set.slice(0, i).concat(set.slice(i + 1));\n      i--;\n    }\n  }\n\n  return set;\n}; // :: ([Mark]) → ?Mark\n// Tests whether there is a mark of this type in the given set.\n\n\nMarkType.prototype.isInSet = function isInSet(set) {\n  for (var i = 0; i < set.length; i++) {\n    if (set[i].type == this) {\n      return set[i];\n    }\n  }\n}; // :: (MarkType) → bool\n// Queries whether a given mark type is\n// [excluded](#model.MarkSpec.excludes) by this one.\n\n\nMarkType.prototype.excludes = function excludes(other) {\n  return this.excluded.indexOf(other) > -1;\n}; // SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   whitespace:: ?union<\"pre\", \"normal\">\n//   Controls way whitespace in this a node is parsed. The default is\n//   `\"normal\"`, which causes the [DOM parser](#model.DOMParser) to\n//   collapse whitespace in normal mode, and normalize it (replacing\n//   newlines and such with spaces) otherwise. `\"pre\"` causes the\n//   parser to preserve spaces inside the node. When this option isn't\n//   given, but [`code`](#model.NodeSpec.code) is true, `whitespace`\n//   will default to `\"pre\"`. Note that this option doesn't influence\n//   the way the node is rendered—that should be handled by `toDOM`\n//   and/or styling.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\n\n\nvar Schema = function Schema(spec) {\n  // :: SchemaSpec\n  // The [spec](#model.SchemaSpec) on which the schema is based,\n  // with the added guarantee that its `nodes` and `marks`\n  // properties are\n  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n  // (not raw objects).\n  this.spec = {};\n\n  for (var prop in spec) {\n    this.spec[prop] = spec[prop];\n  }\n\n  this.spec.nodes = OrderedMap.from(spec.nodes);\n  this.spec.marks = OrderedMap.from(spec.marks); // :: Object<NodeType>\n  // An object mapping the schema's node names to node type objects.\n\n  this.nodes = NodeType.compile(this.spec.nodes, this); // :: Object<MarkType>\n  // A map from mark names to mark type objects.\n\n  this.marks = MarkType.compile(this.spec.marks, this);\n  var contentExprCache = Object.create(null);\n\n  for (var prop$1 in this.nodes) {\n    if (prop$1 in this.marks) {\n      throw new RangeError(prop$1 + \" can not be both a node and a mark\");\n    }\n\n    var type = this.nodes[prop$1],\n        contentExpr = type.spec.content || \"\",\n        markExpr = type.spec.marks;\n    type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n    type.inlineContent = type.contentMatch.inlineContent;\n    type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n  }\n\n  for (var prop$2 in this.marks) {\n    var type$1 = this.marks[prop$2],\n        excl = type$1.spec.excludes;\n    type$1.excluded = excl == null ? [type$1] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n  }\n\n  this.nodeFromJSON = this.nodeFromJSON.bind(this);\n  this.markFromJSON = this.markFromJSON.bind(this); // :: NodeType\n  // The type of the [default top node](#model.SchemaSpec.topNode)\n  // for this schema.\n\n  this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]; // :: Object\n  // An object for storing whatever values modules may want to\n  // compute and cache per schema. (If you want to store something\n  // in it, try to use property names unlikely to clash.)\n\n  this.cached = Object.create(null);\n  this.cached.wrappings = Object.create(null);\n}; // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n// Create a node in this schema. The `type` may be a string or a\n// `NodeType` instance. Attributes will be extended\n// with defaults, `content` may be a `Fragment`,\n// `null`, a `Node`, or an array of nodes.\n\n\nSchema.prototype.node = function node(type, attrs, content, marks) {\n  if (typeof type == \"string\") {\n    type = this.nodeType(type);\n  } else if (!(type instanceof NodeType)) {\n    throw new RangeError(\"Invalid node type: \" + type);\n  } else if (type.schema != this) {\n    throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n  }\n\n  return type.createChecked(attrs, content, marks);\n}; // :: (string, ?[Mark]) → Node\n// Create a text node in the schema. Empty text nodes are not\n// allowed.\n\n\nSchema.prototype.text = function text(text$1, marks) {\n  var type = this.nodes.text;\n  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks));\n}; // :: (union<string, MarkType>, ?Object) → Mark\n// Create a mark with the given type and attributes.\n\n\nSchema.prototype.mark = function mark(type, attrs) {\n  if (typeof type == \"string\") {\n    type = this.marks[type];\n  }\n\n  return type.create(attrs);\n}; // :: (Object) → Node\n// Deserialize a node from its JSON representation. This method is\n// bound.\n\n\nSchema.prototype.nodeFromJSON = function nodeFromJSON(json) {\n  return Node.fromJSON(this, json);\n}; // :: (Object) → Mark\n// Deserialize a mark from its JSON representation. This method is\n// bound.\n\n\nSchema.prototype.markFromJSON = function markFromJSON(json) {\n  return Mark.fromJSON(this, json);\n};\n\nSchema.prototype.nodeType = function nodeType(name) {\n  var found = this.nodes[name];\n\n  if (!found) {\n    throw new RangeError(\"Unknown node type: \" + name);\n  }\n\n  return found;\n};\n\nfunction gatherMarks(schema, marks) {\n  var found = [];\n\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i],\n        mark = schema.marks[name],\n        ok = mark;\n\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var mark$1 = schema.marks[prop];\n\n        if (name == \"_\" || mark$1.spec.group && mark$1.spec.group.split(\" \").indexOf(name) > -1) {\n          found.push(ok = mark$1);\n        }\n      }\n    }\n\n    if (!ok) {\n      throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n    }\n  }\n\n  return found;\n} // ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\n\n\nvar DOMParser = function DOMParser(schema, rules) {\n  var this$1 = this; // :: Schema\n  // The schema into which the parser parses.\n\n  this.schema = schema; // :: [ParseRule]\n  // The set of [parse rules](#model.ParseRule) that the parser\n  // uses, in order of precedence.\n\n  this.rules = rules;\n  this.tags = [];\n  this.styles = [];\n  rules.forEach(function (rule) {\n    if (rule.tag) {\n      this$1.tags.push(rule);\n    } else if (rule.style) {\n      this$1.styles.push(rule);\n    }\n  }); // Only normalize list elements when lists in the schema can't directly contain themselves\n\n  this.normalizeLists = !this.tags.some(function (r) {\n    if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) {\n      return false;\n    }\n\n    var node = schema.nodes[r.node];\n    return node.contentMatch.matchType(node);\n  });\n}; // :: (dom.Node, ?ParseOptions) → Node\n// Parse a document from the content of a DOM node.\n\n\nDOMParser.prototype.parse = function parse(dom, options) {\n  if (options === void 0) options = {};\n  var context = new ParseContext(this, options, false);\n  context.addAll(dom, null, options.from, options.to);\n  return context.finish();\n}; // :: (dom.Node, ?ParseOptions) → Slice\n// Parses the content of the given DOM node, like\n// [`parse`](#model.DOMParser.parse), and takes the same set of\n// options. But unlike that method, which produces a whole node,\n// this one returns a slice that is open at the sides, meaning that\n// the schema constraints aren't applied to the start of nodes to\n// the left of the input and the end of nodes at the end.\n\n\nDOMParser.prototype.parseSlice = function parseSlice(dom, options) {\n  if (options === void 0) options = {};\n  var context = new ParseContext(this, options, true);\n  context.addAll(dom, null, options.from, options.to);\n  return Slice.maxOpen(context.finish());\n};\n\nDOMParser.prototype.matchTag = function matchTag(dom, context, after) {\n  for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n    var rule = this.tags[i];\n\n    if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n      if (rule.getAttrs) {\n        var result = rule.getAttrs(dom);\n\n        if (result === false) {\n          continue;\n        }\n\n        rule.attrs = result;\n      }\n\n      return rule;\n    }\n  }\n};\n\nDOMParser.prototype.matchStyle = function matchStyle(prop, value, context, after) {\n  for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n    var rule = this.styles[i];\n\n    if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,\n    // or has an '=' sign after the prop, followed by the given\n    // value.\n    rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {\n      continue;\n    }\n\n    if (rule.getAttrs) {\n      var result = rule.getAttrs(value);\n\n      if (result === false) {\n        continue;\n      }\n\n      rule.attrs = result;\n    }\n\n    return rule;\n  }\n}; // : (Schema) → [ParseRule]\n\n\nDOMParser.schemaRules = function schemaRules(schema) {\n  var result = [];\n\n  function insert(rule) {\n    var priority = rule.priority == null ? 50 : rule.priority,\n        i = 0;\n\n    for (; i < result.length; i++) {\n      var next = result[i],\n          nextPriority = next.priority == null ? 50 : next.priority;\n\n      if (nextPriority < priority) {\n        break;\n      }\n    }\n\n    result.splice(i, 0, rule);\n  }\n\n  var loop = function (name) {\n    var rules = schema.marks[name].spec.parseDOM;\n\n    if (rules) {\n      rules.forEach(function (rule) {\n        insert(rule = copy(rule));\n        rule.mark = name;\n      });\n    }\n  };\n\n  for (var name in schema.marks) loop(name);\n\n  var loop$1 = function (name) {\n    var rules$1 = schema.nodes[name$1].spec.parseDOM;\n\n    if (rules$1) {\n      rules$1.forEach(function (rule) {\n        insert(rule = copy(rule));\n        rule.node = name$1;\n      });\n    }\n  };\n\n  for (var name$1 in schema.nodes) loop$1();\n\n  return result;\n}; // :: (Schema) → DOMParser\n// Construct a DOM parser using the parsing rules listed in a\n// schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n// [priority](#model.ParseRule.priority).\n\n\nDOMParser.fromSchema = function fromSchema(schema) {\n  return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n}; // : Object<bool> The block-level tags in HTML5\n\n\nvar blockTags = {\n  address: true,\n  article: true,\n  aside: true,\n  blockquote: true,\n  canvas: true,\n  dd: true,\n  div: true,\n  dl: true,\n  fieldset: true,\n  figcaption: true,\n  figure: true,\n  footer: true,\n  form: true,\n  h1: true,\n  h2: true,\n  h3: true,\n  h4: true,\n  h5: true,\n  h6: true,\n  header: true,\n  hgroup: true,\n  hr: true,\n  li: true,\n  noscript: true,\n  ol: true,\n  output: true,\n  p: true,\n  pre: true,\n  section: true,\n  table: true,\n  tfoot: true,\n  ul: true\n}; // : Object<bool> The tags that we normally ignore.\n\nvar ignoreTags = {\n  head: true,\n  noscript: true,\n  object: true,\n  script: true,\n  style: true,\n  title: true\n}; // : Object<bool> List tags.\n\nvar listTags = {\n  ol: true,\n  ul: true\n}; // Using a bitfield for node context options\n\nvar OPT_PRESERVE_WS = 1,\n    OPT_PRESERVE_WS_FULL = 2,\n    OPT_OPEN_LEFT = 4;\n\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) {\n    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n  }\n\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\n\nvar NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {\n  this.type = type;\n  this.attrs = attrs;\n  this.solid = solid;\n  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  this.options = options;\n  this.content = []; // Marks applied to this node itself\n\n  this.marks = marks; // Marks applied to its children\n\n  this.activeMarks = Mark.none; // Marks that can't apply here, but will be used in children if possible\n\n  this.pendingMarks = pendingMarks; // Nested Marks with same type\n\n  this.stashMarks = [];\n};\n\nNodeContext.prototype.findWrapping = function findWrapping(node) {\n  if (!this.match) {\n    if (!this.type) {\n      return [];\n    }\n\n    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n\n    if (fill) {\n      this.match = this.type.contentMatch.matchFragment(fill);\n    } else {\n      var start = this.type.contentMatch,\n          wrap;\n\n      if (wrap = start.findWrapping(node.type)) {\n        this.match = start;\n        return wrap;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  return this.match.findWrapping(node.type);\n};\n\nNodeContext.prototype.finish = function finish(openEnd) {\n  if (!(this.options & OPT_PRESERVE_WS)) {\n    // Strip trailing whitespace\n    var last = this.content[this.content.length - 1],\n        m;\n\n    if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n      if (last.text.length == m[0].length) {\n        this.content.pop();\n      } else {\n        this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));\n      }\n    }\n  }\n\n  var content = Fragment.from(this.content);\n\n  if (!openEnd && this.match) {\n    content = content.append(this.match.fillBefore(Fragment.empty, true));\n  }\n\n  return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n};\n\nNodeContext.prototype.popFromStashMark = function popFromStashMark(mark) {\n  for (var i = this.stashMarks.length - 1; i >= 0; i--) {\n    if (mark.eq(this.stashMarks[i])) {\n      return this.stashMarks.splice(i, 1)[0];\n    }\n  }\n};\n\nNodeContext.prototype.applyPending = function applyPending(nextType) {\n  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n    var mark = pending[i];\n\n    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {\n      this.activeMarks = mark.addToSet(this.activeMarks);\n      this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n    }\n  }\n};\n\nNodeContext.prototype.inlineContext = function inlineContext(node) {\n  if (this.type) {\n    return this.type.inlineContent;\n  }\n\n  if (this.content.length) {\n    return this.content[0].isInline;\n  }\n\n  return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n};\n\nvar ParseContext = function ParseContext(parser, options, open) {\n  // : DOMParser The parser we are using.\n  this.parser = parser; // : Object The options passed to this parse.\n\n  this.options = options;\n  this.isOpen = open;\n  var topNode = options.topNode,\n      topContext;\n  var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0);\n\n  if (topNode) {\n    topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n  } else if (open) {\n    topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);\n  } else {\n    topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);\n  }\n\n  this.nodes = [topContext]; // : [Mark] The current set of marks\n\n  this.open = 0;\n  this.find = options.findPositions;\n  this.needsBlock = false;\n};\n\nvar prototypeAccessors$6 = {\n  top: {\n    configurable: true\n  },\n  currentPos: {\n    configurable: true\n  }\n};\n\nprototypeAccessors$6.top.get = function () {\n  return this.nodes[this.open];\n}; // : (dom.Node)\n// Add a DOM node to the content. Text is inserted as text node,\n// otherwise, the node is passed to `addElement` or, if it has a\n// `style` attribute, `addElementWithStyles`.\n\n\nParseContext.prototype.addDOM = function addDOM(dom) {\n  if (dom.nodeType == 3) {\n    this.addTextNode(dom);\n  } else if (dom.nodeType == 1) {\n    var style = dom.getAttribute(\"style\");\n    var marks = style ? this.readStyles(parseStyles(style)) : null,\n        top = this.top;\n\n    if (marks != null) {\n      for (var i = 0; i < marks.length; i++) {\n        this.addPendingMark(marks[i]);\n      }\n    }\n\n    this.addElement(dom);\n\n    if (marks != null) {\n      for (var i$1 = 0; i$1 < marks.length; i$1++) {\n        this.removePendingMark(marks[i$1], top);\n      }\n    }\n  }\n};\n\nParseContext.prototype.addTextNode = function addTextNode(dom) {\n  var value = dom.nodeValue;\n  var top = this.top;\n\n  if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n    if (!(top.options & OPT_PRESERVE_WS)) {\n      value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \"); // If this starts with whitespace, and there is no node before it, or\n      // a hard break, or a text node that ends with whitespace, strip the\n      // leading space.\n\n      if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n        var nodeBefore = top.content[top.content.length - 1];\n        var domNodeBefore = dom.previousSibling;\n\n        if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)) {\n          value = value.slice(1);\n        }\n      }\n    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n      value = value.replace(/\\r?\\n|\\r/g, \" \");\n    } else {\n      value = value.replace(/\\r\\n?/g, \"\\n\");\n    }\n\n    if (value) {\n      this.insertNode(this.parser.schema.text(value));\n    }\n\n    this.findInText(dom);\n  } else {\n    this.findInside(dom);\n  }\n}; // : (dom.Element, ?ParseRule)\n// Try to find a handler for the given tag and use that to parse. If\n// none is found, the element's content nodes are added directly.\n\n\nParseContext.prototype.addElement = function addElement(dom, matchAfter) {\n  var name = dom.nodeName.toLowerCase(),\n      ruleID;\n\n  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) {\n    normalizeList(dom);\n  }\n\n  var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n\n  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n    this.findInside(dom);\n    this.ignoreFallback(dom);\n  } else if (!rule || rule.skip || rule.closeParent) {\n    if (rule && rule.closeParent) {\n      this.open = Math.max(0, this.open - 1);\n    } else if (rule && rule.skip.nodeType) {\n      dom = rule.skip;\n    }\n\n    var sync,\n        top = this.top,\n        oldNeedsBlock = this.needsBlock;\n\n    if (blockTags.hasOwnProperty(name)) {\n      sync = true;\n\n      if (!top.type) {\n        this.needsBlock = true;\n      }\n    } else if (!dom.firstChild) {\n      this.leafFallback(dom);\n      return;\n    }\n\n    this.addAll(dom);\n\n    if (sync) {\n      this.sync(top);\n    }\n\n    this.needsBlock = oldNeedsBlock;\n  } else {\n    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);\n  }\n}; // Called for leaf DOM nodes that would otherwise be ignored\n\n\nParseContext.prototype.leafFallback = function leafFallback(dom) {\n  if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent) {\n    this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"));\n  }\n}; // Called for ignored nodes\n\n\nParseContext.prototype.ignoreFallback = function ignoreFallback(dom) {\n  // Ignored BR nodes should at least create an inline context\n  if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent)) {\n    this.findPlace(this.parser.schema.text(\"-\"));\n  }\n}; // Run any style parser associated with the node's styles. Either\n// return an array of marks, or null to indicate some of the styles\n// had a rule with `ignore` set.\n\n\nParseContext.prototype.readStyles = function readStyles(styles) {\n  var marks = Mark.none;\n\n  style: for (var i = 0; i < styles.length; i += 2) {\n    for (var after = null;;) {\n      var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n\n      if (!rule) {\n        continue style;\n      }\n\n      if (rule.ignore) {\n        return null;\n      }\n\n      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n\n      if (rule.consuming === false) {\n        after = rule;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return marks;\n}; // : (dom.Element, ParseRule) → bool\n// Look up a handler for the given node. If none are found, return\n// false. Otherwise, apply it, use its return value to drive the way\n// the node's content is wrapped, and return true.\n\n\nParseContext.prototype.addElementByRule = function addElementByRule(dom, rule, continueAfter) {\n  var this$1 = this;\n  var sync, nodeType, markType, mark;\n\n  if (rule.node) {\n    nodeType = this.parser.schema.nodes[rule.node];\n\n    if (!nodeType.isLeaf) {\n      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);\n    } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n      this.leafFallback(dom);\n    }\n  } else {\n    markType = this.parser.schema.marks[rule.mark];\n    mark = markType.create(rule.attrs);\n    this.addPendingMark(mark);\n  }\n\n  var startIn = this.top;\n\n  if (nodeType && nodeType.isLeaf) {\n    this.findInside(dom);\n  } else if (continueAfter) {\n    this.addElement(dom, continueAfter);\n  } else if (rule.getContent) {\n    this.findInside(dom);\n    rule.getContent(dom, this.parser.schema).forEach(function (node) {\n      return this$1.insertNode(node);\n    });\n  } else {\n    var contentDOM = rule.contentElement;\n\n    if (typeof contentDOM == \"string\") {\n      contentDOM = dom.querySelector(contentDOM);\n    } else if (typeof contentDOM == \"function\") {\n      contentDOM = contentDOM(dom);\n    }\n\n    if (!contentDOM) {\n      contentDOM = dom;\n    }\n\n    this.findAround(dom, contentDOM, true);\n    this.addAll(contentDOM, sync);\n  }\n\n  if (sync) {\n    this.sync(startIn);\n    this.open--;\n  }\n\n  if (mark) {\n    this.removePendingMark(mark, startIn);\n  }\n}; // : (dom.Node, ?NodeBuilder, ?number, ?number)\n// Add all child nodes between `startIndex` and `endIndex` (or the\n// whole node, if not given). If `sync` is passed, use it to\n// synchronize after every block element.\n\n\nParseContext.prototype.addAll = function addAll(parent, sync, startIndex, endIndex) {\n  var index = startIndex || 0;\n\n  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n    this.findAtPoint(parent, index);\n    this.addDOM(dom);\n\n    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {\n      this.sync(sync);\n    }\n  }\n\n  this.findAtPoint(parent, index);\n}; // Try to find a way to fit the given node type into the current\n// context. May add intermediate wrappers and/or leave non-solid\n// nodes that we're in.\n\n\nParseContext.prototype.findPlace = function findPlace(node) {\n  var route, sync;\n\n  for (var depth = this.open; depth >= 0; depth--) {\n    var cx = this.nodes[depth];\n    var found = cx.findWrapping(node);\n\n    if (found && (!route || route.length > found.length)) {\n      route = found;\n      sync = cx;\n\n      if (!found.length) {\n        break;\n      }\n    }\n\n    if (cx.solid) {\n      break;\n    }\n  }\n\n  if (!route) {\n    return false;\n  }\n\n  this.sync(sync);\n\n  for (var i = 0; i < route.length; i++) {\n    this.enterInner(route[i], null, false);\n  }\n\n  return true;\n}; // : (Node) → ?Node\n// Try to insert the given node, adjusting the context when needed.\n\n\nParseContext.prototype.insertNode = function insertNode(node) {\n  if (node.isInline && this.needsBlock && !this.top.type) {\n    var block = this.textblockFromContext();\n\n    if (block) {\n      this.enterInner(block);\n    }\n  }\n\n  if (this.findPlace(node)) {\n    this.closeExtra();\n    var top = this.top;\n    top.applyPending(node.type);\n\n    if (top.match) {\n      top.match = top.match.matchType(node.type);\n    }\n\n    var marks = top.activeMarks;\n\n    for (var i = 0; i < node.marks.length; i++) {\n      if (!top.type || top.type.allowsMarkType(node.marks[i].type)) {\n        marks = node.marks[i].addToSet(marks);\n      }\n    }\n\n    top.content.push(node.mark(marks));\n    return true;\n  }\n\n  return false;\n}; // : (NodeType, ?Object) → bool\n// Try to start a node of the given type, adjusting the context when\n// necessary.\n\n\nParseContext.prototype.enter = function enter(type, attrs, preserveWS) {\n  var ok = this.findPlace(type.create(attrs));\n\n  if (ok) {\n    this.enterInner(type, attrs, true, preserveWS);\n  }\n\n  return ok;\n}; // Open a node of the given type\n\n\nParseContext.prototype.enterInner = function enterInner(type, attrs, solid, preserveWS) {\n  this.closeExtra();\n  var top = this.top;\n  top.applyPending(type);\n  top.match = top.match && top.match.matchType(type, attrs);\n  var options = wsOptionsFor(type, preserveWS, top.options);\n\n  if (top.options & OPT_OPEN_LEFT && top.content.length == 0) {\n    options |= OPT_OPEN_LEFT;\n  }\n\n  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n  this.open++;\n}; // Make sure all nodes above this.open are finished and added to\n// their parents\n\n\nParseContext.prototype.closeExtra = function closeExtra(openEnd) {\n  var i = this.nodes.length - 1;\n\n  if (i > this.open) {\n    for (; i > this.open; i--) {\n      this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n    }\n\n    this.nodes.length = this.open + 1;\n  }\n};\n\nParseContext.prototype.finish = function finish() {\n  this.open = 0;\n  this.closeExtra(this.isOpen);\n  return this.nodes[0].finish(this.isOpen || this.options.topOpen);\n};\n\nParseContext.prototype.sync = function sync(to) {\n  for (var i = this.open; i >= 0; i--) {\n    if (this.nodes[i] == to) {\n      this.open = i;\n      return;\n    }\n  }\n};\n\nprototypeAccessors$6.currentPos.get = function () {\n  this.closeExtra();\n  var pos = 0;\n\n  for (var i = this.open; i >= 0; i--) {\n    var content = this.nodes[i].content;\n\n    for (var j = content.length - 1; j >= 0; j--) {\n      pos += content[j].nodeSize;\n    }\n\n    if (i) {\n      pos++;\n    }\n  }\n\n  return pos;\n};\n\nParseContext.prototype.findAtPoint = function findAtPoint(parent, offset) {\n  if (this.find) {\n    for (var i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset) {\n        this.find[i].pos = this.currentPos;\n      }\n    }\n  }\n};\n\nParseContext.prototype.findInside = function findInside(parent) {\n  if (this.find) {\n    for (var i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        this.find[i].pos = this.currentPos;\n      }\n    }\n  }\n};\n\nParseContext.prototype.findAround = function findAround(parent, content, before) {\n  if (parent != content && this.find) {\n    for (var i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        var pos = content.compareDocumentPosition(this.find[i].node);\n\n        if (pos & (before ? 2 : 4)) {\n          this.find[i].pos = this.currentPos;\n        }\n      }\n    }\n  }\n};\n\nParseContext.prototype.findInText = function findInText(textNode) {\n  if (this.find) {\n    for (var i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode) {\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n      }\n    }\n  }\n}; // : (string) → bool\n// Determines whether the given [context\n// string](#ParseRule.context) matches this context.\n\n\nParseContext.prototype.matchesContext = function matchesContext(context) {\n  var this$1 = this;\n\n  if (context.indexOf(\"|\") > -1) {\n    return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n  }\n\n  var parts = context.split(\"/\");\n  var option = this.options.context;\n  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n\n  var match = function (i, depth) {\n    for (; i >= 0; i--) {\n      var part = parts[i];\n\n      if (part == \"\") {\n        if (i == parts.length - 1 || i == 0) {\n          continue;\n        }\n\n        for (; depth >= minDepth; depth--) {\n          if (match(i - 1, depth)) {\n            return true;\n          }\n        }\n\n        return false;\n      } else {\n        var next = depth > 0 || depth == 0 && useRoot ? this$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n\n        if (!next || next.name != part && next.groups.indexOf(part) == -1) {\n          return false;\n        }\n\n        depth--;\n      }\n    }\n\n    return true;\n  };\n\n  return match(parts.length - 1, this.open);\n};\n\nParseContext.prototype.textblockFromContext = function textblockFromContext() {\n  var $context = this.options.context;\n\n  if ($context) {\n    for (var d = $context.depth; d >= 0; d--) {\n      var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) {\n        return deflt;\n      }\n    }\n  }\n\n  for (var name in this.parser.schema.nodes) {\n    var type = this.parser.schema.nodes[name];\n\n    if (type.isTextblock && type.defaultAttrs) {\n      return type;\n    }\n  }\n};\n\nParseContext.prototype.addPendingMark = function addPendingMark(mark) {\n  var found = findSameMarkInSet(mark, this.top.pendingMarks);\n\n  if (found) {\n    this.top.stashMarks.push(found);\n  }\n\n  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n};\n\nParseContext.prototype.removePendingMark = function removePendingMark(mark, upto) {\n  for (var depth = this.open; depth >= 0; depth--) {\n    var level = this.nodes[depth];\n    var found = level.pendingMarks.lastIndexOf(mark);\n\n    if (found > -1) {\n      level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n    } else {\n      level.activeMarks = mark.removeFromSet(level.activeMarks);\n      var stashMark = level.popFromStashMark(mark);\n\n      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {\n        level.activeMarks = stashMark.addToSet(level.activeMarks);\n      }\n    }\n\n    if (level == upto) {\n      break;\n    }\n  }\n};\n\nObject.defineProperties(ParseContext.prototype, prototypeAccessors$6); // Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\n\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n} // Apply a CSS selector.\n\n\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n} // : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\n\n\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g,\n      m,\n      result = [];\n\n  while (m = re.exec(style)) {\n    result.push(m[1], m[2].trim());\n  }\n\n  return result;\n}\n\nfunction copy(obj) {\n  var copy = {};\n\n  for (var prop in obj) {\n    copy[prop] = obj[prop];\n  }\n\n  return copy;\n} // Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\n\n\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n\n  var loop = function (name) {\n    var parent = nodes[name];\n\n    if (!parent.allowsMarkType(markType)) {\n      return;\n    }\n\n    var seen = [],\n        scan = function (match) {\n      seen.push(match);\n\n      for (var i = 0; i < match.edgeCount; i++) {\n        var ref = match.edge(i);\n        var type = ref.type;\n        var next = ref.next;\n\n        if (type == nodeType) {\n          return true;\n        }\n\n        if (seen.indexOf(next) < 0 && scan(next)) {\n          return true;\n        }\n      }\n    };\n\n    if (scan(parent.contentMatch)) {\n      return {\n        v: true\n      };\n    }\n  };\n\n  for (var name in nodes) {\n    var returned = loop(name);\n    if (returned) return returned.v;\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (var i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) {\n      return set[i];\n    }\n  }\n} // DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\n\n\nvar DOMSerializer = function DOMSerializer(nodes, marks) {\n  // :: Object<(node: Node) → DOMOutputSpec>\n  // The node serialization functions.\n  this.nodes = nodes || {}; // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n  // The mark serialization functions.\n\n  this.marks = marks || {};\n}; // :: (Fragment, ?Object) → dom.DocumentFragment\n// Serialize the content of this fragment to a DOM fragment. When\n// not in the browser, the `document` option, containing a DOM\n// document, should be passed so that the serializer can create\n// nodes.\n\n\nDOMSerializer.prototype.serializeFragment = function serializeFragment(fragment, options, target) {\n  var this$1 = this;\n  if (options === void 0) options = {};\n\n  if (!target) {\n    target = doc(options).createDocumentFragment();\n  }\n\n  var top = target,\n      active = null;\n  fragment.forEach(function (node) {\n    if (active || node.marks.length) {\n      if (!active) {\n        active = [];\n      }\n\n      var keep = 0,\n          rendered = 0;\n\n      while (keep < active.length && rendered < node.marks.length) {\n        var next = node.marks[rendered];\n\n        if (!this$1.marks[next.type.name]) {\n          rendered++;\n          continue;\n        }\n\n        if (!next.eq(active[keep]) || next.type.spec.spanning === false) {\n          break;\n        }\n\n        keep += 2;\n        rendered++;\n      }\n\n      while (keep < active.length) {\n        top = active.pop();\n        active.pop();\n      }\n\n      while (rendered < node.marks.length) {\n        var add = node.marks[rendered++];\n        var markDOM = this$1.serializeMark(add, node.isInline, options);\n\n        if (markDOM) {\n          active.push(add, top);\n          top.appendChild(markDOM.dom);\n          top = markDOM.contentDOM || markDOM.dom;\n        }\n      }\n    }\n\n    top.appendChild(this$1.serializeNodeInner(node, options));\n  });\n  return target;\n};\n\nDOMSerializer.prototype.serializeNodeInner = function serializeNodeInner(node, options) {\n  if (options === void 0) options = {};\n  var ref = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n  var dom = ref.dom;\n  var contentDOM = ref.contentDOM;\n\n  if (contentDOM) {\n    if (node.isLeaf) {\n      throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n    }\n\n    if (options.onContent) {\n      options.onContent(node, contentDOM, options);\n    } else {\n      this.serializeFragment(node.content, options, contentDOM);\n    }\n  }\n\n  return dom;\n}; // :: (Node, ?Object) → dom.Node\n// Serialize this node to a DOM node. This can be useful when you\n// need to serialize a part of a document, as opposed to the whole\n// document. To serialize a whole document, use\n// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n// its [content](#model.Node.content).\n\n\nDOMSerializer.prototype.serializeNode = function serializeNode(node, options) {\n  if (options === void 0) options = {};\n  var dom = this.serializeNodeInner(node, options);\n\n  for (var i = node.marks.length - 1; i >= 0; i--) {\n    var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n\n    if (wrap) {\n      (wrap.contentDOM || wrap.dom).appendChild(dom);\n      dom = wrap.dom;\n    }\n  }\n\n  return dom;\n};\n\nDOMSerializer.prototype.serializeMark = function serializeMark(mark, inline, options) {\n  if (options === void 0) options = {};\n  var toDOM = this.marks[mark.type.name];\n  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));\n}; // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n// the spec has a hole (zero) in it, `contentDOM` will point at the\n// node with the hole.\n\n\nDOMSerializer.renderSpec = function renderSpec(doc, structure, xmlNS) {\n  if (xmlNS === void 0) xmlNS = null;\n\n  if (typeof structure == \"string\") {\n    return {\n      dom: doc.createTextNode(structure)\n    };\n  }\n\n  if (structure.nodeType != null) {\n    return {\n      dom: structure\n    };\n  }\n\n  if (structure.dom && structure.dom.nodeType != null) {\n    return structure;\n  }\n\n  var tagName = structure[0],\n      space = tagName.indexOf(\" \");\n\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n\n  var contentDOM = null,\n      dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n  var attrs = structure[1],\n      start = 1;\n\n  if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n\n    for (var name in attrs) {\n      if (attrs[name] != null) {\n        var space$1 = name.indexOf(\" \");\n\n        if (space$1 > 0) {\n          dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);\n        } else {\n          dom.setAttribute(name, attrs[name]);\n        }\n      }\n    }\n  }\n\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start) {\n        throw new RangeError(\"Content hole must be the only child of its parent node\");\n      }\n\n      return {\n        dom: dom,\n        contentDOM: dom\n      };\n    } else {\n      var ref = DOMSerializer.renderSpec(doc, child, xmlNS);\n      var inner = ref.dom;\n      var innerContent = ref.contentDOM;\n      dom.appendChild(inner);\n\n      if (innerContent) {\n        if (contentDOM) {\n          throw new RangeError(\"Multiple content holes\");\n        }\n\n        contentDOM = innerContent;\n      }\n    }\n  }\n\n  return {\n    dom: dom,\n    contentDOM: contentDOM\n  };\n}; // :: (Schema) → DOMSerializer\n// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n// properties in a schema's node and mark specs.\n\n\nDOMSerializer.fromSchema = function fromSchema(schema) {\n  return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n}; // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n// Gather the serializers in a schema's node specs into an object.\n// This can be useful as a base to build a custom serializer from.\n\n\nDOMSerializer.nodesFromSchema = function nodesFromSchema(schema) {\n  var result = gatherToDOM(schema.nodes);\n\n  if (!result.text) {\n    result.text = function (node) {\n      return node.text;\n    };\n  }\n\n  return result;\n}; // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n// Gather the serializers in a schema's mark specs into an object.\n\n\nDOMSerializer.marksFromSchema = function marksFromSchema(schema) {\n  return gatherToDOM(schema.marks);\n};\n\nfunction gatherToDOM(obj) {\n  var result = {};\n\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n\n    if (toDOM) {\n      result[name] = toDOM;\n    }\n  }\n\n  return result;\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document;\n}\n\nexport { ContentMatch, DOMParser, DOMSerializer, Fragment, Mark, MarkType, Node, NodeRange, NodeType, ReplaceError, ResolvedPos, Schema, Slice };","map":{"version":3,"mappings":";;AAAO,SAASA,aAAT,CAAuBC,CAAvB,EAA0BC,CAA1B,EAA6BC,GAA7B,EAAkC;AACvC,OAAKC,IAAIC,CAAC,GAAG,CAAb,GAAiBA,CAAC,EAAlB,EAAsB;AACpB,QAAIA,CAAC,IAAIJ,CAAC,CAACK,UAAP,IAAqBD,CAAC,IAAIH,CAAC,CAACI,UAAhC,EACJ;AAAM,aAAOL,CAAC,CAACK,UAAF,IAAgBJ,CAAC,CAACI,UAAlB,GAA+B,IAA/B,GAAsCH,GAA7C;AAAgD;;AAElDC,QAAIG,MAAM,GAAGN,CAAC,CAACO,KAAF,CAAQH,CAAR,CAAbD;AAAAA,QAAyBK,MAAM,GAAGP,CAAC,CAACM,KAAF,CAAQH,CAAR,CAAlCD;;AACA,QAAIG,MAAM,IAAIE,MAAd,EAAsB;AAAEN,SAAG,IAAII,MAAM,CAACG,QAAd;AAAwB;AAAU;;AAE1D,QAAI,CAACH,MAAM,CAACI,UAAP,CAAkBF,MAAlB,CAAL,EAA8B;AAAE,aAAON,GAAP;AAAU;;AAE1C,QAAII,MAAM,CAACK,MAAP,IAAiBL,MAAM,CAACM,IAAP,IAAeJ,MAAM,CAACI,IAA3C,EAAiD;AAC/C,WAAKT,IAAIU,CAAC,GAAG,CAAb,EAAgBP,MAAM,CAACM,IAAP,CAAYC,CAAZ,KAAkBL,MAAM,CAACI,IAAP,CAAYC,CAAZ,CAAlC,EAAkDA,CAAC,EAAnD,EACN;AAAQX,WAAG;AAAE;;AACP,aAAOA,GAAP;AACD;;AACD,QAAII,MAAM,CAACQ,OAAP,CAAeC,IAAf,IAAuBP,MAAM,CAACM,OAAP,CAAeC,IAA1C,EAAgD;AAC9CZ,UAAIa,KAAK,GAAGjB,aAAa,CAACO,MAAM,CAACQ,OAAR,EAAiBN,MAAM,CAACM,OAAxB,EAAiCZ,GAAG,GAAG,CAAvC,CAAzBC;;AACA,UAAIa,KAAK,IAAI,IAAb,EAAiB;AAAE,eAAOA,KAAP;AAAY;AAChC;;AACDd,OAAG,IAAII,MAAM,CAACG,QAAd;AACD;AACF;;AAEM,SAASQ,WAAT,CAAqBjB,CAArB,EAAwBC,CAAxB,EAA2BiB,IAA3B,EAAiCC,IAAjC,EAAuC;AAC5C,OAAKhB,IAAIiB,EAAE,GAAGpB,CAAC,CAACK,UAAXF,EAAuBkB,EAAE,GAAGpB,CAAC,CAACI,UAAnC,IAAiD;AAC/C,QAAIe,EAAE,IAAI,CAAN,IAAWC,EAAE,IAAI,CAArB,EACJ;AAAM,aAAOD,EAAE,IAAIC,EAAN,GAAW,IAAX,GAAkB;AAACrB,SAAC,EAAEkB,IAAJ;AAAUjB,SAAC,EAAEkB;AAAb,OAAzB;AAA2C;;AAE7ChB,QAAIG,MAAM,GAAGN,CAAC,CAACO,KAAF,CAAQ,EAAEa,EAAV,CAAbjB;AAAAA,QAA4BK,MAAM,GAAGP,CAAC,CAACM,KAAF,CAAQ,EAAEc,EAAV,CAArClB;AAAAA,QAAoDY,IAAI,GAAGT,MAAM,CAACG,QAAlEN;;AACA,QAAIG,MAAM,IAAIE,MAAd,EAAsB;AACpBU,UAAI,IAAIH,IAAR;AAAcI,UAAI,IAAIJ,IAAR;AACd;AACD;;AAED,QAAI,CAACT,MAAM,CAACI,UAAP,CAAkBF,MAAlB,CAAL,EAA8B;AAAE,aAAO;AAACR,SAAC,EAAEkB,IAAJ;AAAUjB,SAAC,EAAEkB;AAAb,OAAP;AAAyB;;AAEzD,QAAIb,MAAM,CAACK,MAAP,IAAiBL,MAAM,CAACM,IAAP,IAAeJ,MAAM,CAACI,IAA3C,EAAiD;AAC/CT,UAAImB,IAAI,GAAG,CAAXnB;AAAAA,UAAcoB,OAAO,GAAGC,IAAI,CAACC,GAAL,CAASnB,MAAM,CAACM,IAAP,CAAYc,MAArB,EAA6BlB,MAAM,CAACI,IAAP,CAAYc,MAAzC,CAAxBvB;;AACA,aAAOmB,IAAI,GAAGC,OAAP,IAAkBjB,MAAM,CAACM,IAAP,CAAYN,MAAM,CAACM,IAAP,CAAYc,MAAZ,GAAqBJ,IAArB,GAA4B,CAAxC,KAA8Cd,MAAM,CAACI,IAAP,CAAYJ,MAAM,CAACI,IAAP,CAAYc,MAAZ,GAAqBJ,IAArB,GAA4B,CAAxC,CAAvE,EAAmH;AACjHA,YAAI;AAAIJ,YAAI;AAAIC,YAAI;AACrB;;AACD,aAAO;AAACnB,SAAC,EAAEkB,IAAJ;AAAUjB,SAAC,EAAEkB;AAAb,OAAP;AACD;;AACD,QAAIb,MAAM,CAACQ,OAAP,CAAeC,IAAf,IAAuBP,MAAM,CAACM,OAAP,CAAeC,IAA1C,EAAgD;AAC9CZ,UAAIa,KAAK,GAAGC,WAAW,CAACX,MAAM,CAACQ,OAAR,EAAiBN,MAAM,CAACM,OAAxB,EAAiCI,IAAI,GAAG,CAAxC,EAA2CC,IAAI,GAAG,CAAlD,CAAvBhB;;AACA,UAAIa,KAAJ,EAAS;AAAE,eAAOA,KAAP;AAAY;AACxB;;AACDE,QAAI,IAAIH,IAAR;AAAcI,QAAI,IAAIJ,IAAR;AACf;AACH,C,CC/CA;AACA;AACA;AACA;AACA;;;IACaY,QAAQ,GACnB,kBAAYb,OAAZ,EAAqBC,IAArB,EAA2B;AACzB,OAAKD,OAAL,GAAeA,OAAf,CADyB,CAE7B;AACA;AACA;;AACI,OAAKC,IAAL,GAAYA,IAAI,IAAI,CAApB;;AACA,MAAIA,IAAI,IAAI,IAAZ,EAAgB;AAAE,SAAKZ,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,OAAO,CAACY,MAA5B,EAAoCtB,CAAC,EAArC,EACtB;AAAM,WAAKW,IAAL,IAAaD,OAAO,CAACV,CAAD,CAAP,CAAWK,QAAxB;AAAwB;AAAQ;AACpC;;;;;;;;;;;;GAEA;AACA;AACA;AACA;;mBACAmB,qCAAaC,IAAb,EAAmBC,EAAnB,EAAuBC,CAAvB,EAA0BC,SAA1B,EAAyCC,MAAzC,EAAiD;qCAAd,GAAG;;AACpC,OAAK9B,IAAIC,CAAC,GAAG,CAARD,EAAWD,GAAG,GAAG,CAAtB,EAAyBA,GAAG,GAAG4B,EAA/B,EAAmC1B,CAAC,EAApC,EAAwC;AACtCD,QAAII,KAAK,GAAG,KAAKO,OAAL,CAAaV,CAAb,CAAZD;AAAAA,QAA6B+B,GAAG,GAAGhC,GAAG,GAAGK,KAAK,CAACE,QAA/CN;;AACA,QAAI+B,GAAG,GAAGL,IAAN,IAAcE,CAAC,CAACxB,KAAD,EAAQyB,SAAS,GAAG9B,GAApB,EAAyB+B,MAAzB,EAAiC7B,CAAjC,CAAD,KAAyC,KAAvD,IAAgEG,KAAK,CAACO,OAAN,CAAcC,IAAlF,EAAwF;AACtFZ,UAAIgC,KAAK,GAAGjC,GAAG,GAAG,CAAlBC;AACAI,WAAK,CAACqB,YAAN,CAAmBJ,IAAI,CAACY,GAAL,CAAS,CAAT,EAAYP,IAAI,GAAGM,KAAnB,CAAnB,EACmBX,IAAI,CAACC,GAAL,CAASlB,KAAK,CAACO,OAAN,CAAcC,IAAvB,EAA6Be,EAAE,GAAGK,KAAlC,CADnB,EAEmBJ,CAFnB,EAEsBC,SAAS,GAAGG,KAFlC;AAGD;;AACDjC,OAAG,GAAGgC,GAAN;AACD;AACH,E,CAEA;AACA;AACA;;;mBACAG,mCAAYN,CAAZ,EAAe;AACb,OAAKH,YAAL,CAAkB,CAAlB,EAAqB,KAAKb,IAA1B,EAAgCgB,CAAhC;AACF,E,CAEA;AACA;AACA;;;mBACAO,mCAAYT,IAAZ,EAAkBC,EAAlB,EAAsBS,cAAtB,EAAsCC,QAAtC,EAAgD;AAC9CrC,MAAIS,IAAI,GAAG,EAAXT;AAAAA,MAAesC,SAAS,GAAG,IAA3BtC;AACA,OAAKyB,YAAL,CAAkBC,IAAlB,EAAwBC,EAAxB,EAA0B,UAAGY,IAAH,EAASxC,GAAT,EAAiB;AACzC,QAAIwC,IAAI,CAAC/B,MAAT,EAAiB;AACfC,UAAI,IAAI8B,IAAI,CAAC9B,IAAL,CAAU+B,KAAV,CAAgBnB,IAAI,CAACY,GAAL,CAASP,IAAT,EAAe3B,GAAf,IAAsBA,GAAtC,EAA2C4B,EAAE,GAAG5B,GAAhD,CAAR;AACAuC,eAAS,GAAG,CAACF,cAAb;AACD,KAHD,MAGO,IAAIG,IAAI,CAACE,MAAL,IAAeJ,QAAnB,EAA6B;AAClC5B,UAAI,IAAI,OAAO4B,QAAP,KAAoB,UAApB,GAAiCA,QAAQ,CAACE,IAAD,CAAzC,GAAiDF,QAAzD;AACAC,eAAS,GAAG,CAACF,cAAb;AACD,KAHM,MAGA,IAAI,CAACE,SAAD,IAAcC,IAAI,CAACG,OAAvB,EAAgC;AACrCjC,UAAI,IAAI2B,cAAR;AACAE,eAAS,GAAG,IAAZ;AACD;AACF,GAXD,EAWG,CAXH;AAYA,SAAO7B,IAAP;AACF,E,CAEA;AACA;AACA;;;mBACAkC,yBAAOC,KAAP,EAAc;AACZ,MAAI,CAACA,KAAK,CAAChC,IAAX,EAAe;AAAE,WAAO,IAAP;AAAW;;AAC5B,MAAI,CAAC,KAAKA,IAAV,EAAc;AAAE,WAAOgC,KAAP;AAAY;;AAC5B5C,MAAI6C,IAAI,GAAG,KAAKC,SAAhB9C;AAAAA,MAA2B+C,KAAK,GAAGH,KAAK,CAACI,UAAzChD;AAAAA,MAAqDW,OAAO,GAAG,KAAKA,OAAL,CAAa6B,KAAb,EAA/DxC;AAAAA,MAAqFC,CAAC,GAAG,CAAzFD;;AACA,MAAI6C,IAAI,CAACrC,MAAL,IAAeqC,IAAI,CAACtC,UAAL,CAAgBwC,KAAhB,CAAnB,EAA2C;AACzCpC,WAAO,CAACA,OAAO,CAACY,MAAR,GAAiB,CAAlB,CAAP,GAA8BsB,IAAI,CAACI,QAAL,CAAcJ,IAAI,CAACpC,IAAL,GAAYsC,KAAK,CAACtC,IAAhC,CAA9B;AACAR,KAAC,GAAG,CAAJ;AACD;;AACD,SAAOA,CAAC,GAAG2C,KAAK,CAACjC,OAAN,CAAcY,MAAzB,EAAiCtB,CAAC,EAAlC,EAAoC;AAAEU,WAAO,CAACuC,IAAR,CAAaN,KAAK,CAACjC,OAAN,CAAcV,CAAd,CAAb;AAA8B;;AACpE,SAAO,IAAIuB,QAAJ,CAAab,OAAb,EAAsB,KAAKC,IAAL,GAAYgC,KAAK,CAAChC,IAAxC,CAAP;AACF,E,CAEA;AACA;;;mBACAuC,mBAAIzB,IAAJ,EAAUC,EAAV,EAAc;AACZ,MAAIA,EAAE,IAAI,IAAV,EAAc;AAAEA,MAAE,GAAG,KAAKf,IAAV;AAAc;;AAC9B,MAAIc,IAAI,IAAI,CAAR,IAAaC,EAAE,IAAI,KAAKf,IAA5B,EAAgC;AAAE,WAAO,IAAP;AAAW;;AAC7CZ,MAAIoD,MAAM,GAAG,EAAbpD;AAAAA,MAAiBY,IAAI,GAAG,CAAxBZ;;AACA,MAAI2B,EAAE,GAAGD,IAAT,EAAa;AAAE,SAAK1B,IAAIC,CAAC,GAAG,CAARD,EAAWD,GAAG,GAAG,CAAtB,EAAyBA,GAAG,GAAG4B,EAA/B,EAAmC1B,CAAC,EAApC,EAAwC;AACrDD,UAAII,KAAK,GAAG,KAAKO,OAAL,CAAaV,CAAb,CAAZD;AAAAA,UAA6B+B,GAAG,GAAGhC,GAAG,GAAGK,KAAK,CAACE,QAA/CN;;AACA,UAAI+B,GAAG,GAAGL,IAAV,EAAgB;AACd,YAAI3B,GAAG,GAAG2B,IAAN,IAAcK,GAAG,GAAGJ,EAAxB,EAA4B;AAC1B,cAAIvB,KAAK,CAACI,MAAV,EACV;AAAYJ,iBAAK,GAAGA,KAAK,CAAC+C,GAAN,CAAU9B,IAAI,CAACY,GAAL,CAAS,CAAT,EAAYP,IAAI,GAAG3B,GAAnB,CAAV,EAAmCsB,IAAI,CAACC,GAAL,CAASlB,KAAK,CAACK,IAAN,CAAWc,MAApB,EAA4BI,EAAE,GAAG5B,GAAjC,CAAnC,CAAR;AAAiF,WADnF,MAGV;AAAYK,iBAAK,GAAGA,KAAK,CAAC+C,GAAN,CAAU9B,IAAI,CAACY,GAAL,CAAS,CAAT,EAAYP,IAAI,GAAG3B,GAAP,GAAa,CAAzB,CAAV,EAAuCsB,IAAI,CAACC,GAAL,CAASlB,KAAK,CAACO,OAAN,CAAcC,IAAvB,EAA6Be,EAAE,GAAG5B,GAAL,GAAW,CAAxC,CAAvC,CAAR;AAA0F;AAC7F;;AACDqD,cAAM,CAACF,IAAP,CAAY9C,KAAZ;AACAQ,YAAI,IAAIR,KAAK,CAACE,QAAd;AACD;;AACDP,SAAG,GAAGgC,GAAN;AACN;AAAK;;AACD,SAAO,IAAIP,QAAJ,CAAa4B,MAAb,EAAqBxC,IAArB,CAAP;AACF;;mBAEAyC,iCAAW3B,IAAX,EAAiBC,EAAjB,EAAqB;AACnB,MAAID,IAAI,IAAIC,EAAZ,EAAc;AAAE,WAAOH,QAAQ,CAAC8B,KAAhB;AAAqB;;AACrC,MAAI5B,IAAI,IAAI,CAAR,IAAaC,EAAE,IAAI,KAAKhB,OAAL,CAAaY,MAApC,EAA0C;AAAE,WAAO,IAAP;AAAW;;AACvD,SAAO,IAAIC,QAAJ,CAAa,KAAKb,OAAL,CAAa6B,KAAb,CAAmBd,IAAnB,EAAyBC,EAAzB,CAAb,CAAP;AACF,E,CAEA;AACA;AACA;;;mBACA4B,qCAAaC,KAAb,EAAoBjB,IAApB,EAA0B;AACxBvC,MAAIyD,OAAO,GAAG,KAAK9C,OAAL,CAAa6C,KAAb,CAAdxD;;AACA,MAAIyD,OAAO,IAAIlB,IAAf,EAAmB;AAAE,WAAO,IAAP;AAAW;;AAChCvC,MAAI0D,IAAI,GAAG,KAAK/C,OAAL,CAAa6B,KAAb,EAAXxC;AACAA,MAAIY,IAAI,GAAG,KAAKA,IAAL,GAAY2B,IAAI,CAACjC,QAAjB,GAA4BmD,OAAO,CAACnD,QAA/CN;AACA0D,MAAI,CAACF,KAAD,CAAJ,GAAcjB,IAAd;AACA,SAAO,IAAIf,QAAJ,CAAakC,IAAb,EAAmB9C,IAAnB,CAAP;AACF,E,CAEA;AACA;AACA;;;mBACA+C,iCAAWpB,IAAX,EAAiB;AACf,SAAO,IAAIf,QAAJ,CAAa,CAACe,IAAD,EAAOqB,MAAP,CAAc,KAAKjD,OAAnB,CAAb,EAA0C,KAAKC,IAAL,GAAY2B,IAAI,CAACjC,QAA3D,CAAP;AACF,E,CAEA;AACA;AACA;;;mBACAuD,6BAAStB,IAAT,EAAe;AACb,SAAO,IAAIf,QAAJ,CAAa,KAAKb,OAAL,CAAaiD,MAAb,CAAoBrB,IAApB,CAAb,EAAwC,KAAK3B,IAAL,GAAY2B,IAAI,CAACjC,QAAzD,CAAP;AACF,E,CAEA;AACA;;;mBACAwD,iBAAGlB,KAAH,EAAU;AACR,MAAI,KAAKjC,OAAL,CAAaY,MAAb,IAAuBqB,KAAK,CAACjC,OAAN,CAAcY,MAAzC,EAA+C;AAAE,WAAO,KAAP;AAAY;;AAC7D,OAAKvB,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKU,OAAL,CAAaY,MAAjC,EAAyCtB,CAAC,EAA1C,EACJ;AAAM,QAAI,CAAC,KAAKU,OAAL,CAAaV,CAAb,EAAgB6D,EAAhB,CAAmBlB,KAAK,CAACjC,OAAN,CAAcV,CAAd,CAAnB,CAAL,EAAyC;AAAE,aAAO,KAAP;AAAO;AAAK;;AACzD,SAAO,IAAP;AACF,E,CAEA;AACA;;;AACA8D,mBAAIf,UAAJ,CAAIgB,GAAJ,GAAI,YAAa;AAAE,SAAO,KAAKrD,OAAL,CAAaY,MAAb,GAAsB,KAAKZ,OAAL,CAAa,CAAb,CAAtB,GAAwC,IAA/C;AAAmD,CAAtE,C,CAEA;AACA;;;AACAoD,mBAAIjB,SAAJ,CAAIkB,GAAJ,GAAI,YAAY;AAAE,SAAO,KAAKrD,OAAL,CAAaY,MAAb,GAAsB,KAAKZ,OAAL,CAAa,KAAKA,OAAL,CAAaY,MAAb,GAAsB,CAAnC,CAAtB,GAA8D,IAArE;AAAyE,CAA3F,C,CAEA;AACA;;;AACAwC,mBAAI7D,UAAJ,CAAI8D,GAAJ,GAAI,YAAa;AAAE,SAAO,KAAKrD,OAAL,CAAaY,MAApB;AAA0B,CAA7C,C,CAEA;AACA;AACA;;;mBACAnB,uBAAMoD,KAAN,EAAa;AACXxD,MAAIiE,KAAK,GAAG,KAAKtD,OAAL,CAAa6C,KAAb,CAAZxD;;AACA,MAAI,CAACiE,KAAL,EAAU;AAAE,UAAM,IAAIC,UAAJ,CAAe,WAAWV,KAAX,GAAmB,oBAAnB,GAA0C,IAAzD,CAAN;AAAoE;;AAChF,SAAOS,KAAP;AACF,E,CAEA;AACA;;;mBACAE,iCAAWX,KAAX,EAAkB;AAChB,SAAO,KAAK7C,OAAL,CAAa6C,KAAb,CAAP;AACF,E,CAEA;AACA;AACA;;;mBACAY,2BAAQxC,CAAR,EAAW;AACT,OAAK5B,IAAIC,CAAC,GAAG,CAARD,EAAWqE,CAAC,GAAG,CAApB,EAAuBpE,CAAC,GAAG,KAAKU,OAAL,CAAaY,MAAxC,EAAgDtB,CAAC,EAAjD,EAAqD;AACnDD,QAAII,KAAK,GAAG,KAAKO,OAAL,CAAaV,CAAb,CAAZD;AACA4B,KAAC,CAACxB,KAAD,EAAQiE,CAAR,EAAWpE,CAAX,CAAD;AACAoE,KAAC,IAAIjE,KAAK,CAACE,QAAX;AACD;AACH,E,CAEA;AACA;AACA;;;mBACAV,yCAAcgD,KAAd,EAAqB7C,GAArB,EAA8B;yBAAN,GAAG;AACzB,SAAOH,aAAa,CAAC,IAAD,EAAOgD,KAAP,EAAc7C,GAAd,CAApB;AACF,E,CAEA;AACA;AACA;AACA;AACA;;;mBACAe,qCAAY8B,KAAZ,EAAmB7C,GAAnB,EAAoCuE,QAApC,EAA2D;yBAArC,GAAG,KAAK1D;mCAAc,GAAGgC,KAAK,CAAChC;AACnD,SAAOE,WAAW,CAAC,IAAD,EAAO8B,KAAP,EAAc7C,GAAd,EAAmBuE,QAAnB,CAAlB;AACF,E,CAEA;AACA;AACA;AACA;;;mBACAC,+BAAUxE,GAAV,EAAeyE,KAAf,EAA2B;6BAAP,GAAG,CAAC;;AACtB,MAAIzE,GAAG,IAAI,CAAX,EAAY;AAAE,WAAO0E,QAAQ,CAAC,CAAD,EAAI1E,GAAJ,CAAf;AAAuB;;AACrC,MAAIA,GAAG,IAAI,KAAKa,IAAhB,EAAoB;AAAE,WAAO6D,QAAQ,CAAC,KAAK9D,OAAL,CAAaY,MAAd,EAAsBxB,GAAtB,CAAf;AAAyC;;AAC/D,MAAIA,GAAG,GAAG,KAAKa,IAAX,IAAmBb,GAAG,GAAG,CAA7B,EAA8B;AAAE,UAAM,IAAImE,UAAJ,CAAc,cAAanE,GAAb,GAAgB,wBAAhB,GAAyC,IAAzC,GAA6C,GAA3D,CAAN;AAAqE;;AACrG,OAAKC,IAAIC,CAAC,GAAG,CAARD,EAAW0E,MAAM,GAAG,CAAzB,GAA6BzE,CAAC,EAA9B,EAAkC;AAChCD,QAAI2E,GAAG,GAAG,KAAKvE,KAAL,CAAWH,CAAX,CAAVD;AAAAA,QAAyB+B,GAAG,GAAG2C,MAAM,GAAGC,GAAG,CAACrE,QAA5CN;;AACA,QAAI+B,GAAG,IAAIhC,GAAX,EAAgB;AACd,UAAIgC,GAAG,IAAIhC,GAAP,IAAcyE,KAAK,GAAG,CAA1B,EAA2B;AAAE,eAAOC,QAAQ,CAACxE,CAAC,GAAG,CAAL,EAAQ8B,GAAR,CAAf;AAA2B;;AACxD,aAAO0C,QAAQ,CAACxE,CAAD,EAAIyE,MAAJ,CAAf;AACD;;AACDA,UAAM,GAAG3C,GAAT;AACD;AACH,E,CAEA;AACA;;;mBACA6C,+BAAW;AAAE,SAAO,MAAM,KAAKC,aAAL,EAAN,GAA6B,GAApC;AAAuC;;mBAEpDA,yCAAgB;AAAE,SAAO,KAAKlE,OAAL,CAAamE,IAAb,CAAkB,IAAlB,CAAP;AAA8B,E,CAEhD;AACA;;;mBACAC,2BAAS;AACP,SAAO,KAAKpE,OAAL,CAAaY,MAAb,GAAsB,KAAKZ,OAAL,CAAaqE,GAAb,CAAgB,UAACC,CAAD,EAAC;AAAA,WAAKA,CAAC,CAACF,MAAF,EAAL;AAAe,GAAhC,CAAtB,GAA0D,IAAjE;AACF,E,CAEA;AACA;;;AACAvD,SAAO0D,QAAP,GAAO,kBAASC,MAAT,EAAiBC,KAAjB,EAAwB;AAC7B,MAAI,CAACA,KAAL,EAAU;AAAE,WAAO5D,QAAQ,CAAC8B,KAAhB;AAAqB;;AACjC,MAAI,CAAC+B,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAL,EAAyB;AAAE,UAAM,IAAIlB,UAAJ,CAAe,qCAAf,CAAN;AAA2D;;AACtF,SAAO,IAAI1C,QAAJ,CAAa4D,KAAK,CAACJ,GAAN,CAAUG,MAAM,CAACI,YAAjB,CAAb,CAAP;AACF,CAJA,C,CAMA;AACA;AACA;;;AACA/D,SAAOgE,SAAP,GAAO,mBAAUC,KAAV,EAAiB;AACtB,MAAI,CAACA,KAAK,CAAClE,MAAX,EAAiB;AAAE,WAAOC,QAAQ,CAAC8B,KAAhB;AAAqB;;AACxCtD,MAAI0F,MAAJ1F;AAAAA,MAAYY,IAAI,GAAG,CAAnBZ;;AACA,OAAKA,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwF,KAAK,CAAClE,MAA1B,EAAkCtB,CAAC,EAAnC,EAAuC;AACrCD,QAAIuC,IAAI,GAAGkD,KAAK,CAACxF,CAAD,CAAhBD;AACAY,QAAI,IAAI2B,IAAI,CAACjC,QAAb;;AACA,QAAIL,CAAC,IAAIsC,IAAI,CAAC/B,MAAV,IAAoBiF,KAAK,CAACxF,CAAC,GAAG,CAAL,CAAL,CAAaM,UAAb,CAAwBgC,IAAxB,CAAxB,EAAuD;AACrD,UAAI,CAACmD,MAAL,EAAW;AAAEA,cAAM,GAAGD,KAAK,CAACjD,KAAN,CAAY,CAAZ,EAAevC,CAAf,CAAT;AAA0B;;AACvCyF,YAAM,CAACA,MAAM,CAACnE,MAAP,GAAgB,CAAjB,CAAN,GAA4BgB,IAAI,CAACU,QAAL,CAAcyC,MAAM,CAACA,MAAM,CAACnE,MAAP,GAAgB,CAAjB,CAAN,CAA0Bd,IAA1B,GAAiC8B,IAAI,CAAC9B,IAApD,CAA5B;AACD,KAHD,MAGO,IAAIiF,MAAJ,EAAY;AACjBA,YAAM,CAACxC,IAAP,CAAYX,IAAZ;AACD;AACF;;AACD,SAAO,IAAIf,QAAJ,CAAakE,MAAM,IAAID,KAAvB,EAA8B7E,IAA9B,CAAP;AACF,CAdA,C,CAgBA;AACA;AACA;AACA;AACA;;;AACAY,SAAOE,IAAP,GAAO,cAAKiE,KAAL,EAAY;AACjB,MAAI,CAACA,KAAL,EAAU;AAAE,WAAOnE,QAAQ,CAAC8B,KAAhB;AAAqB;;AACjC,MAAIqC,KAAK,YAAYnE,QAArB,EAA6B;AAAE,WAAOmE,KAAP;AAAY;;AAC3C,MAAIN,KAAK,CAACC,OAAN,CAAcK,KAAd,CAAJ,EAAwB;AAAE,WAAO,KAAKH,SAAL,CAAeG,KAAf,CAAP;AAA4B;;AACtD,MAAIA,KAAK,CAACC,KAAV,EAAe;AAAE,WAAO,IAAIpE,QAAJ,CAAa,CAACmE,KAAD,CAAb,EAAsBA,KAAK,CAACrF,QAA5B,CAAP;AAA4C;;AAC7D,QAAM,IAAI4D,UAAJ,CAAe,qBAAqByB,KAArB,GAA6B,gBAA7B,IACCA,KAAK,CAAClE,YAAN,GAAqB,kEAArB,GAA0F,EAD3F,CAAf,CAAN;AAEF,CAPA;;;AAUFoE,IAAM5B,KAAK,GAAG;AAACT,OAAK,EAAE,CAAR;AAAWsC,QAAM,EAAE;AAAnB,CAAdD;;AACA,SAASpB,QAAT,CAAkBjB,KAAlB,EAAyBsC,MAAzB,EAAiC;AAC/B7B,OAAK,CAACT,KAAN,GAAcA,KAAd;AACAS,OAAK,CAAC6B,MAAN,GAAeA,MAAf;AACA,SAAO7B,KAAP;AACD,C,CAED;AACA;AACA;AACA;;;AACAzC,QAAQ,CAAC8B,KAAT,GAAiB,IAAI9B,QAAJ,CAAa,EAAb,EAAiB,CAAjB,CAAjB;;ACtRO,SAASuE,WAAT,CAAqBlG,CAArB,EAAwBC,CAAxB,EAA2B;AAChC,MAAID,CAAC,KAAKC,CAAV,EAAW;AAAE,WAAO,IAAP;AAAW;;AACxB,MAAI,EAAED,CAAC,IAAI,OAAOA,CAAP,IAAY,QAAnB,KACA,EAAEC,CAAC,IAAI,OAAOA,CAAP,IAAY,QAAnB,CADJ,EACgC;AAAE,WAAO,KAAP;AAAY;;AAC9CE,MAAIyF,KAAK,GAAGJ,KAAK,CAACC,OAAN,CAAczF,CAAd,CAAZG;;AACA,MAAIqF,KAAK,CAACC,OAAN,CAAcxF,CAAd,KAAoB2F,KAAxB,EAA6B;AAAE,WAAO,KAAP;AAAY;;AAC3C,MAAIA,KAAJ,EAAW;AACT,QAAI5F,CAAC,CAAC0B,MAAF,IAAYzB,CAAC,CAACyB,MAAlB,EAAwB;AAAE,aAAO,KAAP;AAAY;;AACtC,SAAKvB,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAAC,CAAC0B,MAAtB,EAA8BtB,CAAC,EAA/B,EAAiC;AAAE,UAAI,CAAC8F,WAAW,CAAClG,CAAC,CAACI,CAAD,CAAF,EAAOH,CAAC,CAACG,CAAD,CAAR,CAAhB,EAA4B;AAAE,eAAO,KAAP;AAAO;AAAK;AAC9E,GAHD,MAGO;AACL,SAAKD,IAAIqE,CAAT,IAAcxE,CAAd,EAAe;AAAE,UAAI,EAAEwE,CAAC,IAAIvE,CAAP,KAAa,CAACiG,WAAW,CAAClG,CAAC,CAACwE,CAAD,CAAF,EAAOvE,CAAC,CAACuE,CAAD,CAAR,CAA7B,EAAyC;AAAE,eAAO,KAAP;AAAO;AAAK;;AACxE,SAAKrE,IAAIqE,GAAT,IAAcvE,CAAd,EAAe;AAAE,UAAI,EAAEuE,GAAC,IAAIxE,CAAP,CAAJ,EAAa;AAAE,eAAO,KAAP;AAAO;AAAK;AAC7C;;AACD,SAAO,IAAP;AACF,C,CCZA;AACA;AACA;AACA;AACA;AACA;;;IACamG,IAAI,GACf,cAAYC,IAAZ,EAAkBL,KAAlB,EAAyB;AAC3B;AACA;AACI,OAAKK,IAAL,GAAYA,IAAZ,CAHuB,CAI3B;AACA;;AACI,OAAKL,KAAL,GAAaA,KAAb;AACF,E,CAEA;AACA;AACA;AACA;AACA;AACA;;;eACAM,6BAASC,GAAT,EAAc;AACZnG,MAAI0D,IAAJ1D;AAAAA,MAAUoG,MAAM,GAAG,KAAnBpG;;AACA,OAAKA,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkG,GAAG,CAAC5E,MAAxB,EAAgCtB,CAAC,EAAjC,EAAqC;AACnCD,QAAI4C,KAAK,GAAGuD,GAAG,CAAClG,CAAD,CAAfD;;AACA,QAAI,KAAK8D,EAAL,CAAQlB,KAAR,CAAJ,EAAkB;AAAE,aAAOuD,GAAP;AAAU;;AAC9B,QAAI,KAAKF,IAAL,CAAUI,QAAV,CAAmBzD,KAAK,CAACqD,IAAzB,CAAJ,EAAoC;AAClC,UAAI,CAACvC,IAAL,EAAS;AAAEA,YAAI,GAAGyC,GAAG,CAAC3D,KAAJ,CAAU,CAAV,EAAavC,CAAb,CAAP;AAAsB;AAClC,KAFD,MAEO,IAAI2C,KAAK,CAACqD,IAAN,CAAWI,QAAX,CAAoB,KAAKJ,IAAzB,CAAJ,EAAoC;AACzC,aAAOE,GAAP;AACD,KAFM,MAEA;AACL,UAAI,CAACC,MAAD,IAAWxD,KAAK,CAACqD,IAAN,CAAWK,IAAX,GAAkB,KAAKL,IAAL,CAAUK,IAA3C,EAAiD;AAC/C,YAAI,CAAC5C,IAAL,EAAS;AAAEA,cAAI,GAAGyC,GAAG,CAAC3D,KAAJ,CAAU,CAAV,EAAavC,CAAb,CAAP;AAAsB;;AACjCyD,YAAI,CAACR,IAAL,CAAU,IAAV;AACAkD,cAAM,GAAG,IAAT;AACD;;AACD,UAAI1C,IAAJ,EAAQ;AAAEA,YAAI,CAACR,IAAL,CAAUN,KAAV;AAAgB;AAC3B;AACF;;AACD,MAAI,CAACc,IAAL,EAAS;AAAEA,QAAI,GAAGyC,GAAG,CAAC3D,KAAJ,EAAP;AAAkB;;AAC7B,MAAI,CAAC4D,MAAL,EAAW;AAAE1C,QAAI,CAACR,IAAL,CAAU,IAAV;AAAe;;AAC5B,SAAOQ,IAAP;AACF,E,CAEA;AACA;AACA;;;eACA6C,uCAAcJ,GAAd,EAAmB;AACjB,OAAKnG,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkG,GAAG,CAAC5E,MAAxB,EAAgCtB,CAAC,EAAjC,EACJ;AAAM,QAAI,KAAK6D,EAAL,CAAQqC,GAAG,CAAClG,CAAD,CAAX,CAAJ,EACN;AAAQ,aAAOkG,GAAG,CAAC3D,KAAJ,CAAU,CAAV,EAAavC,CAAb,EAAgB2D,MAAhB,CAAuBuC,GAAG,CAAC3D,KAAJ,CAAUvC,CAAC,GAAG,CAAd,CAAvB,CAAP;AAA8C;AAAC;;AACnD,SAAOkG,GAAP;AACF,E,CAEA;AACA;;;eACAK,2BAAQL,GAAR,EAAa;AACX,OAAKnG,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkG,GAAG,CAAC5E,MAAxB,EAAgCtB,CAAC,EAAjC,EACJ;AAAM,QAAI,KAAK6D,EAAL,CAAQqC,GAAG,CAAClG,CAAD,CAAX,CAAJ,EAAmB;AAAE,aAAO,IAAP;AAAO;AAAI;;AAClC,SAAO,KAAP;AACF,E,CAEA;AACA;AACA;;;eACA6D,iBAAGlB,KAAH,EAAU;AACR,SAAO,QAAQA,KAAR,IACJ,KAAKqD,IAAL,IAAarD,KAAK,CAACqD,IAAnB,IAA2BF,WAAW,CAAC,KAAKH,KAAN,EAAahD,KAAK,CAACgD,KAAnB,CADzC;AAEF,E,CAEA;AACA;;;eACAb,2BAAS;AACP/E,MAAIyG,GAAG,GAAG;AAACR,QAAI,EAAE,KAAKA,IAAL,CAAUS;AAAjB,GAAV1G;;AACA,OAAKA,IAAI2G,CAAT,IAAc,KAAKf,KAAnB,EAA0B;AACxBa,OAAG,CAACb,KAAJ,GAAY,KAAKA,KAAjB;AACA;AACD;;AACD,SAAOa,GAAP;AACF,E,CAEA;;;AACAT,KAAOd,QAAP,GAAO,kBAASC,MAAT,EAAiByB,IAAjB,EAAuB;AAC5B,MAAI,CAACA,IAAL,EAAS;AAAE,UAAM,IAAI1C,UAAJ,CAAe,iCAAf,CAAN;AAAuD;;AAClElE,MAAIiG,IAAI,GAAGd,MAAM,CAAC0B,KAAP,CAAaD,IAAI,CAACX,IAAlB,CAAXjG;;AACA,MAAI,CAACiG,IAAL,EAAS;AAAE,UAAM,IAAI/B,UAAJ,CAAc,2BAA0B0C,IAAI,CAACX,IAA/B,GAAmC,iBAAjD,CAAN;AAAyE;;AACpF,SAAOA,IAAI,CAACa,MAAL,CAAYF,IAAI,CAAChB,KAAjB,CAAP;AACF,CALA,C,CAOA;AACA;;;AACAI,KAAOe,OAAP,GAAO,iBAAQlH,CAAR,EAAWC,CAAX,EAAc;AACnB,MAAID,CAAC,IAAIC,CAAT,EAAU;AAAE,WAAO,IAAP;AAAW;;AACvB,MAAID,CAAC,CAAC0B,MAAF,IAAYzB,CAAC,CAACyB,MAAlB,EAAwB;AAAE,WAAO,KAAP;AAAY;;AACtC,OAAKvB,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAAC,CAAC0B,MAAtB,EAA8BtB,CAAC,EAA/B,EACJ;AAAM,QAAI,CAACJ,CAAC,CAACI,CAAD,CAAD,CAAK6D,EAAL,CAAQhE,CAAC,CAACG,CAAD,CAAT,CAAL,EAAkB;AAAE,aAAO,KAAP;AAAO;AAAK;;AAClC,SAAO,IAAP;AACF,CANA,C,CAQA;AACA;AACA;;;AACA+F,KAAOgB,OAAP,GAAO,iBAAQH,KAAR,EAAe;AACpB,MAAI,CAACA,KAAD,IAAUA,KAAK,CAACtF,MAAN,IAAgB,CAA9B,EAA+B;AAAE,WAAOyE,IAAI,CAACiB,IAAZ;AAAgB;;AACjD,MAAIJ,KAAK,YAAYb,IAArB,EAAyB;AAAE,WAAO,CAACa,KAAD,CAAP;AAAc;;AACzC7G,MAAI0D,IAAI,GAAGmD,KAAK,CAACrE,KAAN,EAAXxC;AACA0D,MAAI,CAACwD,IAAL,CAAS,UAAErH,CAAF,EAAKC,CAAL,EAAM;AAAA,WAAKD,CAAC,CAACoG,IAAF,CAAOK,IAAP,GAAcxG,CAAC,CAACmG,IAAF,CAAOK,IAA1B;AAA8B,GAA7C;AACA,SAAO5C,IAAP;AACF,CANA,C,CASF;;;AACAsC,IAAI,CAACiB,IAAL,GAAY,EAAZ,C,CCjHA;AACA;AACA;;AAEO,SAASE,YAAT,CAAsBC,OAAtB,EAA+B;AACpCpH,MAAIqH,GAAG,GAAGC,KAAK,CAACC,IAAN,CAAW,IAAX,EAAiBH,OAAjB,CAAVpH;AACAqH,KAAG,CAACG,SAAJ,GAAgBL,YAAY,CAACM,SAA7B;AACA,SAAOJ,GAAP;AACD;;AAEDF,YAAY,CAACM,SAAb,GAAyBC,MAAM,CAACZ,MAAP,CAAcQ,KAAK,CAACG,SAApB,CAAzB;AACAN,YAAY,CAACM,SAAb,CAAuBE,WAAvB,GAAqCR,YAArC;AACAA,YAAY,CAACM,SAAb,CAAuBf,IAAvB,GAA8B,cAA9B,C,CAEA;AACA;AACA;;IACakB,KAAK,GAWhB,eAAYjH,OAAZ,EAAqBkH,SAArB,EAAgCC,OAAhC,EAAyC;AAC3C;AACI,OAAKnH,OAAL,GAAeA,OAAf,CAFuC,CAG3C;;AACI,OAAKkH,SAAL,GAAiBA,SAAjB,CAJuC,CAK3C;;AACI,OAAKC,OAAL,GAAeA,OAAf;AACF;;;;;;GAEA;AACA;;AACA/D,qBAAInD,IAAJmD,CAAIC,GAAJD,GAAI,YAAO;AACT,SAAO,KAAKpD,OAAL,CAAaC,IAAb,GAAoB,KAAKiH,SAAzB,GAAqC,KAAKC,OAAjD;AACF,CAFA/D;;gBAIAgE,6BAAShI,GAAT,EAAciI,QAAd,EAAwB;AACtBhI,MAAIW,OAAO,GAAGsH,UAAU,CAAC,KAAKtH,OAAN,EAAeZ,GAAG,GAAG,KAAK8H,SAA1B,EAAqCG,QAArC,EAA+C,IAA/C,CAAxBhI;AACA,SAAOW,OAAO,IAAI,IAAIiH,KAAJ,CAAUjH,OAAV,EAAmB,KAAKkH,SAAxB,EAAmC,KAAKC,OAAxC,CAAlB;AACF;;gBAEAI,uCAAcxG,IAAd,EAAoBC,EAApB,EAAwB;AACtB,SAAO,IAAIiG,KAAJ,CAAUO,WAAW,CAAC,KAAKxH,OAAN,EAAee,IAAI,GAAG,KAAKmG,SAA3B,EAAsClG,EAAE,GAAG,KAAKkG,SAAhD,CAArB,EAAiF,KAAKA,SAAtF,EAAiG,KAAKC,OAAtG,CAAP;AACF,E,CAEA;AACA;;;gBACAhE,iBAAGlB,KAAH,EAAU;AACR,SAAO,KAAKjC,OAAL,CAAamD,EAAb,CAAgBlB,KAAK,CAACjC,OAAtB,KAAkC,KAAKkH,SAAL,IAAkBjF,KAAK,CAACiF,SAA1D,IAAuE,KAAKC,OAAL,IAAgBlF,KAAK,CAACkF,OAApG;AACF;;gBAEAlD,+BAAW;AACT,SAAO,KAAKjE,OAAL,GAAe,GAAf,GAAqB,KAAKkH,SAA1B,GAAsC,GAAtC,GAA4C,KAAKC,OAAjD,GAA2D,GAAlE;AACF,E,CAEA;AACA;;;gBACA/C,2BAAS;AACP,MAAI,CAAC,KAAKpE,OAAL,CAAaC,IAAlB,EAAsB;AAAE,WAAO,IAAP;AAAW;;AACnCZ,MAAI4G,IAAI,GAAG;AAACjG,WAAO,EAAE,KAAKA,OAAL,CAAaoE,MAAb;AAAV,GAAX/E;;AACA,MAAI,KAAK6H,SAAL,GAAiB,CAArB,EAAsB;AAAEjB,QAAI,CAACiB,SAAL,GAAiB,KAAKA,SAAtB;AAA+B;;AACvD,MAAI,KAAKC,OAAL,GAAe,CAAnB,EAAoB;AAAElB,QAAI,CAACkB,OAAL,GAAe,KAAKA,OAApB;AAA2B;;AACjD,SAAOlB,IAAP;AACF,E,CAEA;AACA;;;AACAgB,MAAO1C,QAAP,GAAO,kBAASC,MAAT,EAAiByB,IAAjB,EAAuB;AAC5B,MAAI,CAACA,IAAL,EAAS;AAAE,WAAOgB,KAAK,CAACtE,KAAb;AAAkB;;AAC7BtD,MAAI6H,SAAS,GAAGjB,IAAI,CAACiB,SAAL,IAAkB,CAAlC7H;AAAAA,MAAqC8H,OAAO,GAAGlB,IAAI,CAACkB,OAAL,IAAgB,CAA/D9H;;AACA,MAAI,OAAO6H,SAAP,IAAoB,QAApB,IAAgC,OAAOC,OAAP,IAAkB,QAAtD,EACJ;AAAM,UAAM,IAAI5D,UAAJ,CAAe,kCAAf,CAAN;AAAwD;;AAC1D,SAAO,IAAI0D,KAAJ,CAAUpG,QAAQ,CAAC0D,QAAT,CAAkBC,MAAlB,EAA0ByB,IAAI,CAACjG,OAA/B,CAAV,EAAmDkH,SAAnD,EAA8DC,OAA9D,CAAP;AACF,CANA,C,CAQA;AACA;AACA;;;AACAF,MAAOQ,OAAP,GAAO,iBAAQJ,QAAR,EAAkBK,aAAlB,EAAsC;6CAAP,GAAC;AACrCrI,MAAI6H,SAAS,GAAG,CAAhB7H;AAAAA,MAAmB8H,OAAO,GAAG,CAA7B9H;;AACA,OAAKA,IAAIiF,CAAC,GAAG+C,QAAQ,CAAChF,UAAtB,EAAkCiC,CAAC,IAAI,CAACA,CAAC,CAACxC,MAAR,KAAmB4F,aAAa,IAAI,CAACpD,CAAC,CAACgB,IAAF,CAAOqC,IAAP,CAAYC,SAAjD,CAAlC,EAA+FtD,CAAC,GAAGA,CAAC,CAACjC,UAArG,EAA+G;AAAE6E,aAAS;AAAE;;AAC5H,OAAK7H,IAAIiF,GAAC,GAAG+C,QAAQ,CAAClF,SAAtB,EAAiCmC,GAAC,IAAI,CAACA,GAAC,CAACxC,MAARwC,KAAmBoD,aAAa,IAAI,CAACpD,GAAC,CAACgB,IAAFhB,CAAOqD,IAAPrD,CAAYsD,SAAjDtD,CAAjC,EAA8FA,GAAC,GAAGA,GAAC,CAACnC,SAApG,EAA6G;AAAEgF,WAAO;AAAE;;AACxH,SAAO,IAAIF,KAAJ,CAAUI,QAAV,EAAoBH,SAApB,EAA+BC,OAA/B,CAAP;AACF,CALA;;;;AAQF,SAASK,WAAT,CAAqBxH,OAArB,EAA8Be,IAA9B,EAAoCC,EAApC,EAAwC;AACxC,SAAqB,GAAGhB,OAAO,CAAC4D,SAAR,CAAkB7C,IAAlB,CAAxB;AAAO;AAAO;AAAiC,MAAEtB,KAAK,GAAGO,OAAO,CAACwD,UAAR,CAAmBX,KAAnB,CAAV;AAC/C,WAAwC,GAAG7C,OAAO,CAAC4D,SAAR,CAAkB5C,EAAlB,CAA3C;AAAc;AAAiB;;AAC7B,MAAImE,MAAM,IAAIpE,IAAV,IAAkBtB,KAAK,CAACI,MAA5B,EAAoC;AAClC,QAAIgI,QAAQ,IAAI7G,EAAZ,IAAkB,CAAChB,OAAO,CAACP,KAAR,CAAcqI,OAAd,EAAuBjI,MAA9C,EAAoD;AAAE,YAAM,IAAI0D,UAAJ,CAAe,yBAAf,CAAN;AAA+C;;AACrG,WAAOvD,OAAO,CAACwC,GAAR,CAAY,CAAZ,EAAezB,IAAf,EAAqBiB,MAArB,CAA4BhC,OAAO,CAACwC,GAAR,CAAYxB,EAAZ,CAA5B,CAAP;AACD;;AACD,MAAI6B,KAAK,IAAIiF,OAAb,EAAoB;AAAE,UAAM,IAAIvE,UAAJ,CAAe,yBAAf,CAAN;AAA+C;;AACrE,SAAOvD,OAAO,CAAC4C,YAAR,CAAqBC,KAArB,EAA4BpD,KAAK,CAACsD,IAAN,CAAWyE,WAAW,CAAC/H,KAAK,CAACO,OAAP,EAAgBe,IAAI,GAAGoE,MAAP,GAAgB,CAAhC,EAAmCnE,EAAE,GAAGmE,MAAL,GAAc,CAAjD,CAAtB,CAA5B,CAAP;AACD;;AAED,SAASmC,UAAT,CAAoBtH,OAApB,EAA6B+H,IAA7B,EAAmCC,MAAnC,EAA2C7G,MAA3C,EAAmD;AACnD,SAAqB,GAAGnB,OAAO,CAAC4D,SAAR,CAAkBmE,IAAlB,CAAxB;AAAO;AAAO;AAAiC,MAAEtI,KAAK,GAAGO,OAAO,CAACwD,UAAR,CAAmBX,KAAnB,CAAV;;AAC7C,MAAIsC,MAAM,IAAI4C,IAAV,IAAkBtI,KAAK,CAACI,MAA5B,EAAoC;AAClC,QAAIsB,MAAM,IAAI,CAACA,MAAM,CAAC8G,UAAP,CAAkBpF,KAAlB,EAAyBA,KAAzB,EAAgCmF,MAAhC,CAAf,EAAsD;AAAE,aAAO,IAAP;AAAW;;AACnE,WAAOhI,OAAO,CAACwC,GAAR,CAAY,CAAZ,EAAeuF,IAAf,EAAqB/F,MAArB,CAA4BgG,MAA5B,EAAoChG,MAApC,CAA2ChC,OAAO,CAACwC,GAAR,CAAYuF,IAAZ,CAA3C,CAAP;AACD;;AACD1I,MAAIa,KAAK,GAAGoH,UAAU,CAAC7H,KAAK,CAACO,OAAP,EAAgB+H,IAAI,GAAG5C,MAAP,GAAgB,CAAhC,EAAmC6C,MAAnC,CAAtB3I;AACA,SAAOa,KAAK,IAAIF,OAAO,CAAC4C,YAAR,CAAqBC,KAArB,EAA4BpD,KAAK,CAACsD,IAAN,CAAW7C,KAAX,CAA5B,CAAhB;AACD,C,CAED;AACA;;;AACA+G,KAAK,CAACtE,KAAN,GAAc,IAAIsE,KAAJ,CAAUpG,QAAQ,CAAC8B,KAAnB,EAA0B,CAA1B,EAA6B,CAA7B,CAAd;;AAEO,SAASuF,OAAT,CAAiBC,KAAjB,EAAwBC,GAAxB,EAA6BvG,KAA7B,EAAoC;AACzC,MAAIA,KAAK,CAACqF,SAAN,GAAkBiB,KAAK,CAACE,KAA5B,EACF;AAAI,UAAM,IAAI7B,YAAJ,CAAiB,iDAAjB,CAAN;AAAyE;;AAC3E,MAAI2B,KAAK,CAACE,KAAN,GAAcxG,KAAK,CAACqF,SAApB,IAAiCkB,GAAG,CAACC,KAAJ,GAAYxG,KAAK,CAACsF,OAAvD,EACF;AAAI,UAAM,IAAIX,YAAJ,CAAiB,0BAAjB,CAAN;AAAkD;;AACpD,SAAO8B,YAAY,CAACH,KAAD,EAAQC,GAAR,EAAavG,KAAb,EAAoB,CAApB,CAAnB;AACD;;AAED,SAASyG,YAAT,CAAsBH,KAAtB,EAA6BC,GAA7B,EAAkCvG,KAAlC,EAAyCwG,KAAzC,EAAgD;AAC9ChJ,MAAIwD,KAAK,GAAGsF,KAAK,CAACtF,KAAN,CAAYwF,KAAZ,CAAZhJ;AAAAA,MAAgCuC,IAAI,GAAGuG,KAAK,CAACvG,IAAN,CAAWyG,KAAX,CAAvChJ;;AACA,MAAIwD,KAAK,IAAIuF,GAAG,CAACvF,KAAJ,CAAUwF,KAAV,CAAT,IAA6BA,KAAK,GAAGF,KAAK,CAACE,KAAN,GAAcxG,KAAK,CAACqF,SAA7D,EAAwE;AACtE7H,QAAIa,KAAK,GAAGoI,YAAY,CAACH,KAAD,EAAQC,GAAR,EAAavG,KAAb,EAAoBwG,KAAK,GAAG,CAA5B,CAAxBhJ;AACA,WAAOuC,IAAI,CAACmB,IAAL,CAAUnB,IAAI,CAAC5B,OAAL,CAAa4C,YAAb,CAA0BC,KAA1B,EAAiC3C,KAAjC,CAAV,CAAP;AACD,GAHD,MAGO,IAAI,CAAC2B,KAAK,CAAC7B,OAAN,CAAcC,IAAnB,EAAyB;AAC9B,WAAOsI,KAAK,CAAC3G,IAAD,EAAO4G,aAAa,CAACL,KAAD,EAAQC,GAAR,EAAaC,KAAb,CAApB,CAAZ;AACD,GAFM,MAEA,IAAI,CAACxG,KAAK,CAACqF,SAAP,IAAoB,CAACrF,KAAK,CAACsF,OAA3B,IAAsCgB,KAAK,CAACE,KAAN,IAAeA,KAArD,IAA8DD,GAAG,CAACC,KAAJ,IAAaA,KAA/E,EAAsF;AAAA;AAC3FhJ,QAAI8B,MAAM,GAAGgH,KAAK,CAAChH,MAAnB9B;AAAAA,QAA2BW,OAAO,GAAGmB,MAAM,CAACnB,OAA5CX;AACA,WAAOkJ,KAAK,CAACpH,MAAD,EAASnB,OAAO,CAACwC,GAAR,CAAY,CAAZ,EAAe2F,KAAK,CAACM,YAArB,EAAmCzG,MAAnC,CAA0CH,KAAK,CAAC7B,OAAhD,EAAyDgC,MAAzD,CAAgEhC,OAAO,CAACwC,GAAR,CAAY4F,GAAG,CAACK,YAAhB,CAAhE,CAAT,CAAZ;AACD,GAHM,MAGA;AACT,WAAoB,GAAGC,sBAAsB,CAAC7G,KAAD,EAAQsG,KAAR,CAA7C;AAAS;AAAO;AACZ,WAAOI,KAAK,CAAC3G,IAAD,EAAO+G,eAAe,CAACR,KAAD,EAAQ9G,KAAR,EAAeD,GAAf,EAAoBgH,GAApB,EAAyBC,KAAzB,CAAtB,CAAZ;AACD;AACF;;AAED,SAASO,SAAT,CAAmBC,IAAnB,EAAyBC,GAAzB,EAA8B;AAC5B,MAAI,CAACA,GAAG,CAACxD,IAAJ,CAASyD,iBAAT,CAA2BF,IAAI,CAACvD,IAAhC,CAAL,EACF;AAAI,UAAM,IAAIkB,YAAJ,CAAiB,iBAAiBsC,GAAG,CAACxD,IAAJ,CAASS,IAA1B,GAAiC,QAAjC,GAA4C8C,IAAI,CAACvD,IAAL,CAAUS,IAAvE,CAAN;AAAkF;AACrF;;AAED,SAASiD,QAAT,CAAkBC,OAAlB,EAA2BC,MAA3B,EAAmCb,KAAnC,EAA0C;AACxChJ,MAAIuC,IAAI,GAAGqH,OAAO,CAACrH,IAAR,CAAayG,KAAb,CAAXhJ;AACAuJ,WAAS,CAAChH,IAAD,EAAOsH,MAAM,CAACtH,IAAP,CAAYyG,KAAZ,CAAP,CAAT;AACA,SAAOzG,IAAP;AACD;;AAED,SAASuH,OAAT,CAAiB1J,KAAjB,EAAwB2J,MAAxB,EAAgC;AAC9B/J,MAAI6C,IAAI,GAAGkH,MAAM,CAACxI,MAAP,GAAgB,CAA3BvB;;AACA,MAAI6C,IAAI,IAAI,CAAR,IAAazC,KAAK,CAACI,MAAnB,IAA6BJ,KAAK,CAACG,UAAN,CAAiBwJ,MAAM,CAAClH,IAAD,CAAvB,CAAjC,EACF;AAAIkH,UAAM,CAAClH,IAAD,CAAN,GAAezC,KAAK,CAAC6C,QAAN,CAAe8G,MAAM,CAAClH,IAAD,CAAN,CAAapC,IAAb,GAAoBL,KAAK,CAACK,IAAzC,CAAf;AAA6D,GAD/D,MAGF;AAAIsJ,UAAM,CAAC7G,IAAP,CAAY9C,KAAZ;AAAkB;AACrB;;AAED,SAAS4J,QAAT,CAAkBC,MAAlB,EAA0BC,IAA1B,EAAgClB,KAAhC,EAAuCe,MAAvC,EAA+C;AAC7C/J,MAAIuC,IAAI,GAAG,CAAC2H,IAAI,IAAID,MAAT,EAAiB1H,IAAjB,CAAsByG,KAAtB,CAAXhJ;AACAA,MAAImK,UAAU,GAAG,CAAjBnK;AAAAA,MAAoBoK,QAAQ,GAAGF,IAAI,GAAGA,IAAI,CAAC1G,KAAL,CAAWwF,KAAX,CAAH,GAAuBzG,IAAI,CAACrC,UAA/DF;;AACA,MAAIiK,MAAJ,EAAY;AACVE,cAAU,GAAGF,MAAM,CAACzG,KAAP,CAAawF,KAAb,CAAb;;AACA,QAAIiB,MAAM,CAACjB,KAAP,GAAeA,KAAnB,EAA0B;AACxBmB,gBAAU;AACX,KAFD,MAEO,IAAIF,MAAM,CAACI,UAAX,EAAuB;AAC5BP,aAAO,CAACG,MAAM,CAACK,SAAR,EAAmBP,MAAnB,CAAP;AACAI,gBAAU;AACX;AACF;;AACD,OAAKnK,IAAIC,CAAC,GAAGkK,UAAb,EAAyBlK,CAAC,GAAGmK,QAA7B,EAAuCnK,CAAC,EAAxC,EAA0C;AAAE6J,WAAO,CAACvH,IAAI,CAACnC,KAAL,CAAWH,CAAX,CAAD,EAAgB8J,MAAhB,CAAP;AAA8B;;AAC1E,MAAIG,IAAI,IAAIA,IAAI,CAAClB,KAAL,IAAcA,KAAtB,IAA+BkB,IAAI,CAACG,UAAxC,EACF;AAAIP,WAAO,CAACI,IAAI,CAACK,UAAN,EAAkBR,MAAlB,CAAP;AAAgC;AACnC;;AAED,SAASb,KAAT,CAAe3G,IAAf,EAAqB5B,OAArB,EAA8B;AAC5B,MAAI,CAAC4B,IAAI,CAAC0D,IAAL,CAAUuE,YAAV,CAAuB7J,OAAvB,CAAL,EACF;AAAI,UAAM,IAAIwG,YAAJ,CAAiB,8BAA8B5E,IAAI,CAAC0D,IAAL,CAAUS,IAAzD,CAAN;AAAoE;;AACtE,SAAOnE,IAAI,CAACmB,IAAL,CAAU/C,OAAV,CAAP;AACD;;AAED,SAAS2I,eAAT,CAAyBR,KAAzB,EAAgCmB,MAAhC,EAAwCC,IAAxC,EAA8CnB,GAA9C,EAAmDC,KAAnD,EAA0D;AACxDhJ,MAAI6H,SAAS,GAAGiB,KAAK,CAACE,KAAN,GAAcA,KAAd,IAAuBW,QAAQ,CAACb,KAAD,EAAQmB,MAAR,EAAgBjB,KAAK,GAAG,CAAxB,CAA/ChJ;AACAA,MAAI8H,OAAO,GAAGiB,GAAG,CAACC,KAAJ,GAAYA,KAAZ,IAAqBW,QAAQ,CAACO,IAAD,EAAOnB,GAAP,EAAYC,KAAK,GAAG,CAApB,CAA3ChJ;AAEAA,MAAIW,OAAO,GAAG,EAAdX;AACAgK,UAAQ,CAAC,IAAD,EAAOlB,KAAP,EAAcE,KAAd,EAAqBrI,OAArB,CAAR;;AACA,MAAIkH,SAAS,IAAIC,OAAb,IAAwBmC,MAAM,CAACzG,KAAP,CAAawF,KAAb,KAAuBkB,IAAI,CAAC1G,KAAL,CAAWwF,KAAX,CAAnD,EAAsE;AACpEO,aAAS,CAAC1B,SAAD,EAAYC,OAAZ,CAAT;AACAgC,WAAO,CAACZ,KAAK,CAACrB,SAAD,EAAYyB,eAAe,CAACR,KAAD,EAAQmB,MAAR,EAAgBC,IAAhB,EAAsBnB,GAAtB,EAA2BC,KAAK,GAAG,CAAnC,CAA3B,CAAN,EAAyErI,OAAzE,CAAP;AACD,GAHD,MAGO;AACL,QAAIkH,SAAJ,EACJ;AAAMiC,aAAO,CAACZ,KAAK,CAACrB,SAAD,EAAYsB,aAAa,CAACL,KAAD,EAAQmB,MAAR,EAAgBjB,KAAK,GAAG,CAAxB,CAAzB,CAAN,EAA4DrI,OAA5D,CAAP;AAA2E;;AAC7EqJ,YAAQ,CAACC,MAAD,EAASC,IAAT,EAAelB,KAAf,EAAsBrI,OAAtB,CAAR;;AACA,QAAImH,OAAJ,EACJ;AAAMgC,aAAO,CAACZ,KAAK,CAACpB,OAAD,EAAUqB,aAAa,CAACe,IAAD,EAAOnB,GAAP,EAAYC,KAAK,GAAG,CAApB,CAAvB,CAAN,EAAsDrI,OAAtD,CAAP;AAAqE;AACxE;;AACDqJ,UAAQ,CAACjB,GAAD,EAAM,IAAN,EAAYC,KAAZ,EAAmBrI,OAAnB,CAAR;AACA,SAAO,IAAIa,QAAJ,CAAab,OAAb,CAAP;AACD;;AAED,SAASwI,aAAT,CAAuBL,KAAvB,EAA8BC,GAA9B,EAAmCC,KAAnC,EAA0C;AACxChJ,MAAIW,OAAO,GAAG,EAAdX;AACAgK,UAAQ,CAAC,IAAD,EAAOlB,KAAP,EAAcE,KAAd,EAAqBrI,OAArB,CAAR;;AACA,MAAImI,KAAK,CAACE,KAAN,GAAcA,KAAlB,EAAyB;AACvBhJ,QAAIiG,IAAI,GAAG0D,QAAQ,CAACb,KAAD,EAAQC,GAAR,EAAaC,KAAK,GAAG,CAArB,CAAnBhJ;AACA8J,WAAO,CAACZ,KAAK,CAACjD,IAAD,EAAOkD,aAAa,CAACL,KAAD,EAAQC,GAAR,EAAaC,KAAK,GAAG,CAArB,CAApB,CAAN,EAAoDrI,OAApD,CAAP;AACD;;AACDqJ,UAAQ,CAACjB,GAAD,EAAM,IAAN,EAAYC,KAAZ,EAAmBrI,OAAnB,CAAR;AACA,SAAO,IAAIa,QAAJ,CAAab,OAAb,CAAP;AACD;;AAED,SAAS0I,sBAAT,CAAgC7G,KAAhC,EAAuCiI,MAAvC,EAA+C;AAC7CzK,MAAI0K,KAAK,GAAGD,MAAM,CAACzB,KAAP,GAAexG,KAAK,CAACqF,SAAjC7H;AAAAA,MAA4C8B,MAAM,GAAG2I,MAAM,CAAClI,IAAP,CAAYmI,KAAZ,CAArD1K;AACAA,MAAIuC,IAAI,GAAGT,MAAM,CAAC4B,IAAP,CAAYlB,KAAK,CAAC7B,OAAlB,CAAXX;;AACA,OAAKA,IAAIC,CAAC,GAAGyK,KAAK,GAAG,CAArB,EAAwBzK,CAAC,IAAI,CAA7B,EAAgCA,CAAC,EAAjC,EACF;AAAIsC,QAAI,GAAGkI,MAAM,CAAClI,IAAP,CAAYtC,CAAZ,EAAeyD,IAAf,CAAoBlC,QAAQ,CAACE,IAAT,CAAca,IAAd,CAApB,CAAP;AAA+C;;AACjD,SAAO;AAACP,SAAK,EAAEO,IAAI,CAACoI,cAAL,CAAoBnI,KAAK,CAACqF,SAAN,GAAkB6C,KAAtC,CAAR;AACC3I,OAAG,EAAEQ,IAAI,CAACoI,cAAL,CAAoBpI,IAAI,CAAC5B,OAAL,CAAaC,IAAb,GAAoB4B,KAAK,CAACsF,OAA1B,GAAoC4C,KAAxD;AADN,GAAP;AAEF,C,CC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACaE,WAAW,GACtB,qBAAY7K,GAAZ,EAAiB8K,IAAjB,EAAuBzB,YAAvB,EAAqC;AACvC;AACI,OAAKrJ,GAAL,GAAWA,GAAX;AACA,OAAK8K,IAAL,GAAYA,IAAZ,CAHmC,CAIvC;AACA;AACA;AACA;;AACI,OAAK7B,KAAL,GAAa6B,IAAI,CAACtJ,MAAL,GAAc,CAAd,GAAkB,CAA/B,CARmC,CASvC;;AACI,OAAK6H,YAAL,GAAoBA,YAApB;AACF;;;;;;;;;;;;;;;;;;;;sBAEA0B,qCAAaC,GAAb,EAAkB;AAChB,MAAIA,GAAG,IAAI,IAAX,EAAe;AAAE,WAAO,KAAK/B,KAAZ;AAAiB;;AAClC,MAAI+B,GAAG,GAAG,CAAV,EAAW;AAAE,WAAO,KAAK/B,KAAL,GAAa+B,GAApB;AAAuB;;AACpC,SAAOA,GAAP;AACF,E,CAEA;AACA;AACA;AACA;;;AACAhH,qBAAIjC,MAAJiC,CAAIC,GAAJD,GAAI,YAAS;AAAE,SAAO,KAAKxB,IAAL,CAAU,KAAKyG,KAAf,CAAP;AAA4B,CAA3CjF,C,CAEA;AACA;;;AACAA,qBAAIiH,GAAJjH,CAAIC,GAAJD,GAAI,YAAM;AAAE,SAAO,KAAKxB,IAAL,CAAU,CAAV,CAAP;AAAmB,CAA/BwB,C,CAEA;AACA;AACA;;;sBACAxB,qBAAKyG,KAAL,EAAY;AAAE,SAAO,KAAK6B,IAAL,CAAU,KAAKC,YAAL,CAAkB9B,KAAlB,IAA2B,CAArC,CAAP;AAA8C,E,CAE5D;AACA;AACA;AACA;;;sBACAxF,uBAAMwF,KAAN,EAAa;AAAE,SAAO,KAAK6B,IAAL,CAAU,KAAKC,YAAL,CAAkB9B,KAAlB,IAA2B,CAA3B,GAA+B,CAAzC,CAAP;AAAkD,E,CAEjE;AACA;AACA;;;sBACAiC,iCAAWjC,KAAX,EAAkB;AAChBA,OAAK,GAAG,KAAK8B,YAAL,CAAkB9B,KAAlB,CAAR;AACA,SAAO,KAAKxF,KAAL,CAAWwF,KAAX,KAAqBA,KAAK,IAAI,KAAKA,KAAd,IAAuB,CAAC,KAAKqB,UAA7B,GAA0C,CAA1C,GAA8C,CAAnE,CAAP;AACF,E,CAEA;AACA;AACA;;;sBACArI,uBAAMgH,KAAN,EAAa;AACXA,OAAK,GAAG,KAAK8B,YAAL,CAAkB9B,KAAlB,CAAR;AACA,SAAOA,KAAK,IAAI,CAAT,GAAa,CAAb,GAAiB,KAAK6B,IAAL,CAAU7B,KAAK,GAAG,CAAR,GAAY,CAAtB,IAA2B,CAAnD;AACF,E,CAEA;AACA;AACA;;;sBACAjH,mBAAIiH,KAAJ,EAAW;AACTA,OAAK,GAAG,KAAK8B,YAAL,CAAkB9B,KAAlB,CAAR;AACA,SAAO,KAAKhH,KAAL,CAAWgH,KAAX,IAAoB,KAAKzG,IAAL,CAAUyG,KAAV,EAAiBrI,OAAjB,CAAyBC,IAApD;AACF,E,CAEA;AACA;AACA;AACA;;;sBACAsK,yBAAOlC,KAAP,EAAc;AACZA,OAAK,GAAG,KAAK8B,YAAL,CAAkB9B,KAAlB,CAAR;;AACA,MAAI,CAACA,KAAL,EAAU;AAAE,UAAM,IAAI9E,UAAJ,CAAe,gDAAf,CAAN;AAAsE;;AAClF,SAAO8E,KAAK,IAAI,KAAKA,KAAL,GAAa,CAAtB,GAA0B,KAAKjJ,GAA/B,GAAqC,KAAK8K,IAAL,CAAU7B,KAAK,GAAG,CAAR,GAAY,CAAtB,CAA5C;AACF,E,CAEA;AACA;AACA;;;sBACAmC,uBAAMnC,KAAN,EAAa;AACXA,OAAK,GAAG,KAAK8B,YAAL,CAAkB9B,KAAlB,CAAR;;AACA,MAAI,CAACA,KAAL,EAAU;AAAE,UAAM,IAAI9E,UAAJ,CAAe,+CAAf,CAAN;AAAqE;;AACjF,SAAO8E,KAAK,IAAI,KAAKA,KAAL,GAAa,CAAtB,GAA0B,KAAKjJ,GAA/B,GAAqC,KAAK8K,IAAL,CAAU7B,KAAK,GAAG,CAAR,GAAY,CAAtB,IAA2B,KAAK6B,IAAL,CAAU7B,KAAK,GAAG,CAAlB,EAAqB1I,QAA5F;AACF,E,CAEA;AACA;AACA;AACA;;;AACAyD,qBAAIsG,UAAJtG,CAAIC,GAAJD,GAAI,YAAa;AAAE,SAAO,KAAKhE,GAAL,GAAW,KAAK8K,IAAL,CAAU,KAAKA,IAAL,CAAUtJ,MAAV,GAAmB,CAA7B,CAAlB;AAAiD,CAApEwC,C,CAEA;AACA;AACA;AACA;;;AACAA,qBAAIuG,SAAJvG,CAAIC,GAAJD,GAAI,YAAY;AACd/D,MAAI8B,MAAM,GAAG,KAAKA,MAAlB9B;AAAAA,MAA0BwD,KAAK,GAAG,KAAKA,KAAL,CAAW,KAAKwF,KAAhB,CAAlChJ;;AACA,MAAIwD,KAAK,IAAI1B,MAAM,CAAC5B,UAApB,EAA8B;AAAE,WAAO,IAAP;AAAW;;AAC3CF,MAAIoL,IAAI,GAAG,KAAKrL,GAAL,GAAW,KAAK8K,IAAL,CAAU,KAAKA,IAAL,CAAUtJ,MAAV,GAAmB,CAA7B,CAAtBvB;AAAAA,MAAuDI,KAAK,GAAG0B,MAAM,CAAC1B,KAAP,CAAaoD,KAAb,CAA/DxD;AACA,SAAOoL,IAAI,GAAGtJ,MAAM,CAAC1B,KAAP,CAAaoD,KAAb,EAAoBL,GAApB,CAAwBiI,IAAxB,CAAH,GAAmChL,KAA9C;AACF,CALA2D,C,CAOA;AACA;AACA;AACA;;;AACAA,qBAAIwG,UAAJxG,CAAIC,GAAJD,GAAI,YAAa;AACf/D,MAAIwD,KAAK,GAAG,KAAKA,KAAL,CAAW,KAAKwF,KAAhB,CAAZhJ;AACAA,MAAIoL,IAAI,GAAG,KAAKrL,GAAL,GAAW,KAAK8K,IAAL,CAAU,KAAKA,IAAL,CAAUtJ,MAAV,GAAmB,CAA7B,CAAtBvB;;AACA,MAAIoL,IAAJ,EAAQ;AAAE,WAAO,KAAKtJ,MAAL,CAAY1B,KAAZ,CAAkBoD,KAAlB,EAAyBL,GAAzB,CAA6B,CAA7B,EAAgCiI,IAAhC,CAAP;AAA4C;;AACtD,SAAO5H,KAAK,IAAI,CAAT,GAAa,IAAb,GAAoB,KAAK1B,MAAL,CAAY1B,KAAZ,CAAkBoD,KAAK,GAAG,CAA1B,CAA3B;AACF,CALAO,C,CAOA;AACA;AACA;;;sBACAsH,iCAAW7H,KAAX,EAAkBwF,KAAlB,EAAyB;AACvBA,OAAK,GAAG,KAAK8B,YAAL,CAAkB9B,KAAlB,CAAR;AACAhJ,MAAIuC,IAAI,GAAG,KAAKsI,IAAL,CAAU7B,KAAK,GAAG,CAAlB,CAAXhJ;AAAAA,MAAiCD,GAAG,GAAGiJ,KAAK,IAAI,CAAT,GAAa,CAAb,GAAiB,KAAK6B,IAAL,CAAU7B,KAAK,GAAG,CAAR,GAAY,CAAtB,IAA2B,CAAnFhJ;;AACA,OAAKA,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuD,KAApB,EAA2BvD,CAAC,EAA5B,EAA8B;AAAEF,OAAG,IAAIwC,IAAI,CAACnC,KAAL,CAAWH,CAAX,EAAcK,QAArB;AAA6B;;AAC7D,SAAOP,GAAP;AACF,E,CAEA;AACA;AACA;AACA;AACA;;;sBACA8G,yBAAQ;AACN7G,MAAI8B,MAAM,GAAG,KAAKA,MAAlB9B;AAAAA,MAA0BwD,KAAK,GAAG,KAAKA,KAAL,EAAlCxD,CADM,CAGV;;AACI,MAAI8B,MAAM,CAACnB,OAAP,CAAeC,IAAf,IAAuB,CAA3B,EAA4B;AAAE,WAAOoF,IAAI,CAACiB,IAAZ;AAAgB,GAJxC,CAMV;;;AACI,MAAI,KAAKoD,UAAT,EAAmB;AAAE,WAAOvI,MAAM,CAAC1B,KAAP,CAAaoD,KAAb,EAAoBqD,KAA3B;AAAgC;;AAErD7G,MAAIwJ,IAAI,GAAG1H,MAAM,CAACqC,UAAP,CAAkBX,KAAK,GAAG,CAA1B,CAAXxD;AAAAA,MAAyC4C,KAAK,GAAGd,MAAM,CAACqC,UAAP,CAAkBX,KAAlB,CAAjDxD,CATM,CAUV;AACA;;AACI,MAAI,CAACwJ,IAAL,EAAW;AAAExJ,QAAIsL,GAAG,GAAG9B,IAAVxJ;AAAgBwJ,QAAI,GAAG5G,KAAP;AAAcA,SAAK,GAAG0I,GAAR;AAAa,GAZlD,CAcV;AACA;;;AACItL,MAAI6G,KAAK,GAAG2C,IAAI,CAAC3C,KAAjB7G;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4G,KAAK,CAACtF,MAA1B,EAAkCtB,CAAC,EAAnC,EACJ;AAAM,QAAI4G,KAAK,CAAC5G,CAAD,CAAL,CAASgG,IAAT,CAAcqC,IAAd,CAAmBiD,SAAnB,KAAiC,KAAjC,KAA2C,CAAC3I,KAAD,IAAU,CAACiE,KAAK,CAAC5G,CAAD,CAAL,CAASuG,OAAT,CAAiB5D,KAAK,CAACiE,KAAvB,CAAtD,CAAJ,EACN;AAAQA,WAAK,GAAGA,KAAK,CAAC5G,CAAC,EAAF,CAAL,CAAWsG,aAAX,CAAyBM,KAAzB,CAAR;AAAsC;AAAC;;AAE3C,SAAOA,KAAP;AACF,E,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;sBACA2E,mCAAYtB,IAAZ,EAAkB;AAChBlK,MAAImL,KAAK,GAAG,KAAKrJ,MAAL,CAAYqC,UAAZ,CAAuB,KAAKX,KAAL,EAAvB,CAAZxD;;AACA,MAAI,CAACmL,KAAD,IAAU,CAACA,KAAK,CAACM,QAArB,EAA6B;AAAE,WAAO,IAAP;AAAW;;AAE1CzL,MAAI6G,KAAK,GAAGsE,KAAK,CAACtE,KAAlB7G;AAAAA,MAAyB0L,IAAI,GAAGxB,IAAI,CAACpI,MAAL,CAAYqC,UAAZ,CAAuB+F,IAAI,CAAC1G,KAAL,EAAvB,CAAhCxD;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4G,KAAK,CAACtF,MAA1B,EAAkCtB,CAAC,EAAnC,EACJ;AAAM,QAAI4G,KAAK,CAAC5G,CAAD,CAAL,CAASgG,IAAT,CAAcqC,IAAd,CAAmBiD,SAAnB,KAAiC,KAAjC,KAA2C,CAACG,IAAD,IAAS,CAAC7E,KAAK,CAAC5G,CAAD,CAAL,CAASuG,OAAT,CAAiBkF,IAAI,CAAC7E,KAAtB,CAArD,CAAJ,EACN;AAAQA,WAAK,GAAGA,KAAK,CAAC5G,CAAC,EAAF,CAAL,CAAWsG,aAAX,CAAyBM,KAAzB,CAAR;AAAsC;AAAC;;AAC3C,SAAOA,KAAP;AACF,E,CAEA;AACA;AACA;;;sBACA8E,mCAAY5L,GAAZ,EAAiB;AACf,OAAKC,IAAIgJ,KAAK,GAAG,KAAKA,KAAtB,EAA6BA,KAAK,GAAG,CAArC,EAAwCA,KAAK,EAA7C,EACJ;AAAM,QAAI,KAAKhH,KAAL,CAAWgH,KAAX,KAAqBjJ,GAArB,IAA4B,KAAKgC,GAAL,CAASiH,KAAT,KAAmBjJ,GAAnD,EAAsD;AAAE,aAAOiJ,KAAP;AAAO;AAAK;;AACtE,SAAO,CAAP;AACF,E,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;sBACA4C,iCAAWhJ,KAAX,EAAyBiJ,IAAzB,EAA+B;6BAAf,GAAG;;AACjB,MAAIjJ,KAAK,CAAC7C,GAAN,GAAY,KAAKA,GAArB,EAAwB;AAAE,WAAO6C,KAAK,CAACgJ,UAAN,CAAiB,IAAjB,CAAP;AAA6B;;AACvD,OAAK5L,IAAI8L,CAAC,GAAG,KAAK9C,KAAL,IAAc,KAAKlH,MAAL,CAAYiK,aAAZ,IAA6B,KAAKhM,GAAL,IAAY6C,KAAK,CAAC7C,GAA/C,GAAqD,CAArD,GAAyD,CAAvE,CAAb,EAAwF+L,CAAC,IAAI,CAA7F,EAAgGA,CAAC,EAAjG,EACJ;AAAM,QAAIlJ,KAAK,CAAC7C,GAAN,IAAa,KAAKgC,GAAL,CAAS+J,CAAT,CAAb,KAA6B,CAACD,IAAD,IAASA,IAAI,CAAC,KAAKtJ,IAAL,CAAUuJ,CAAV,CAAD,CAA1C,CAAJ,EACN;AAAQ,aAAO,IAAIE,SAAJ,CAAc,IAAd,EAAoBpJ,KAApB,EAA2BkJ,CAA3B,CAAP;AAAmC;AAAC;AAC1C,E,CAEA;AACA;;;sBACAG,iCAAWrJ,KAAX,EAAkB;AAChB,SAAO,KAAK7C,GAAL,GAAW,KAAKqJ,YAAhB,IAAgCxG,KAAK,CAAC7C,GAAN,GAAY6C,KAAK,CAACwG,YAAzD;AACF,E,CAEA;AACA;;;sBACAnH,mBAAIW,KAAJ,EAAW;AACT,SAAOA,KAAK,CAAC7C,GAAN,GAAY,KAAKA,GAAjB,GAAuB6C,KAAvB,GAA+B,IAAtC;AACF,E,CAEA;AACA;;;sBACAtB,mBAAIsB,KAAJ,EAAW;AACT,SAAOA,KAAK,CAAC7C,GAAN,GAAY,KAAKA,GAAjB,GAAuB6C,KAAvB,GAA+B,IAAtC;AACF;;sBAEAgC,+BAAW;AACT5E,MAAIkM,GAAG,GAAG,EAAVlM;;AACA,OAAKA,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,KAAK+I,KAA1B,EAAiC/I,CAAC,EAAlC,EACJ;AAAMiM,OAAG,IAAI,CAACA,GAAG,GAAG,GAAH,GAAS,EAAb,IAAmB,KAAK3J,IAAL,CAAUtC,CAAV,EAAagG,IAAb,CAAkBS,IAArC,GAA4C,GAA5C,GAAkD,KAAKlD,KAAL,CAAWvD,CAAC,GAAG,CAAf,CAAzD;AAA0E;;AAC5E,SAAOiM,GAAG,GAAG,GAAN,GAAY,KAAK9C,YAAxB;AACF;;AAEAwB,YAAOuB,OAAP,GAAO,iBAAQnB,GAAR,EAAajL,GAAb,EAAkB;AACvB,MAAI,EAAEA,GAAG,IAAI,CAAP,IAAYA,GAAG,IAAIiL,GAAG,CAACrK,OAAJ,CAAYC,IAAjC,CAAJ,EAA0C;AAAE,UAAM,IAAIsD,UAAJ,CAAe,cAAcnE,GAAd,GAAoB,eAAnC,CAAN;AAAyD;;AACrGC,MAAI6K,IAAI,GAAG,EAAX7K;AACAA,MAAIgC,KAAK,GAAG,CAAZhC;AAAAA,MAAeoJ,YAAY,GAAGrJ,GAA9BC;;AACA,OAAKA,IAAIuC,IAAI,GAAGyI,GAAhB,IAAuB;AAC3B,WAAyB,GAAGzI,IAAI,CAAC5B,OAAL,CAAa4D,SAAb,CAAuB6E,YAAvB,CAA5B;AAAW;AAAO;AACZpJ,QAAIoM,GAAG,GAAGhD,YAAY,GAAGtD,MAAzB9F;AACA6K,QAAI,CAAC3H,IAAL,CAAUX,IAAV,EAAgBiB,KAAhB,EAAuBxB,KAAK,GAAG8D,MAA/B;;AACA,QAAI,CAACsG,GAAL,EAAQ;AAAE;AAAK;;AACf7J,QAAI,GAAGA,IAAI,CAACnC,KAAL,CAAWoD,KAAX,CAAP;;AACA,QAAIjB,IAAI,CAAC/B,MAAT,EAAe;AAAE;AAAK;;AACtB4I,gBAAY,GAAGgD,GAAG,GAAG,CAArB;AACApK,SAAK,IAAI8D,MAAM,GAAG,CAAlB;AACD;;AACD,SAAO,IAAI8E,WAAJ,CAAgB7K,GAAhB,EAAqB8K,IAArB,EAA2BzB,YAA3B,CAAP;AACF,CAfA;;AAiBAwB,YAAOyB,aAAP,GAAO,uBAAcrB,GAAd,EAAmBjL,GAAnB,EAAwB;AAC7B,OAAKC,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqM,YAAY,CAAC/K,MAAjC,EAAyCtB,CAAC,EAA1C,EAA8C;AAC5CD,QAAIuM,MAAM,GAAGD,YAAY,CAACrM,CAAD,CAAzBD;;AACA,QAAIuM,MAAM,CAACxM,GAAP,IAAcA,GAAd,IAAqBwM,MAAM,CAACvB,GAAP,IAAcA,GAAvC,EAA0C;AAAE,aAAOuB,MAAP;AAAa;AAC1D;;AACDvM,MAAIoD,MAAM,GAAGkJ,YAAY,CAACE,eAAD,CAAZ,GAAgC5B,WAAW,CAACuB,OAAZ,CAAoBnB,GAApB,EAAyBjL,GAAzB,CAA7CC;AACAwM,iBAAe,GAAG,CAACA,eAAe,GAAG,CAAnB,IAAwBC,gBAA1C;AACA,SAAOrJ,MAAP;AACF,CARA;;;AAWFpD,IAAIsM,YAAY,GAAG,EAAnBtM;AAAAA,IAAuBwM,eAAe,GAAG,CAAzCxM;AAAAA,IAA4CyM,gBAAgB,GAAG,EAA/DzM,C,CAEA;AACA;;IACagM,SAAS,GAKpB,mBAAYlD,KAAZ,EAAmBC,GAAnB,EAAwBC,KAAxB,EAA+B;AACjC;AACA;AACA;AACA;AACA;AACI,OAAKF,KAAL,GAAaA,KAAb,CAN6B,CAOjC;AACA;;AACI,OAAKC,GAAL,GAAWA,GAAX,CAT6B,CAUjC;;AACI,OAAKC,KAAL,GAAaA,KAAb;AACF;;;;;;;;;;;;;;;;;;GAEA;;AACA0D,uBAAI1K,KAAJ0K,CAAI1I,GAAJ0I,GAAI,YAAQ;AAAE,SAAO,KAAK5D,KAAL,CAAWoC,MAAX,CAAkB,KAAKlC,KAAL,GAAa,CAA/B,CAAP;AAAwC,CAAtD0D,C,CACA;;;AACAA,uBAAI3K,GAAJ2K,CAAI1I,GAAJ0I,GAAI,YAAM;AAAE,SAAO,KAAK3D,GAAL,CAASoC,KAAT,CAAe,KAAKnC,KAAL,GAAa,CAA5B,CAAP;AAAqC,CAAjD0D,C,CAEA;;;AACAA,uBAAI5K,MAAJ4K,CAAI1I,GAAJ0I,GAAI,YAAS;AAAE,SAAO,KAAK5D,KAAL,CAAWvG,IAAX,CAAgB,KAAKyG,KAArB,CAAP;AAAkC,CAAjD0D,C,CACA;;;AACAA,uBAAIvC,UAAJuC,CAAI1I,GAAJ0I,GAAI,YAAa;AAAE,SAAO,KAAK5D,KAAL,CAAWtF,KAAX,CAAiB,KAAKwF,KAAtB,CAAP;AAAmC,CAAtD0D,C,CACA;;;AACAA,uBAAItC,QAAJsC,CAAI1I,GAAJ0I,GAAI,YAAW;AAAE,SAAO,KAAK3D,GAAL,CAASkC,UAAT,CAAoB,KAAKjC,KAAzB,CAAP;AAAsC,CAAvD0D;;;AC3RF7G,IAAM8G,UAAU,GAAGjF,MAAM,CAACZ,MAAP,CAAc,IAAd,CAAnBjB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACa+G,IAAI,GACf,cAAY3G,IAAZ,EAAkBL,KAAlB,EAAyBjF,OAAzB,EAAkCkG,KAAlC,EAAyC;AAC3C;AACA;AACI,OAAKZ,IAAL,GAAYA,IAAZ,CAHuC,CAK3C;AACA;AACA;AACA;;AACI,OAAKL,KAAL,GAAaA,KAAb,CATuC,CAW3C;AACA;;AACI,OAAKjF,OAAL,GAAeA,OAAO,IAAIa,QAAQ,CAAC8B,KAAnC,CAbuC,CAe3C;AACA;AACA;;AACI,OAAKuD,KAAL,GAAaA,KAAK,IAAIb,IAAI,CAACiB,IAA3B;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAlD,qBAAIzD,QAAJyD,CAAIC,GAAJD,GAAI,YAAW;AAAE,SAAO,KAAKtB,MAAL,GAAc,CAAd,GAAkB,IAAI,KAAK9B,OAAL,CAAaC,IAA1C;AAA8C,CAA/DmD,C,CAEA;AACA;;;AACAA,qBAAI7D,UAAJ6D,CAAIC,GAAJD,GAAI,YAAa;AAAE,SAAO,KAAKpD,OAAL,CAAaT,UAApB;AAA8B,CAAjD6D,C,CAEA;AACA;AACA;;;eACA3D,uBAAMoD,KAAN,EAAa;AAAE,SAAO,KAAK7C,OAAL,CAAaP,KAAb,CAAmBoD,KAAnB,CAAP;AAAgC,E,CAE/C;AACA;;;eACAW,iCAAWX,KAAX,EAAkB;AAAE,SAAO,KAAK7C,OAAL,CAAawD,UAAb,CAAwBX,KAAxB,CAAP;AAAqC,E,CAEzD;AACA;AACA;;;eACAY,2BAAQxC,CAAR,EAAW;AAAE,OAAKjB,OAAL,CAAayD,OAAb,CAAqBxC,CAArB;AAAuB,E,CAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;eACAH,qCAAaC,IAAb,EAAmBC,EAAnB,EAAuBC,CAAvB,EAA0BiL,QAA1B,EAAwC;mCAAN,GAAG;AACnC,OAAKlM,OAAL,CAAac,YAAb,CAA0BC,IAA1B,EAAgCC,EAAhC,EAAoCC,CAApC,EAAuCiL,QAAvC,EAAiD,IAAjD;AACF,E,CAEA;AACA;AACA;;;eACA3K,mCAAYN,CAAZ,EAAe;AACb,OAAKH,YAAL,CAAkB,CAAlB,EAAqB,KAAKd,OAAL,CAAaC,IAAlC,EAAwCgB,CAAxC;AACF,E,CAEA;AACA;AACA;;;AACAmC,qBAAI+I,WAAJ/I,CAAIC,GAAJD,GAAI,YAAc;AAAE,SAAO,KAAK5B,WAAL,CAAiB,CAAjB,EAAoB,KAAKxB,OAAL,CAAaC,IAAjC,EAAuC,EAAvC,CAAP;AAAiD,CAArEmD,C,CAEA;AACA;AACA;AACA;AACA;;;eACA5B,mCAAYT,IAAZ,EAAkBC,EAAlB,EAAsBS,cAAtB,EAAsCC,QAAtC,EAAgD;AAC9C,SAAO,KAAK1B,OAAL,CAAawB,WAAb,CAAyBT,IAAzB,EAA+BC,EAA/B,EAAmCS,cAAnC,EAAmDC,QAAnD,CAAP;AACF,E,CAEA;AACA;AACA;;;AACA0B,qBAAIf,UAAJe,CAAIC,GAAJD,GAAI,YAAa;AAAE,SAAO,KAAKpD,OAAL,CAAaqC,UAApB;AAA8B,CAAjDe,C,CAEA;AACA;AACA;;;AACAA,qBAAIjB,SAAJiB,CAAIC,GAAJD,GAAI,YAAY;AAAE,SAAO,KAAKpD,OAAL,CAAamC,SAApB;AAA6B,CAA/CiB,C,CAEA;AACA;;;eACAD,iBAAGlB,KAAH,EAAU;AACR,SAAO,QAAQA,KAAR,IAAkB,KAAKrC,UAAL,CAAgBqC,KAAhB,KAA0B,KAAKjC,OAAL,CAAamD,EAAb,CAAgBlB,KAAK,CAACjC,OAAtB,CAAnD;AACF,E,CAEA;AACA;AACA;;;eACAJ,iCAAWqC,KAAX,EAAkB;AAChB,SAAO,KAAKmK,SAAL,CAAenK,KAAK,CAACqD,IAArB,EAA2BrD,KAAK,CAACgD,KAAjC,EAAwChD,KAAK,CAACiE,KAA9C,CAAP;AACF,E,CAEA;AACA;AACA;;;eACAkG,+BAAU9G,IAAV,EAAgBL,KAAhB,EAAuBiB,KAAvB,EAA8B;AAC5B,SAAO,KAAKZ,IAAL,IAAaA,IAAb,IACLF,WAAW,CAAC,KAAKH,KAAN,EAAaA,KAAK,IAAIK,IAAI,CAAC+G,YAAd,IAA8BL,UAA3C,CADN,IAEL3G,IAAI,CAACe,OAAL,CAAa,KAAKF,KAAlB,EAAyBA,KAAK,IAAIb,IAAI,CAACiB,IAAvC,CAFF;AAGF,E,CAEA;AACA;AACA;;;eACAvD,qBAAK/C,OAAL,EAAqB;iCAAT,GAAG;;AACb,MAAIA,OAAO,IAAI,KAAKA,OAApB,EAA2B;AAAE,WAAO,IAAP;AAAW;;AACxC,SAAO,IAAI,KAAKgH,WAAT,CAAqB,KAAK1B,IAA1B,EAAgC,KAAKL,KAArC,EAA4CjF,OAA5C,EAAqD,KAAKkG,KAA1D,CAAP;AACF,E,CAEA;AACA;AACA;;;eACAoG,qBAAKpG,KAAL,EAAY;AACV,SAAOA,KAAK,IAAI,KAAKA,KAAd,GAAsB,IAAtB,GAA6B,IAAI,KAAKc,WAAT,CAAqB,KAAK1B,IAA1B,EAAgC,KAAKL,KAArC,EAA4C,KAAKjF,OAAjD,EAA0DkG,KAA1D,CAApC;AACF,E,CAEA;AACA;AACA;AACA;;;eACA1D,mBAAIzB,IAAJ,EAAUC,EAAV,EAAc;AACZ,MAAID,IAAI,IAAI,CAAR,IAAaC,EAAE,IAAI,KAAKhB,OAAL,CAAaC,IAApC,EAAwC;AAAE,WAAO,IAAP;AAAW;;AACrD,SAAO,KAAK8C,IAAL,CAAU,KAAK/C,OAAL,CAAawC,GAAb,CAAiBzB,IAAjB,EAAuBC,EAAvB,CAAV,CAAP;AACF,E,CAEA;AACA;AACA;;;eACAa,uBAAMd,IAAN,EAAYC,EAAZ,EAAoCuL,cAApC,EAA4D;uBAA9C,GAAG,KAAKvM,OAAL,CAAaC;+CAAoB,GAAG;;AACnD,MAAIc,IAAI,IAAIC,EAAZ,EAAc;AAAE,WAAOiG,KAAK,CAACtE,KAAb;AAAkB;;AAElCtD,MAAI8I,KAAK,GAAG,KAAKqD,OAAL,CAAazK,IAAb,CAAZ1B;AAAAA,MAAgC+I,GAAG,GAAG,KAAKoD,OAAL,CAAaxK,EAAb,CAAtC3B;AACAA,MAAIgJ,KAAK,GAAGkE,cAAc,GAAG,CAAH,GAAOpE,KAAK,CAAC6C,WAAN,CAAkBhK,EAAlB,CAAjC3B;AACAA,MAAIgC,KAAK,GAAG8G,KAAK,CAAC9G,KAAN,CAAYgH,KAAZ,CAAZhJ;AAAAA,MAAgCuC,IAAI,GAAGuG,KAAK,CAACvG,IAAN,CAAWyG,KAAX,CAAvChJ;AACAA,MAAIW,OAAO,GAAG4B,IAAI,CAAC5B,OAAL,CAAawC,GAAb,CAAiB2F,KAAK,CAAC/I,GAAN,GAAYiC,KAA7B,EAAoC+G,GAAG,CAAChJ,GAAJ,GAAUiC,KAA9C,CAAdhC;AACA,SAAO,IAAI4H,KAAJ,CAAUjH,OAAV,EAAmBmI,KAAK,CAACE,KAAN,GAAcA,KAAjC,EAAwCD,GAAG,CAACC,KAAJ,GAAYA,KAApD,CAAP;AACF,E,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;eACAH,6BAAQnH,IAAR,EAAcC,EAAd,EAAkBa,KAAlB,EAAyB;AACvB,SAAOqG,OAAO,CAAC,KAAKsD,OAAL,CAAazK,IAAb,CAAD,EAAqB,KAAKyK,OAAL,CAAaxK,EAAb,CAArB,EAAuCa,KAAvC,CAAd;AACF,E,CAEA;AACA;;;eACA2K,yBAAOpN,GAAP,EAAY;AACV,OAAKC,IAAIuC,IAAI,GAAG,IAAhB,IAAwB;AAC5B,WAAyB,GAAGA,IAAI,CAAC5B,OAAL,CAAa4D,SAAb,CAAuBxE,GAAvB,CAA5B;AAAW;AAAO;AACZwC,QAAI,GAAGA,IAAI,CAAC4B,UAAL,CAAgBX,KAAhB,CAAP;;AACA,QAAI,CAACjB,IAAL,EAAS;AAAE,aAAO,IAAP;AAAW;;AACtB,QAAIuD,MAAM,IAAI/F,GAAV,IAAiBwC,IAAI,CAAC/B,MAA1B,EAAgC;AAAE,aAAO+B,IAAP;AAAW;;AAC7CxC,OAAG,IAAI+F,MAAM,GAAG,CAAhB;AACD;AACH,E,CAEA;AACA;AACA;AACA;;;eACAsH,iCAAWrN,GAAX,EAAgB;AAClB,SAAuB,GAAG,KAAKY,OAAL,CAAa4D,SAAb,CAAuBxE,GAAvB,CAA1B;AAAS;AAAO;AACZ,SAAO;AAACwC,QAAI,EAAE,KAAK5B,OAAL,CAAawD,UAAb,CAAwBX,KAAxB,CAAP;AAAqCA,WAAEA,KAAvC;AAA4CsC,YAAEA;AAA9C,GAAP;AACF,E,CAEA;AACA;AACA;AACA;;;eACAuH,mCAAYtN,GAAZ,EAAiB;AACf,MAAIA,GAAG,IAAI,CAAX,EAAY;AAAE,WAAO;AAACwC,UAAI,EAAE,IAAP;AAAaiB,WAAK,EAAE,CAApB;AAAuBsC,YAAM,EAAE;AAA/B,KAAP;AAAwC;;AAC1D,SAAuB,GAAG,KAAKnF,OAAL,CAAa4D,SAAb,CAAuBxE,GAAvB,CAA1B;AAAS;AAAO;;AACZ,MAAI+F,MAAM,GAAG/F,GAAb,EAAgB;AAAE,WAAO;AAACwC,UAAI,EAAE,KAAK5B,OAAL,CAAaP,KAAb,CAAmBoD,KAAnB,CAAP;AAAgCA,aAAEA,KAAlC;AAAuCsC,cAAEA;AAAzC,KAAP;AAAuD;;AACzE9F,MAAIuC,IAAI,GAAG,KAAK5B,OAAL,CAAaP,KAAb,CAAmBoD,KAAK,GAAG,CAA3B,CAAXxD;AACA,SAAO;AAAAuC,UAACA,IAAD;AAAOiB,SAAK,EAAEA,KAAK,GAAG,CAAtB;AAAyBsC,UAAM,EAAEA,MAAM,GAAGvD,IAAI,CAACjC;AAA/C,GAAP;AACF,E,CAEA;AACA;AACA;;;eACA6L,2BAAQpM,GAAR,EAAa;AAAE,SAAO6K,WAAW,CAACyB,aAAZ,CAA0B,IAA1B,EAAgCtM,GAAhC,CAAP;AAA2C;;eAE1D4K,yCAAe5K,GAAf,EAAoB;AAAE,SAAO6K,WAAW,CAACuB,OAAZ,CAAoB,IAApB,EAA0BpM,GAA1B,CAAP;AAAqC,E,CAE3D;AACA;AACA;;;eACAuN,qCAAa5L,IAAb,EAAmBC,EAAnB,EAAuBsE,IAAvB,EAA6B;AAC3BjG,MAAIiE,KAAK,GAAG,KAAZjE;;AACA,MAAI2B,EAAE,GAAGD,IAAT,EAAa;AAAE,SAAKD,YAAL,CAAkBC,IAAlB,EAAwBC,EAAxB,EAA0B,UAAEY,IAAF,EAAU;AACjD,UAAI0D,IAAI,CAACO,OAAL,CAAajE,IAAI,CAACsE,KAAlB,CAAJ,EAA4B;AAAE5C,aAAK,GAAG,IAAR;AAAY;;AAC1C,aAAO,CAACA,KAAR;AACD,KAHc;AAGb;;AACF,SAAOA,KAAP;AACF,E,CAEA;AACA;;;AACAF,qBAAIrB,OAAJqB,CAAIC,GAAJD,GAAI,YAAU;AAAE,SAAO,KAAKkC,IAAL,CAAUvD,OAAjB;AAAwB,CAAxCqB,C,CAEA;AACA;AACA;;;AACAA,qBAAIwJ,WAAJxJ,CAAIC,GAAJD,GAAI,YAAc;AAAE,SAAO,KAAKkC,IAAL,CAAUsH,WAAjB;AAA4B,CAAhDxJ,C,CAEA;AACA;;;AACAA,qBAAIgI,aAAJhI,CAAIC,GAAJD,GAAI,YAAgB;AAAE,SAAO,KAAKkC,IAAL,CAAU8F,aAAjB;AAA8B,CAApDhI,C,CAEA;AACA;AACA;;;AACAA,qBAAI0H,QAAJ1H,CAAIC,GAAJD,GAAI,YAAW;AAAE,SAAO,KAAKkC,IAAL,CAAUwF,QAAjB;AAAyB,CAA1C1H,C,CAEA;AACA;;;AACAA,qBAAIvD,MAAJuD,CAAIC,GAAJD,GAAI,YAAS;AAAE,SAAO,KAAKkC,IAAL,CAAUzF,MAAjB;AAAuB,CAAtCuD,C,CAEA;AACA;;;AACAA,qBAAItB,MAAJsB,CAAIC,GAAJD,GAAI,YAAS;AAAE,SAAO,KAAKkC,IAAL,CAAUxD,MAAjB;AAAuB,CAAtCsB,C,CAEA;AACA;AACA;AACA;AACA;AACA;;;AACAA,qBAAIyJ,MAAJzJ,CAAIC,GAAJD,GAAI,YAAS;AAAE,SAAO,KAAKkC,IAAL,CAAUuH,MAAjB;AAAuB,CAAtCzJ,C,CAEA;AACA;AACA;;;eACAa,+BAAW;AACT,MAAI,KAAKqB,IAAL,CAAUqC,IAAV,CAAemF,aAAnB,EAAgC;AAAE,WAAO,KAAKxH,IAAL,CAAUqC,IAAV,CAAemF,aAAf,CAA6B,IAA7B,CAAP;AAAyC;;AAC3EzN,MAAI0G,IAAI,GAAG,KAAKT,IAAL,CAAUS,IAArB1G;;AACA,MAAI,KAAKW,OAAL,CAAaC,IAAjB,EACJ;AAAM8F,QAAI,IAAI,MAAM,KAAK/F,OAAL,CAAakE,aAAb,EAAN,GAAqC,GAA7C;AAAgD;;AAClD,SAAO6I,SAAS,CAAC,KAAK7G,KAAN,EAAaH,IAAb,CAAhB;AACF,E,CAEA;AACA;;;eACAiH,yCAAenK,KAAf,EAAsB;AACpBxD,MAAI4N,KAAK,GAAG,KAAK3H,IAAL,CAAU4H,YAAV,CAAuBC,aAAvB,CAAqC,KAAKnN,OAA1C,EAAmD,CAAnD,EAAsD6C,KAAtD,CAAZxD;;AACA,MAAI,CAAC4N,KAAL,EAAU;AAAE,UAAM,IAAItG,KAAJ,CAAU,sDAAV,CAAN;AAAuE;;AACnF,SAAOsG,KAAP;AACF,E,CAEA;AACA;AACA;AACA;AACA;AACA;;;eACAhF,iCAAWlH,IAAX,EAAiBC,EAAjB,EAAqBoM,WAArB,EAAmD/L,KAAnD,EAA8DD,GAA9D,EAA4F;yCAA5D,GAAGP,QAAQ,CAAC8B;6BAAY,GAAG;yBAAM,GAAGyK,WAAW,CAAC7N;AAC9EF,MAAIgO,GAAG,GAAG,KAAKL,cAAL,CAAoBjM,IAApB,EAA0BoM,aAA1B,CAAwCC,WAAxC,EAAqD/L,KAArD,EAA4DD,GAA5D,CAAV/B;AACAA,MAAIiO,GAAG,GAAGD,GAAG,IAAIA,GAAG,CAACF,aAAJ,CAAkB,KAAKnN,OAAvB,EAAgCgB,EAAhC,CAAjB3B;;AACA,MAAI,CAACiO,GAAD,IAAQ,CAACA,GAAG,CAACC,QAAjB,EAAyB;AAAE,WAAO,KAAP;AAAY;;AACvC,OAAKlO,IAAIC,CAAC,GAAG+B,KAAb,EAAoB/B,CAAC,GAAG8B,GAAxB,EAA6B9B,CAAC,EAA9B,EAAgC;AAAE,QAAI,CAAC,KAAKgG,IAAL,CAAUkI,WAAV,CAAsBJ,WAAW,CAAC3N,KAAZ,CAAkBH,CAAlB,EAAqB4G,KAA3C,CAAL,EAAsD;AAAE,aAAO,KAAP;AAAO;AAAK;;AACtG,SAAO,IAAP;AACF,E,CAEA;AACA;AACA;;;eACAuH,yCAAe1M,IAAf,EAAqBC,EAArB,EAAyBsE,IAAzB,EAA+BY,KAA/B,EAAsC;AACpC,MAAIA,KAAK,IAAI,CAAC,KAAKZ,IAAL,CAAUkI,WAAV,CAAsBtH,KAAtB,CAAd,EAA0C;AAAE,WAAO,KAAP;AAAY;;AACxD7G,MAAIgC,KAAK,GAAG,KAAK2L,cAAL,CAAoBjM,IAApB,EAA0B2M,SAA1B,CAAoCpI,IAApC,CAAZjG;AACAA,MAAI+B,GAAG,GAAGC,KAAK,IAAIA,KAAK,CAAC8L,aAAN,CAAoB,KAAKnN,OAAzB,EAAkCgB,EAAlC,CAAnB3B;AACA,SAAO+B,GAAG,GAAGA,GAAG,CAACmM,QAAP,GAAkB,KAA5B;AACF,E,CAEA;AACA;AACA;AACA;AACA;;;eACAI,+BAAU1L,KAAV,EAAiB;AACf,MAAIA,KAAK,CAACjC,OAAN,CAAcC,IAAlB,EAAsB;AAAE,WAAO,KAAKgI,UAAL,CAAgB,KAAK1I,UAArB,EAAiC,KAAKA,UAAtC,EAAkD0C,KAAK,CAACjC,OAAxD,CAAP;AAAuE,GAA/F,MACJ;AAAS,WAAO,KAAKsF,IAAL,CAAUyD,iBAAV,CAA4B9G,KAAK,CAACqD,IAAlC,CAAP;AAA8C;AACrD,E,CAEA;AACA;AACA;;;eACAsI,yBAAQ;AACN,MAAI,CAAC,KAAKtI,IAAL,CAAUuE,YAAV,CAAuB,KAAK7J,OAA5B,CAAL,EACJ;AAAM,UAAM,IAAIuD,UAAJ,CAAc,8BAA6B,KAAK+B,IAAL,CAAUS,IAAvC,GAA2C,IAA3C,GAAgD,KAAK/F,OAAL,CAAaiE,QAAb,GAAwBpC,KAAxB,CAA8B,CAA9B,EAAiC,EAAjC,CAA9D,CAAN;AAA2G;;AAC7GxC,MAAI0D,IAAI,GAAGsC,IAAI,CAACiB,IAAhBjH;;AACA,OAAKA,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK4G,KAAL,CAAWtF,MAA/B,EAAuCtB,CAAC,EAAxC,EAA0C;AAAEyD,QAAI,GAAG,KAAKmD,KAAL,CAAW5G,CAAX,EAAciG,QAAd,CAAuBxC,IAAvB,CAAP;AAAmC;;AAC/E,MAAI,CAACsC,IAAI,CAACe,OAAL,CAAarD,IAAb,EAAmB,KAAKmD,KAAxB,CAAL,EACJ;AAAM,UAAM,IAAI3C,UAAJ,CAAc,0CAAyC,KAAK+B,IAAL,CAAUS,IAAnD,GAAuD,IAAvD,GAA4D,KAAKG,KAAL,CAAW7B,GAAX,CAAc,UAACwJ,CAAD,EAAC;AAAA,aAAKA,CAAC,CAACvI,IAAF,CAAOS,IAAZ;AAAgB,KAA/B,CAA1E,CAAN;AAAmH;;AACrH,OAAK/F,OAAL,CAAayD,OAAb,CAAoB,UAAC7B,IAAD,EAAC;AAAA,WAAQA,IAAI,CAACgM,KAAL,EAAR;AAAoB,GAAzC;AACF,E,CAEA;AACA;;;eACAxJ,2BAAS;AACP/E,MAAIyG,GAAG,GAAG;AAACR,QAAI,EAAE,KAAKA,IAAL,CAAUS;AAAjB,GAAV1G;;AACA,OAAKA,IAAI2G,CAAT,IAAc,KAAKf,KAAnB,EAA0B;AACxBa,OAAG,CAACb,KAAJ,GAAY,KAAKA,KAAjB;AACA;AACD;;AACD,MAAI,KAAKjF,OAAL,CAAaC,IAAjB,EACJ;AAAM6F,OAAG,CAAC9F,OAAJ,GAAc,KAAKA,OAAL,CAAaoE,MAAb,EAAd;AAAmC;;AACrC,MAAI,KAAK8B,KAAL,CAAWtF,MAAf,EACJ;AAAMkF,OAAG,CAACI,KAAJ,GAAY,KAAKA,KAAL,CAAW7B,GAAX,CAAc,UAACC,CAAD,EAAC;AAAA,aAAKA,CAAC,CAACF,MAAF,EAAL;AAAe,KAA9B,CAAZ;AAA2C;;AAC7C,SAAO0B,GAAP;AACF,E,CAEA;AACA;;;AACAmG,KAAO1H,QAAP,GAAO,kBAASC,MAAT,EAAiByB,IAAjB,EAAuB;AAC5B,MAAI,CAACA,IAAL,EAAS;AAAE,UAAM,IAAI1C,UAAJ,CAAe,iCAAf,CAAN;AAAuD;;AAClElE,MAAI6G,KAAK,GAAG,IAAZ7G;;AACA,MAAI4G,IAAI,CAACC,KAAT,EAAgB;AACd,QAAI,CAACxB,KAAK,CAACC,OAAN,CAAcsB,IAAI,CAACC,KAAnB,CAAL,EAA8B;AAAE,YAAM,IAAI3C,UAAJ,CAAe,qCAAf,CAAN;AAA2D;;AAC3F2C,SAAK,GAAGD,IAAI,CAACC,KAAL,CAAW7B,GAAX,CAAeG,MAAM,CAACsJ,YAAtB,CAAR;AACD;;AACD,MAAI7H,IAAI,CAACX,IAAL,IAAa,MAAjB,EAAyB;AACvB,QAAI,OAAOW,IAAI,CAACnG,IAAZ,IAAoB,QAAxB,EAAgC;AAAE,YAAM,IAAIyD,UAAJ,CAAe,2BAAf,CAAN;AAAiD;;AACnF,WAAOiB,MAAM,CAAC1E,IAAP,CAAYmG,IAAI,CAACnG,IAAjB,EAAuBoG,KAAvB,CAAP;AACD;;AACD7G,MAAIW,OAAO,GAAGa,QAAQ,CAAC0D,QAAT,CAAkBC,MAAlB,EAA0ByB,IAAI,CAACjG,OAA/B,CAAdX;AACA,SAAOmF,MAAM,CAACuJ,QAAP,CAAgB9H,IAAI,CAACX,IAArB,EAA2Ba,MAA3B,CAAkCF,IAAI,CAAChB,KAAvC,EAA8CjF,OAA9C,EAAuDkG,KAAvD,CAAP;AACF,CAbA;;;;AAgBK,IAAM8H,QAAQ;AACnB,oBAAY1I,IAAZ,EAAkBL,KAAlB,EAAyBjF,OAAzB,EAAkCkG,KAAlC,EAAyC;AACvC+H,cAAK,IAALA,EAAM3I,IAAN2I,EAAYhJ,KAAZgJ,EAAmB,IAAnBA,EAAyB/H,KAAzB+H;;AAEA,QAAI,CAACjO,OAAL,EAAY;AAAE,YAAM,IAAIuD,UAAJ,CAAe,kCAAf,CAAN;AAAwD;;AAEtE,SAAKzD,IAAL,GAAYE,OAAZ;AACJ;;;;;;;;;;;;;;AAEAgO,qBAAE/J,QAAF,GAAE,oBAAW;AACT,QAAI,KAAKqB,IAAL,CAAUqC,IAAV,CAAemF,aAAnB,EAAgC;AAAE,aAAO,KAAKxH,IAAL,CAAUqC,IAAV,CAAemF,aAAf,CAA6B,IAA7B,CAAP;AAAyC;;AAC3E,WAAOC,SAAS,CAAC,KAAK7G,KAAN,EAAagI,IAAI,CAACC,SAAL,CAAe,KAAKrO,IAApB,CAAb,CAAhB;AACJ,GAHA;;AAKEiM,uBAAII,WAAJ,CAAI9I,GAAJ,GAAI,YAAc;AAAE,WAAO,KAAKvD,IAAZ;AAAgB,GAApC;;AAEFkO,qBAAExM,WAAF,GAAE,qBAAYT,IAAZ,EAAkBC,EAAlB,EAAsB;AAAE,WAAO,KAAKlB,IAAL,CAAU+B,KAAV,CAAgBd,IAAhB,EAAsBC,EAAtB,CAAP;AAAgC,GAA1D;;AAEE+K,uBAAIpM,QAAJ,CAAI0D,GAAJ,GAAI,YAAW;AAAE,WAAO,KAAKvD,IAAL,CAAUc,MAAjB;AAAuB,GAAxC;;AAEFoN,qBAAE1B,IAAF,GAAE,cAAKpG,KAAL,EAAY;AACV,WAAOA,KAAK,IAAI,KAAKA,KAAd,GAAsB,IAAtB,GAA6B,IAAI8H,QAAJ,CAAa,KAAK1I,IAAlB,EAAwB,KAAKL,KAA7B,EAAoC,KAAKnF,IAAzC,EAA+CoG,KAA/C,CAApC;AACJ,GAFA;;AAIA8H,qBAAE1L,QAAF,GAAE,kBAASxC,IAAT,EAAe;AACb,QAAIA,IAAI,IAAI,KAAKA,IAAjB,EAAqB;AAAE,aAAO,IAAP;AAAW;;AAClC,WAAO,IAAIkO,QAAJ,CAAa,KAAK1I,IAAlB,EAAwB,KAAKL,KAA7B,EAAoCnF,IAApC,EAA0C,KAAKoG,KAA/C,CAAP;AACJ,GAHA;;AAKA8H,qBAAExL,GAAF,GAAE,aAAIzB,IAAJ,EAAcC,EAAd,EAAqC;6BAA7B,GAAG;yBAAK,GAAG,KAAKlB,IAAL,CAAUc;;AAC3B,QAAIG,IAAI,IAAI,CAAR,IAAaC,EAAE,IAAI,KAAKlB,IAAL,CAAUc,MAAjC,EAAuC;AAAE,aAAO,IAAP;AAAW;;AACpD,WAAO,KAAK0B,QAAL,CAAc,KAAKxC,IAAL,CAAU+B,KAAV,CAAgBd,IAAhB,EAAsBC,EAAtB,CAAd,CAAP;AACJ,GAHA;;AAKAgN,qBAAE7K,EAAF,GAAE,YAAGlB,KAAH,EAAU;AACR,WAAO,KAAKrC,UAAL,CAAgBqC,KAAhB,KAA0B,KAAKnC,IAAL,IAAamC,KAAK,CAACnC,IAApD;AACJ,GAFA;;AAIAkO,qBAAE5J,MAAF,GAAE,kBAAS;AACP/E,QAAI+O,IAAI,GAAGH,eAAM7J,MAAN6J,CAAMrH,IAANqH,CAAY,IAAZA,CAAX5O;AACA+O,QAAI,CAACtO,IAAL,GAAY,KAAKA,IAAjB;AACA,WAAOsO,IAAP;AACJ,GAJA;;;;CAtCqB,CAASnC,IAAT,CAAd;;AA6CP,SAASc,SAAT,CAAmB7G,KAAnB,EAA0BqF,GAA1B,EAA+B;AAC7B,OAAKlM,IAAIC,CAAC,GAAG4G,KAAK,CAACtF,MAAN,GAAe,CAA5B,EAA+BtB,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EACF;AAAIiM,OAAG,GAAGrF,KAAK,CAAC5G,CAAD,CAAL,CAASgG,IAAT,CAAcS,IAAd,GAAqB,GAArB,GAA2BwF,GAA3B,GAAiC,GAAvC;AAA0C;;AAC5C,SAAOA,GAAP;AACF,C,CChaA;AACA;AACA;AACA;;;IACa8C,YAAY,GACvB,sBAAYd,QAAZ,EAAsB;AACxB;AACA;AACI,OAAKA,QAAL,GAAgBA,QAAhB;AACA,OAAKxC,IAAL,GAAY,EAAZ;AACA,OAAKuD,SAAL,GAAiB,EAAjB;AACF;;;;;;;;;;;;;;AAEAD,aAAOE,KAAP,GAAO,eAAMC,MAAN,EAAcC,SAAd,EAAyB;AAC9BpP,MAAIqP,MAAM,GAAG,IAAIC,WAAJ,CAAgBH,MAAhB,EAAwBC,SAAxB,CAAbpP;;AACA,MAAIqP,MAAM,CAAC3D,IAAP,IAAe,IAAnB,EAAuB;AAAE,WAAOsD,YAAY,CAAC1L,KAApB;AAAyB;;AAClDtD,MAAIuP,IAAI,GAAGC,SAAS,CAACH,MAAD,CAApBrP;;AACA,MAAIqP,MAAM,CAAC3D,IAAX,EAAe;AAAE2D,UAAM,CAAChI,GAAP,CAAW,0BAAX;AAAsC;;AACvDrH,MAAI4N,KAAK,GAAG6B,GAAG,CAACC,GAAG,CAACH,IAAD,CAAJ,CAAfvP;AACA2P,kBAAgB,CAAC/B,KAAD,EAAQyB,MAAR,CAAhB;AACA,SAAOzB,KAAP;AACF,CARA,C,CAUA;AACA;AACA;;;uBACAS,+BAAUpI,IAAV,EAAgB;AACd,OAAKjG,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKyL,IAAL,CAAUnK,MAA9B,EAAsCtB,CAAC,IAAI,CAA3C,EACJ;AAAM,QAAI,KAAKyL,IAAL,CAAUzL,CAAV,KAAgBgG,IAApB,EAAwB;AAAE,aAAO,KAAKyF,IAAL,CAAUzL,CAAC,GAAG,CAAd,CAAP;AAAsB;AAAC;;AACnD,SAAO,IAAP;AACF,E,CAEA;AACA;AACA;;;uBACA6N,uCAAc8B,IAAd,EAAoB5N,KAApB,EAA+BD,GAA/B,EAAsD;6BAA7B,GAAG;yBAAM,GAAG6N,IAAI,CAAC1P;AACxCF,MAAI2E,GAAG,GAAG,IAAV3E;;AACA,OAAKA,IAAIC,CAAC,GAAG+B,KAAb,EAAoB2C,GAAG,IAAI1E,CAAC,GAAG8B,GAA/B,EAAoC9B,CAAC,EAArC,EACJ;AAAM0E,OAAG,GAAGA,GAAG,CAAC0J,SAAJ,CAAcuB,IAAI,CAACxP,KAAL,CAAWH,CAAX,EAAcgG,IAA5B,CAAN;AAAuC;;AACzC,SAAOtB,GAAP;AACF;;AAEAZ,qBAAIgI,aAAJhI,CAAIC,GAAJD,GAAI,YAAgB;AAClB/D,MAAI+C,KAAK,GAAG,KAAK2I,IAAL,CAAU,CAAV,CAAZ1L;AACA,SAAO+C,KAAK,GAAGA,KAAK,CAAC0I,QAAT,GAAoB,KAAhC;AACF,CAHA1H,C,CAKA;AACA;AACA;;;AACAA,qBAAI8L,WAAJ9L,CAAIC,GAAJD,GAAI,YAAc;AAChB,OAAK/D,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKyL,IAAL,CAAUnK,MAA9B,EAAsCtB,CAAC,IAAI,CAA3C,EAA8C;AAC5CD,QAAIiG,IAAI,GAAG,KAAKyF,IAAL,CAAUzL,CAAV,CAAXD;;AACA,QAAI,EAAEiG,IAAI,CAACzF,MAAL,IAAeyF,IAAI,CAAC6J,gBAAL,EAAjB,CAAJ,EAA6C;AAAE,aAAO7J,IAAP;AAAW;AAC3D;AACH,CALAlC;;uBAOAgM,iCAAWnN,KAAX,EAAkB;AAChB,OAAK5C,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKyL,IAAL,CAAUnK,MAA9B,EAAsCtB,CAAC,IAAI,CAA3C,EACJ;AAAM,SAAKD,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkC,KAAK,CAAC8I,IAAN,CAAWnK,MAA/B,EAAuCb,CAAC,IAAI,CAA5C,EACN;AAAQ,UAAI,KAAKgL,IAAL,CAAUzL,CAAV,KAAgB2C,KAAK,CAAC8I,IAAN,CAAWhL,CAAX,CAApB,EAAiC;AAAE,eAAO,IAAP;AAAO;AAAA;AAAI;;AAClD,SAAO,KAAP;AACF,E,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;uBACAsP,iCAAW7E,KAAX,EAAkB8E,KAAlB,EAAiC9F,UAAjC,EAAiD;6BAA1B,GAAG;uCAAiB,GAAG;AAC5CnK,MAAIkQ,IAAI,GAAG,CAAC,IAAD,CAAXlQ;;AACA,WAASmQ,MAAT,CAAgBvC,KAAhB,EAAuBwC,KAAvB,EAA8B;AAC5BpQ,QAAIqQ,QAAQ,GAAGzC,KAAK,CAACE,aAAN,CAAoB3C,KAApB,EAA2BhB,UAA3B,CAAfnK;;AACA,QAAIqQ,QAAQ,KAAK,CAACJ,KAAD,IAAUI,QAAQ,CAACnC,QAAxB,CAAZ,EACN;AAAQ,aAAO1M,QAAQ,CAACE,IAAT,CAAc0O,KAAK,CAACpL,GAAN,CAAS,UAACsL,EAAD,EAAC;AAAA,eAAMA,EAAE,CAACC,aAAH,EAAN;AAAwB,OAAlC,CAAd,CAAP;AAAyD;;AAE3D,SAAKvQ,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2N,KAAK,CAAClC,IAAN,CAAWnK,MAA/B,EAAuCtB,CAAC,IAAI,CAA5C,EAA+C;AAC7CD,UAAIiG,IAAI,GAAG2H,KAAK,CAAClC,IAAN,CAAWzL,CAAX,CAAXD;AAAAA,UAA0B0L,IAAI,GAAGkC,KAAK,CAAClC,IAAN,CAAWzL,CAAC,GAAG,CAAf,CAAjCD;;AACA,UAAI,EAAEiG,IAAI,CAACzF,MAAL,IAAeyF,IAAI,CAAC6J,gBAAL,EAAjB,KAA6CI,IAAI,CAACM,OAAL,CAAa9E,IAAb,KAAsB,CAAC,CAAxE,EAA2E;AACzEwE,YAAI,CAAChN,IAAL,CAAUwI,IAAV;AACA1L,YAAIiE,KAAK,GAAGkM,MAAM,CAACzE,IAAD,EAAO0E,KAAK,CAACxM,MAAN,CAAaqC,IAAb,CAAP,CAAlBjG;;AACA,YAAIiE,KAAJ,EAAS;AAAE,iBAAOA,KAAP;AAAY;AACxB;AACF;AACF;;AAED,SAAOkM,MAAM,CAAC,IAAD,EAAO,EAAP,CAAb;AACF,E,CAEA;AACA;AACA;AACA;AACA;;;uBACAM,qCAAa1G,MAAb,EAAqB;AACnB,OAAK/J,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKgP,SAAL,CAAe1N,MAAnC,EAA2CtB,CAAC,IAAI,CAAhD,EACJ;AAAM,QAAI,KAAKgP,SAAL,CAAehP,CAAf,KAAqB8J,MAAzB,EAA+B;AAAE,aAAO,KAAKkF,SAAL,CAAehP,CAAC,GAAG,CAAnB,CAAP;AAA2B;AAAC;;AAC/DD,MAAI0Q,QAAQ,GAAG,KAAKC,eAAL,CAAqB5G,MAArB,CAAf/J;AACA,OAAKiP,SAAL,CAAe/L,IAAf,CAAoB6G,MAApB,EAA4B2G,QAA5B;AACA,SAAOA,QAAP;AACF;;uBAEAC,2CAAgB5G,MAAhB,EAAwB;AACtB/J,MAAIkQ,IAAI,GAAGxI,MAAM,CAACZ,MAAP,CAAc,IAAd,CAAX9G;AAAAA,MAAgC4Q,MAAM,GAAG,CAAC;AAAChD,SAAK,EAAE,IAAR;AAAc3H,QAAI,EAAE,IAApB;AAA0B4K,OAAG,EAAE;AAA/B,GAAD,CAAzC7Q;;AACA,SAAO4Q,MAAM,CAACrP,MAAd,EAAsB;AACpBvB,QAAIyD,OAAO,GAAGmN,MAAM,CAACE,KAAP,EAAd9Q;AAAAA,QAA8B4N,KAAK,GAAGnK,OAAO,CAACmK,KAA9C5N;;AACA,QAAI4N,KAAK,CAACS,SAAN,CAAgBtE,MAAhB,CAAJ,EAA6B;AAC3B/J,UAAIoD,MAAM,GAAG,EAAbpD;;AACA,WAAKA,IAAIyG,GAAG,GAAGhD,OAAf,EAAwBgD,GAAG,CAACR,IAA5B,EAAkCQ,GAAG,GAAGA,GAAG,CAACoK,GAA5C,EACR;AAAUzN,cAAM,CAACF,IAAP,CAAYuD,GAAG,CAACR,IAAhB;AAAqB;;AACvB,aAAO7C,MAAM,CAAC2N,OAAP,EAAP;AACD;;AACD,SAAK/Q,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2N,KAAK,CAAClC,IAAN,CAAWnK,MAA/B,EAAuCtB,CAAC,IAAI,CAA5C,EAA+C;AAC7CD,UAAIiG,IAAI,GAAG2H,KAAK,CAAClC,IAAN,CAAWzL,CAAX,CAAXD;;AACA,UAAI,CAACiG,IAAI,CAACxD,MAAN,IAAgB,CAACwD,IAAI,CAAC6J,gBAAL,EAAjB,IAA4C,EAAE7J,IAAI,CAACS,IAAL,IAAawJ,IAAf,CAA5C,KAAqE,CAACzM,OAAO,CAACwC,IAAT,IAAiB2H,KAAK,CAAClC,IAAN,CAAWzL,CAAC,GAAG,CAAf,EAAkBiO,QAAxG,CAAJ,EAAuH;AACrH0C,cAAM,CAAC1N,IAAP,CAAY;AAAC0K,eAAK,EAAE3H,IAAI,CAAC4H,YAAb;AAAyB5H,gBAAEA,IAA3B;AAAiC4K,aAAG,EAAEpN;AAAtC,SAAZ;AACAyM,YAAI,CAACjK,IAAI,CAACS,IAAN,CAAJ,GAAkB,IAAlB;AACD;AACF;AACF;AACH,E,CAEA;AACA;AACA;;;AACA3C,qBAAIiN,SAAJjN,CAAIC,GAAJD,GAAI,YAAY;AACd,SAAO,KAAK2H,IAAL,CAAUnK,MAAV,IAAoB,CAA3B;AACF,CAFAwC,C,CAIA;AACA;AACA;;;uBACAkN,qBAAKhM,CAAL,EAAQ;AACNjF,MAAIC,CAAC,GAAGgF,CAAC,IAAI,CAAbjF;;AACA,MAAIC,CAAC,IAAI,KAAKyL,IAAL,CAAUnK,MAAnB,EAAyB;AAAE,UAAM,IAAI2C,UAAJ,CAAc,gBAAee,CAAf,GAAgB,+BAA9B,CAAN;AAAoE;;AAC/F,SAAO;AAACgB,QAAI,EAAE,KAAKyF,IAAL,CAAUzL,CAAV,CAAP;AAAqByL,QAAI,EAAE,KAAKA,IAAL,CAAUzL,CAAC,GAAG,CAAd;AAA3B,GAAP;AACF;;uBAEA2E,+BAAW;AACT5E,MAAIkQ,IAAI,GAAG,EAAXlQ;;AACA,WAASkR,IAAT,CAAc1C,CAAd,EAAiB;AACf0B,QAAI,CAAChN,IAAL,CAAUsL,CAAV;;AACA,SAAKxO,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuO,CAAC,CAAC9C,IAAF,CAAOnK,MAA3B,EAAmCtB,CAAC,IAAI,CAAxC,EACN;AAAQ,UAAIiQ,IAAI,CAACM,OAAL,CAAahC,CAAC,CAAC9C,IAAF,CAAOzL,CAAP,CAAb,KAA2B,CAAC,CAAhC,EAAiC;AAAEiR,YAAI,CAAC1C,CAAC,CAAC9C,IAAF,CAAOzL,CAAP,CAAD,CAAJ;AAAc;AAAC;AACrD;;AACDiR,MAAI,CAAC,IAAD,CAAJ;AACA,SAAOhB,IAAI,CAAClL,GAAL,CAAQ,UAAEwJ,CAAF,EAAKvO,CAAL,EAAW;AACxBD,QAAImR,GAAG,GAAGlR,CAAC,IAAIuO,CAAC,CAACN,QAAF,GAAa,GAAb,GAAmB,GAAvB,CAAD,GAA+B,GAAzClO;;AACA,SAAKA,IAAIC,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGuO,CAAC,CAAC9C,IAAF,CAAOnK,MAA3B,EAAmCtB,GAAC,IAAI,CAAxC,EACN;AAAQkR,SAAG,IAAI,CAAClR,GAAC,GAAG,IAAH,GAAU,EAAZ,IAAkBuO,CAAC,CAAC9C,IAAF,CAAOzL,GAAP,EAAUyG,IAA5B,GAAmC,IAAnC,GAA0CwJ,IAAI,CAACM,OAAL,CAAahC,CAAC,CAAC9C,IAAF,CAAOzL,GAAC,GAAG,CAAX,CAAb,CAAjD;AAA4E;;AAC9E,WAAOkR,GAAP;AACD,GALM,EAKJrM,IALI,CAKC,IALD,CAAP;AAMF;;;AAGFkK,YAAY,CAAC1L,KAAb,GAAqB,IAAI0L,YAAJ,CAAiB,IAAjB,CAArB;;AAEA,IAAMM,WAAW,GACf,qBAAYH,MAAZ,EAAoBC,SAApB,EAA+B;AAC7B,OAAKD,MAAL,GAAcA,MAAd;AACA,OAAKC,SAAL,GAAiBA,SAAjB;AACA,OAAKgC,MAAL,GAAc,IAAd;AACA,OAAKrR,GAAL,GAAW,CAAX;AACA,OAAKsR,MAAL,GAAclC,MAAM,CAACmC,KAAP,CAAa,gBAAb,CAAd;;AACA,MAAI,KAAKD,MAAL,CAAY,KAAKA,MAAL,CAAY9P,MAAZ,GAAqB,CAAjC,KAAuC,EAA3C,EAA6C;AAAE,SAAK8P,MAAL,CAAYE,GAAZ;AAAiB;;AAChE,MAAI,KAAKF,MAAL,CAAY,CAAZ,KAAkB,EAAtB,EAAwB;AAAE,SAAKA,MAAL,CAAYP,KAAZ;AAAmB;AAC/C,CATF;;;;;;;;AAWEpE,uBAAIhB,IAAJgB,CAAI1I,GAAJ0I,GAAI,YAAO;AAAE,SAAO,KAAK2E,MAAL,CAAY,KAAKtR,GAAjB,CAAP;AAA4B,CAAzC2M;;sBAEA8E,mBAAIC,GAAJ,EAAS;AAAE,SAAO,KAAK/F,IAAL,IAAa+F,GAAb,KAAqB,KAAK1R,GAAL,MAAc,IAAnC,CAAP;AAA+C;;sBAE1DsH,mBAAI6E,GAAJ,EAAS;AAAE,QAAM,IAAIwF,WAAJ,CAAgBxF,GAAG,GAAG,2BAAN,GAAoC,KAAKiD,MAAzC,GAAkD,IAAlE,CAAN;AAA6E;;;;AAG1F,SAASK,SAAT,CAAmBH,MAAnB,EAA2B;AACzBrP,MAAI2R,KAAK,GAAG,EAAZ3R;;AACA,KAAG;AAAE2R,SAAK,CAACzO,IAAN,CAAW0O,YAAY,CAACvC,MAAD,CAAvB;AAAkC,GAAvC,QACOA,MAAM,CAACmC,GAAP,CAAW,GAAX,CADP;;AAEA,SAAOG,KAAK,CAACpQ,MAAN,IAAgB,CAAhB,GAAoBoQ,KAAK,CAAC,CAAD,CAAzB,GAA+B;AAAC1L,QAAI,EAAE,QAAP;AAAe0L,WAAEA;AAAjB,GAAtC;AACD;;AAED,SAASC,YAAT,CAAsBvC,MAAtB,EAA8B;AAC5BrP,MAAI2R,KAAK,GAAG,EAAZ3R;;AACA,KAAG;AAAE2R,SAAK,CAACzO,IAAN,CAAW2O,kBAAkB,CAACxC,MAAD,CAA7B;AAAwC,GAA7C,QACOA,MAAM,CAAC3D,IAAP,IAAe2D,MAAM,CAAC3D,IAAP,IAAe,GAA9B,IAAqC2D,MAAM,CAAC3D,IAAP,IAAe,GAD3D;;AAEA,SAAOiG,KAAK,CAACpQ,MAAN,IAAgB,CAAhB,GAAoBoQ,KAAK,CAAC,CAAD,CAAzB,GAA+B;AAAC1L,QAAI,EAAE,KAAP;AAAY0L,WAAEA;AAAd,GAAtC;AACD;;AAED,SAASE,kBAAT,CAA4BxC,MAA5B,EAAoC;AAClCrP,MAAIuP,IAAI,GAAGuC,aAAa,CAACzC,MAAD,CAAxBrP;;AACA,WAAS;AACP,QAAIqP,MAAM,CAACmC,GAAP,CAAW,GAAX,CAAJ,EACJ;AAAMjC,UAAI,GAAG;AAACtJ,YAAI,EAAE,MAAP;AAAasJ,cAAEA;AAAf,OAAP;AAA2B,KAD7B,MAEK,IAAIF,MAAM,CAACmC,GAAP,CAAW,GAAX,CAAJ,EACT;AAAMjC,UAAI,GAAG;AAACtJ,YAAI,EAAE,MAAP;AAAasJ,cAAEA;AAAf,OAAP;AAA2B,KADxB,MAEA,IAAIF,MAAM,CAACmC,GAAP,CAAW,GAAX,CAAJ,EACT;AAAMjC,UAAI,GAAG;AAACtJ,YAAI,EAAE,KAAP;AAAYsJ,cAAEA;AAAd,OAAP;AAA0B,KADvB,MAEA,IAAIF,MAAM,CAACmC,GAAP,CAAW,GAAX,CAAJ,EACT;AAAMjC,UAAI,GAAGwC,cAAc,CAAC1C,MAAD,EAASE,IAAT,CAArB;AAAmC,KADhC,MAET;AAAS;AAAK;AACX;;AACD,SAAOA,IAAP;AACD;;AAED,SAASyC,QAAT,CAAkB3C,MAAlB,EAA0B;AACxB,MAAI,KAAK4C,IAAL,CAAU5C,MAAM,CAAC3D,IAAjB,CAAJ,EAA0B;AAAE2D,UAAM,CAAChI,GAAP,CAAW,2BAA2BgI,MAAM,CAAC3D,IAAlC,GAAyC,GAApD;AAAwD;;AACpF1L,MAAIoD,MAAM,GAAG8O,MAAM,CAAC7C,MAAM,CAAC3D,IAAR,CAAnB1L;AACAqP,QAAM,CAACtP,GAAP;AACA,SAAOqD,MAAP;AACD;;AAED,SAAS2O,cAAT,CAAwB1C,MAAxB,EAAgCE,IAAhC,EAAsC;AACpCvP,MAAIsB,GAAG,GAAG0Q,QAAQ,CAAC3C,MAAD,CAAlBrP;AAAAA,MAA4BiC,GAAG,GAAGX,GAAlCtB;;AACA,MAAIqP,MAAM,CAACmC,GAAP,CAAW,GAAX,CAAJ,EAAqB;AACnB,QAAInC,MAAM,CAAC3D,IAAP,IAAe,GAAnB,EAAsB;AAAEzJ,SAAG,GAAG+P,QAAQ,CAAC3C,MAAD,CAAd;AAAsB,KAA9C,MACJ;AAASpN,SAAG,GAAG,CAAC,CAAP;AAAQ;AACd;;AACD,MAAI,CAACoN,MAAM,CAACmC,GAAP,CAAW,GAAX,CAAL,EAAoB;AAAEnC,UAAM,CAAChI,GAAP,CAAW,uBAAX;AAAmC;;AACzD,SAAO;AAACpB,QAAI,EAAE,OAAP;AAAc3E,SAAEA,GAAhB;AAAmBW,SAAEA,GAArB;AAAwBsN,UAAEA;AAA1B,GAAP;AACD;;AAED,SAAS4C,WAAT,CAAqB9C,MAArB,EAA6B3I,IAA7B,EAAmC;AACjC1G,MAAIoQ,KAAK,GAAGf,MAAM,CAACD,SAAnBpP;AAAAA,MAA8BiG,IAAI,GAAGmK,KAAK,CAAC1J,IAAD,CAA1C1G;;AACA,MAAIiG,IAAJ,EAAQ;AAAE,WAAO,CAACA,IAAD,CAAP;AAAa;;AACvBjG,MAAIoD,MAAM,GAAG,EAAbpD;;AACA,OAAKA,IAAIoS,QAAT,IAAqBhC,KAArB,EAA4B;AAC1BpQ,QAAIiG,MAAI,GAAGmK,KAAK,CAACgC,QAAD,CAAhBpS;;AACA,QAAIiG,MAAI,CAACoM,MAALpM,CAAYuK,OAAZvK,CAAoBS,IAApBT,IAA4B,CAAC,CAAjC,EAAkC;AAAE7C,YAAM,CAACF,IAAP,CAAY+C,MAAZ;AAAiB;AACtD;;AACD,MAAI7C,MAAM,CAAC7B,MAAP,IAAiB,CAArB,EAAsB;AAAE8N,UAAM,CAAChI,GAAP,CAAW,4BAA4BX,IAA5B,GAAmC,SAA9C;AAAwD;;AAChF,SAAOtD,MAAP;AACD;;AAED,SAAS0O,aAAT,CAAuBzC,MAAvB,EAA+B;AAC7B,MAAIA,MAAM,CAACmC,GAAP,CAAW,GAAX,CAAJ,EAAqB;AACnBxR,QAAIuP,IAAI,GAAGC,SAAS,CAACH,MAAD,CAApBrP;;AACA,QAAI,CAACqP,MAAM,CAACmC,GAAP,CAAW,GAAX,CAAL,EAAoB;AAAEnC,YAAM,CAAChI,GAAP,CAAW,uBAAX;AAAmC;;AACzD,WAAOkI,IAAP;AACD,GAJD,MAIO,IAAI,CAAC,KAAK0C,IAAL,CAAU5C,MAAM,CAAC3D,IAAjB,CAAL,EAA6B;AAClC1L,QAAI2R,KAAK,GAAGQ,WAAW,CAAC9C,MAAD,EAASA,MAAM,CAAC3D,IAAhB,CAAX,CAAiC1G,GAAjC,CAAoC,UAACiB,IAAD,EAAS;AACvD,UAAIoJ,MAAM,CAAC+B,MAAP,IAAiB,IAArB,EAAyB;AAAE/B,cAAM,CAAC+B,MAAP,GAAgBnL,IAAI,CAACwF,QAArB;AAA6B,OAAxD,MACK,IAAI4D,MAAM,CAAC+B,MAAP,IAAiBnL,IAAI,CAACwF,QAA1B,EAAkC;AAAE4D,cAAM,CAAChI,GAAP,CAAW,iCAAX;AAA6C;;AACtF,aAAO;AAACpB,YAAI,EAAE,MAAP;AAAeb,aAAK,EAAEa;AAAtB,OAAP;AACD,KAJW,CAAZjG;AAKAqP,UAAM,CAACtP,GAAP;AACA,WAAO4R,KAAK,CAACpQ,MAAN,IAAgB,CAAhB,GAAoBoQ,KAAK,CAAC,CAAD,CAAzB,GAA+B;AAAC1L,UAAI,EAAE,QAAP;AAAe0L,aAAEA;AAAjB,KAAtC;AACD,GARM,MAQA;AACLtC,UAAM,CAAChI,GAAP,CAAW,uBAAuBgI,MAAM,CAAC3D,IAA9B,GAAqC,GAAhD;AACD;AACF,C,CAED;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASgE,GAAT,CAAaH,IAAb,EAAmB;AACjBvP,MAAI0P,GAAG,GAAG,CAAC,EAAD,CAAV1P;AACAsS,SAAO,CAACC,OAAO,CAAChD,IAAD,EAAO,CAAP,CAAR,EAAmBhN,IAAI,EAAvB,CAAP;AACA,SAAOmN,GAAP;;AAEA,WAASnN,IAAT,GAAgB;AAAE,WAAOmN,GAAG,CAACxM,IAAJ,CAAS,EAAT,IAAe,CAAtB;AAAyB;;AAC3C,WAAS+N,IAAT,CAAcvP,IAAd,EAAoBC,EAApB,EAAwB6Q,IAAxB,EAA8B;AAC5BxS,QAAIiR,IAAI,GAAG;AAAAuB,YAACA,IAAD;AAAK7Q,UAAEA;AAAP,KAAX3B;AACA0P,OAAG,CAAChO,IAAD,CAAH,CAAUwB,IAAV,CAAe+N,IAAf;AACA,WAAOA,IAAP;AACD;;AACD,WAASqB,OAAT,CAAiBG,KAAjB,EAAwB9Q,EAAxB,EAA4B;AAAE8Q,SAAK,CAACrO,OAAN,CAAa,UAAC6M,IAAD,EAAC;AAAA,aAAQA,IAAI,CAACtP,EAAL,GAAUA,EAAlB;AAAoB,KAAlC;AAAqC;;AAEnE,WAAS4Q,OAAT,CAAiBhD,IAAjB,EAAuB7N,IAAvB,EAA6B;AAC3B,QAAI6N,IAAI,CAACtJ,IAAL,IAAa,QAAjB,EAA2B;AACzB,aAAOsJ,IAAI,CAACoC,KAAL,CAAWe,MAAX,CAAiB,UAAEvB,GAAF,EAAO5B,IAAP,EAAW;AAAA,eAAK4B,GAAG,CAACvN,MAAJ,CAAW2O,OAAO,CAAChD,IAAD,EAAO7N,IAAP,CAAlB,CAAL;AAAoC,OAAhE,EAAkE,EAAlE,CAAP;AACD,KAFD,MAEO,IAAI6N,IAAI,CAACtJ,IAAL,IAAa,KAAjB,EAAwB;AAC7B,WAAKjG,IAAIC,CAAC,GAAG,CAAb,GAAiBA,CAAC,EAAlB,EAAsB;AACpBD,YAAI0L,IAAI,GAAG6G,OAAO,CAAChD,IAAI,CAACoC,KAAL,CAAW1R,CAAX,CAAD,EAAgByB,IAAhB,CAAlB1B;;AACA,YAAIC,CAAC,IAAIsP,IAAI,CAACoC,KAAL,CAAWpQ,MAAX,GAAoB,CAA7B,EAA8B;AAAE,iBAAOmK,IAAP;AAAW;;AAC3C4G,eAAO,CAAC5G,IAAD,EAAOhK,IAAI,GAAGa,IAAI,EAAlB,CAAP;AACD;AACF,KANM,MAMA,IAAIgN,IAAI,CAACtJ,IAAL,IAAa,MAAjB,EAAyB;AAC9BjG,UAAI2S,IAAI,GAAGpQ,IAAI,EAAfvC;AACAiR,UAAI,CAACvP,IAAD,EAAOiR,IAAP,CAAJ;AACAL,aAAO,CAACC,OAAO,CAAChD,IAAI,CAACA,IAAN,EAAYoD,IAAZ,CAAR,EAA2BA,IAA3B,CAAP;AACA,aAAO,CAAC1B,IAAI,CAAC0B,IAAD,CAAL,CAAP;AACD,KALM,MAKA,IAAIpD,IAAI,CAACtJ,IAAL,IAAa,MAAjB,EAAyB;AAC9BjG,UAAI2S,MAAI,GAAGpQ,IAAI,EAAfvC;AACAsS,aAAO,CAACC,OAAO,CAAChD,IAAI,CAACA,IAAN,EAAY7N,IAAZ,CAAR,EAA2BiR,MAA3B,CAAP;AACAL,aAAO,CAACC,OAAO,CAAChD,IAAI,CAACA,IAAN,EAAYoD,MAAZ,CAAR,EAA2BA,MAA3B,CAAP;AACA,aAAO,CAAC1B,IAAI,CAAC0B,MAAD,CAAL,CAAP;AACD,KALM,MAKA,IAAIpD,IAAI,CAACtJ,IAAL,IAAa,KAAjB,EAAwB;AAC7B,aAAO,CAACgL,IAAI,CAACvP,IAAD,CAAL,EAAakC,MAAb,CAAoB2O,OAAO,CAAChD,IAAI,CAACA,IAAN,EAAY7N,IAAZ,CAA3B,CAAP;AACD,KAFM,MAEA,IAAI6N,IAAI,CAACtJ,IAAL,IAAa,OAAjB,EAA0B;AAC/BjG,UAAI2E,GAAG,GAAGjD,IAAV1B;;AACA,WAAKA,IAAIC,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGsP,IAAI,CAACjO,GAAzB,EAA8BrB,GAAC,EAA/B,EAAmC;AACjCD,YAAI0L,MAAI,GAAGnJ,IAAI,EAAfvC;AACAsS,eAAO,CAACC,OAAO,CAAChD,IAAI,CAACA,IAAN,EAAY5K,GAAZ,CAAR,EAA0B+G,MAA1B,CAAP;AACA/G,WAAG,GAAG+G,MAAN;AACD;;AACD,UAAI6D,IAAI,CAACtN,GAAL,IAAY,CAAC,CAAjB,EAAoB;AAClBqQ,eAAO,CAACC,OAAO,CAAChD,IAAI,CAACA,IAAN,EAAY5K,GAAZ,CAAR,EAA0BA,GAA1B,CAAP;AACD,OAFD,MAEO;AACL,aAAK3E,IAAIC,GAAC,GAAGsP,IAAI,CAACjO,GAAlB,EAAuBrB,GAAC,GAAGsP,IAAI,CAACtN,GAAhC,EAAqChC,GAAC,EAAtC,EAA0C;AACxCD,cAAI0L,MAAI,GAAGnJ,IAAI,EAAfvC;AACAiR,cAAI,CAACtM,GAAD,EAAM+G,MAAN,CAAJ;AACA4G,iBAAO,CAACC,OAAO,CAAChD,IAAI,CAACA,IAAN,EAAY5K,GAAZ,CAAR,EAA0B+G,MAA1B,CAAP;AACA/G,aAAG,GAAG+G,MAAN;AACD;AACF;;AACD,aAAO,CAACuF,IAAI,CAACtM,GAAD,CAAL,CAAP;AACD,KAlBM,MAkBA,IAAI4K,IAAI,CAACtJ,IAAL,IAAa,MAAjB,EAAyB;AAC9B,aAAO,CAACgL,IAAI,CAACvP,IAAD,EAAO,IAAP,EAAa6N,IAAI,CAACnK,KAAlB,CAAL,CAAP;AACD;AACF;AACF;;AAED,SAASwN,GAAT,CAAa/S,CAAb,EAAgBC,CAAhB,EAAmB;AAAE,SAAOA,CAAC,GAAGD,CAAX;AAAc,C,CAEnC;AACA;AACA;;;AACA,SAASgT,QAAT,CAAkBnD,GAAlB,EAAuBnN,IAAvB,EAA6B;AAC3BvC,MAAIoD,MAAM,GAAG,EAAbpD;AACAkR,MAAI,CAAC3O,IAAD,CAAJ;AACA,SAAOa,MAAM,CAAC8D,IAAP,CAAY0L,GAAZ,CAAP;;AAEA,WAAS1B,IAAT,CAAc3O,IAAd,EAAoB;AAClBvC,QAAIyS,KAAK,GAAG/C,GAAG,CAACnN,IAAD,CAAfvC;;AACA,QAAIyS,KAAK,CAAClR,MAAN,IAAgB,CAAhB,IAAqB,CAACkR,KAAK,CAAC,CAAD,CAAL,CAASD,IAAnC,EAAuC;AAAE,aAAOtB,IAAI,CAACuB,KAAK,CAAC,CAAD,CAAL,CAAS9Q,EAAV,CAAX;AAAwB;;AACjEyB,UAAM,CAACF,IAAP,CAAYX,IAAZ;;AACA,SAAKvC,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwS,KAAK,CAAClR,MAA1B,EAAkCtB,CAAC,EAAnC,EAAuC;AAC3C,aAAoB,GAAGwS,KAAK,CAACxS,CAAD,CAA5B;AAAW;AAAM;;AACX,UAAI,CAACuS,IAAD,IAASpP,MAAM,CAACoN,OAAP,CAAe7O,EAAf,KAAsB,CAAC,CAApC,EAAqC;AAAEuP,YAAI,CAACvP,EAAD,CAAJ;AAAQ;AAChD;AACF;AACF,C,CAED;AACA;AACA;AACA;;;AACA,SAAS8N,GAAT,CAAaC,GAAb,EAAkB;AAChB1P,MAAI8S,OAAO,GAAGpL,MAAM,CAACZ,MAAP,CAAc,IAAd,CAAd9G;AACA,SAAO+S,OAAO,CAACF,QAAQ,CAACnD,GAAD,EAAM,CAAN,CAAT,CAAd;;AAEA,WAASqD,OAAT,CAAiBC,MAAjB,EAAyB;AACvBhT,QAAImR,GAAG,GAAG,EAAVnR;AACAgT,UAAM,CAAC5O,OAAP,CAAc,UAAC7B,IAAD,EAAS;AACrBmN,SAAG,CAACnN,IAAD,CAAH,CAAU6B,OAAV,CAAiB,eAAiB;;;;AAChC,YAAI,CAACoO,IAAL,EAAS;AAAE;AAAM;;AACjBxS,YAAIiT,KAAK,GAAG9B,GAAG,CAACX,OAAJ,CAAYgC,IAAZ,CAAZxS;AAAAA,YAA+BmG,GAAG,GAAG8M,KAAK,GAAG,CAAC,CAAT,IAAc9B,GAAG,CAAC8B,KAAK,GAAG,CAAT,CAAtDjT;AACA6S,gBAAQ,CAACnD,GAAD,EAAM/N,EAAN,CAAR,CAAkByC,OAAlB,CAAyB,UAAC7B,IAAD,EAAS;AAChC,cAAI,CAAC4D,GAAL,EAAQ;AAAEgL,eAAG,CAACjO,IAAJ,CAASsP,IAAT,EAAerM,GAAG,GAAG,EAArB;AAAwB;;AAClC,cAAIA,GAAG,CAACqK,OAAJ,CAAYjO,IAAZ,KAAqB,CAAC,CAA1B,EAA2B;AAAE4D,eAAG,CAACjD,IAAJ,CAASX,IAAT;AAAc;AAC5C,SAHD;AAID,OAPD;AAQD,KATD;AAUAvC,QAAIkT,KAAK,GAAGJ,OAAO,CAACE,MAAM,CAAClO,IAAP,CAAY,GAAZ,CAAD,CAAP,GAA4B,IAAIkK,YAAJ,CAAiBgE,MAAM,CAACxC,OAAP,CAAed,GAAG,CAACnO,MAAJ,GAAa,CAA5B,IAAiC,CAAC,CAAnD,CAAxCvB;;AACA,SAAKA,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkR,GAAG,CAAC5P,MAAxB,EAAgCtB,CAAC,IAAI,CAArC,EAAwC;AACtCD,UAAIgT,QAAM,GAAG7B,GAAG,CAAClR,CAAC,GAAG,CAAL,CAAH,CAAWiH,IAAX,CAAgB0L,GAAhB,CAAb5S;AACAkT,WAAK,CAACxH,IAAN,CAAWxI,IAAX,CAAgBiO,GAAG,CAAClR,CAAD,CAAnB,EAAwB6S,OAAO,CAACE,QAAM,CAAClO,IAAPkO,CAAY,GAAZA,CAAD,CAAP,IAA6BD,OAAO,CAACC,QAAD,CAA5D;AACD;;AACD,WAAOE,KAAP;AACD;AACF;;AAED,SAASvD,gBAAT,CAA0B/B,KAA1B,EAAiCyB,MAAjC,EAAyC;AACvC,OAAKrP,IAAIC,CAAC,GAAG,CAARD,EAAWmT,IAAI,GAAG,CAACvF,KAAD,CAAvB,EAAgC3N,CAAC,GAAGkT,IAAI,CAAC5R,MAAzC,EAAiDtB,CAAC,EAAlD,EAAsD;AACpDD,QAAIkT,KAAK,GAAGC,IAAI,CAAClT,CAAD,CAAhBD;AAAAA,QAAqBoT,IAAI,GAAG,CAACF,KAAK,CAAChF,QAAnClO;AAAAA,QAA6C2F,KAAK,GAAG,EAArD3F;;AACA,SAAKA,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwS,KAAK,CAACxH,IAAN,CAAWnK,MAA/B,EAAuCb,CAAC,IAAI,CAA5C,EAA+C;AAC7CV,UAAIuC,IAAI,GAAG2Q,KAAK,CAACxH,IAAN,CAAWhL,CAAX,CAAXV;AAAAA,UAA0B0L,IAAI,GAAGwH,KAAK,CAACxH,IAAN,CAAWhL,CAAC,GAAG,CAAf,CAAjCV;AACA2F,WAAK,CAACzC,IAAN,CAAWX,IAAI,CAACmE,IAAhB;;AACA,UAAI0M,IAAI,IAAI,EAAE7Q,IAAI,CAAC/B,MAAL,IAAe+B,IAAI,CAACuN,gBAAL,EAAjB,CAAZ,EAAqD;AAAEsD,YAAI,GAAG,KAAP;AAAY;;AACnE,UAAID,IAAI,CAAC3C,OAAL,CAAa9E,IAAb,KAAsB,CAAC,CAA3B,EAA4B;AAAEyH,YAAI,CAACjQ,IAAL,CAAUwI,IAAV;AAAe;AAC9C;;AACD,QAAI0H,IAAJ,EAAQ;AAAE/D,YAAM,CAAChI,GAAP,CAAW,iCAAiC1B,KAAK,CAACb,IAAN,CAAW,IAAX,CAAjC,GAAoD,gFAA/D;AAAgJ;AAC3J;AACH,C,CC7XA;AACA;AACA;AACA;;;AACA,SAASkI,YAAT,CAAsBpH,KAAtB,EAA6B;AAC3B5F,MAAIqT,QAAQ,GAAG3L,MAAM,CAACZ,MAAP,CAAc,IAAd,CAAf9G;;AACA,OAAKA,IAAIsT,QAAT,IAAqB1N,KAArB,EAA4B;AAC1B5F,QAAIuT,IAAI,GAAG3N,KAAK,CAAC0N,QAAD,CAAhBtT;;AACA,QAAI,CAACuT,IAAI,CAACC,UAAV,EAAoB;AAAE,aAAO,IAAP;AAAW;;AACjCH,YAAQ,CAACC,QAAD,CAAR,GAAqBC,IAAI,CAACE,OAA1B;AACD;;AACD,SAAOJ,QAAP;AACD;;AAED,SAASK,YAAT,CAAsB9N,KAAtB,EAA6BR,KAA7B,EAAoC;AAClCpF,MAAI2T,KAAK,GAAGjM,MAAM,CAACZ,MAAP,CAAc,IAAd,CAAZ9G;;AACA,OAAKA,IAAI0G,IAAT,IAAiBd,KAAjB,EAAwB;AACtB5F,QAAI4T,KAAK,GAAGxO,KAAK,IAAIA,KAAK,CAACsB,IAAD,CAA1B1G;;AACA,QAAI4T,KAAK,KAAKC,SAAd,EAAyB;AACvB7T,UAAIuT,IAAI,GAAG3N,KAAK,CAACc,IAAD,CAAhB1G;;AACA,UAAIuT,IAAI,CAACC,UAAT,EAAmB;AAAEI,aAAK,GAAGL,IAAI,CAACE,OAAb;AAAoB,OAAzC,MACN;AAAW,cAAM,IAAIvP,UAAJ,CAAe,qCAAqCwC,IAApD,CAAN;AAA+D;AACrE;;AACDiN,SAAK,CAACjN,IAAD,CAAL,GAAckN,KAAd;AACD;;AACD,SAAOD,KAAP;AACD;;AAED,SAASG,SAAT,CAAmBlO,KAAnB,EAA0B;AACxB5F,MAAIoD,MAAM,GAAGsE,MAAM,CAACZ,MAAP,CAAc,IAAd,CAAb9G;;AACA,MAAI4F,KAAJ,EAAS;AAAE,SAAK5F,IAAI0G,IAAT,IAAiBd,KAAjB,EAAsB;AAAExC,YAAM,CAACsD,IAAD,CAAN,GAAe,IAAIqN,SAAJ,CAAcnO,KAAK,CAACc,IAAD,CAAnB,CAAf;AAAwC;AAAC;;AAC5E,SAAOtD,MAAP;AACD,C,CAED;AACA;AACA;AACA;;;IACa4Q,QAAQ,GACnB,kBAAYtN,IAAZ,EAAkBvB,MAAlB,EAA0BmD,IAA1B,EAAgC;AAClC;AACA;AACI,OAAK5B,IAAL,GAAYA,IAAZ,CAH8B,CAKlC;AACA;;AACI,OAAKvB,MAAL,GAAcA,MAAd,CAP8B,CASlC;AACA;;AACI,OAAKmD,IAAL,GAAYA,IAAZ;AAEA,OAAK+J,MAAL,GAAc/J,IAAI,CAAC2L,KAAL,GAAa3L,IAAI,CAAC2L,KAAL,CAAW3C,KAAX,CAAiB,GAAjB,CAAb,GAAqC,EAAnD;AACA,OAAK1L,KAAL,GAAakO,SAAS,CAACxL,IAAI,CAAC1C,KAAN,CAAtB;AAEA,OAAKoH,YAAL,GAAoBA,YAAY,CAAC,KAAKpH,KAAN,CAAhC,CAhB8B,CAkBlC;AACA;;AACI,OAAKiI,YAAL,GAAoB,IAApB,CApB8B,CAsBlC;AACA;AACA;;AACI,OAAKqG,OAAL,GAAe,IAAf,CAzB8B,CA2BlC;AACA;;AACI,OAAKnI,aAAL,GAAqB,IAArB,CA7B8B,CA+BlC;AACA;;AACI,OAAKrJ,OAAL,GAAe,EAAE4F,IAAI,CAAC8I,MAAL,IAAe1K,IAAI,IAAI,MAAzB,CAAf,CAjC8B,CAmClC;AACA;;AACI,OAAKlG,MAAL,GAAckG,IAAI,IAAI,MAAtB;AACF;;;;;;;;;;;;;;;;;;GAEA;AACA;;AACA3C,qBAAI0H,QAAJ1H,CAAIC,GAAJD,GAAI,YAAW;AAAE,SAAO,CAAC,KAAKrB,OAAb;AAAoB,CAArCqB,C,CAEA;AACA;AACA;;;AACAA,qBAAIwJ,WAAJxJ,CAAIC,GAAJD,GAAI,YAAc;AAAE,SAAO,KAAKrB,OAAL,IAAgB,KAAKqJ,aAA5B;AAAyC,CAA7DhI,C,CAEA;AACA;;;AACAA,qBAAItB,MAAJsB,CAAIC,GAAJD,GAAI,YAAS;AAAE,SAAO,KAAK8J,YAAL,IAAqBmB,YAAY,CAAC1L,KAAzC;AAA8C,CAA7DS,C,CAEA;AACA;AACA;;;AACAA,qBAAIyJ,MAAJzJ,CAAIC,GAAJD,GAAI,YAAS;AAAE,SAAO,KAAKtB,MAAL,IAAe,KAAK6F,IAAL,CAAU6L,IAAhC;AAAoC,CAAnDpQ,C,CAEA;AACA;;;AACAA,qBAAIqQ,UAAJrQ,CAAIC,GAAJD,GAAI,YAAa;AAAE,SAAO,KAAKuE,IAAL,CAAU8L,UAAV,KAAyB,KAAK9L,IAAL,CAAU+L,IAAV,GAAiB,KAAjB,GAAyB,QAAlD,CAAP;AAAkE,CAArFtQ,C,CAEA;AACA;;;mBACA+L,+CAAmB;AACjB,OAAK9P,IAAIiF,CAAT,IAAc,KAAKW,KAAnB,EAAwB;AAAE,QAAI,KAAKA,KAAL,CAAWX,CAAX,EAAcqP,UAAlB,EAA4B;AAAE,aAAO,IAAP;AAAO;AAAI;;AACnE,SAAO,KAAP;AACF;;mBAEA5K,+CAAkB9G,KAAlB,EAAyB;AACvB,SAAO,QAAQA,KAAR,IAAiB,KAAKiL,YAAL,CAAkBkC,UAAlB,CAA6BnN,KAAK,CAACiL,YAAnC,CAAxB;AACF;;mBAEA6F,uCAAa9N,KAAb,EAAoB;AAClB,MAAI,CAACA,KAAD,IAAU,KAAKoH,YAAnB,EAA+B;AAAE,WAAO,KAAKA,YAAZ;AAAwB,GAAzD,MACJ;AAAS,WAAO0G,YAAY,CAAC,KAAK9N,KAAN,EAAaA,KAAb,CAAnB;AAAsC;AAC7C,E,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;mBACAkB,yBAAOlB,KAAP,EAAcjF,OAAd,EAAuBkG,KAAvB,EAA8B;AAC5B,MAAI,KAAKrG,MAAT,EAAe;AAAE,UAAM,IAAI8G,KAAJ,CAAU,4CAAV,CAAN;AAA6D;;AAC9E,SAAO,IAAIsF,IAAJ,CAAS,IAAT,EAAe,KAAK8G,YAAL,CAAkB9N,KAAlB,CAAf,EAAyCpE,QAAQ,CAACE,IAAT,CAAcf,OAAd,CAAzC,EAAiEqF,IAAI,CAACgB,OAAL,CAAaH,KAAb,CAAjE,CAAP;AACF,E,CAEA;AACA;AACA;AACA;;;mBACA0N,uCAAc3O,KAAd,EAAqBjF,OAArB,EAA8BkG,KAA9B,EAAqC;AACnClG,SAAO,GAAGa,QAAQ,CAACE,IAAT,CAAcf,OAAd,CAAV;;AACA,MAAI,CAAC,KAAK6J,YAAL,CAAkB7J,OAAlB,CAAL,EACJ;AAAM,UAAM,IAAIuD,UAAJ,CAAe,8BAA8B,KAAKwC,IAAlD,CAAN;AAA6D;;AAC/D,SAAO,IAAIkG,IAAJ,CAAS,IAAT,EAAe,KAAK8G,YAAL,CAAkB9N,KAAlB,CAAf,EAAyCjF,OAAzC,EAAkDqF,IAAI,CAACgB,OAAL,CAAaH,KAAb,CAAlD,CAAP;AACF,E,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;mBACA0J,uCAAc3K,KAAd,EAAqBjF,OAArB,EAA8BkG,KAA9B,EAAqC;AACnCjB,OAAK,GAAG,KAAK8N,YAAL,CAAkB9N,KAAlB,CAAR;AACAjF,SAAO,GAAGa,QAAQ,CAACE,IAAT,CAAcf,OAAd,CAAV;;AACA,MAAIA,OAAO,CAACC,IAAZ,EAAkB;AAChBZ,QAAIkL,MAAM,GAAG,KAAK2C,YAAL,CAAkBmC,UAAlB,CAA6BrP,OAA7B,CAAbX;;AACA,QAAI,CAACkL,MAAL,EAAW;AAAE,aAAO,IAAP;AAAW;;AACxBvK,WAAO,GAAGuK,MAAM,CAACvI,MAAP,CAAchC,OAAd,CAAV;AACD;;AACDX,MAAImL,KAAK,GAAG,KAAK0C,YAAL,CAAkBC,aAAlB,CAAgCnN,OAAhC,EAAyCqP,UAAzC,CAAoDxO,QAAQ,CAAC8B,KAA7D,EAAoE,IAApE,CAAZtD;;AACA,MAAI,CAACmL,KAAL,EAAU;AAAE,WAAO,IAAP;AAAW;;AACvB,SAAO,IAAIyB,IAAJ,CAAS,IAAT,EAAehH,KAAf,EAAsBjF,OAAO,CAACgC,MAAR,CAAewI,KAAf,CAAtB,EAA6CnF,IAAI,CAACgB,OAAL,CAAaH,KAAb,CAA7C,CAAP;AACF,E,CAEA;AACA;AACA;;;mBACA2D,qCAAa7J,OAAb,EAAsB;AACpBX,MAAIoD,MAAM,GAAG,KAAKyK,YAAL,CAAkBC,aAAlB,CAAgCnN,OAAhC,CAAbX;;AACA,MAAI,CAACoD,MAAD,IAAW,CAACA,MAAM,CAAC8K,QAAvB,EAA+B;AAAE,WAAO,KAAP;AAAY;;AAC7C,OAAKlO,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,OAAO,CAACT,UAA5B,EAAwCD,CAAC,EAAzC,EACJ;AAAM,QAAI,CAAC,KAAKkO,WAAL,CAAiBxN,OAAO,CAACP,KAAR,CAAcH,CAAd,EAAiB4G,KAAlC,CAAL,EAA6C;AAAE,aAAO,KAAP;AAAO;AAAK;;AAC7D,SAAO,IAAP;AACF,E,CAEA;AACA;;;mBACA2N,yCAAeC,QAAf,EAAyB;AACvB,SAAO,KAAKP,OAAL,IAAgB,IAAhB,IAAwB,KAAKA,OAAL,CAAa1D,OAAb,CAAqBiE,QAArB,IAAiC,CAAC,CAAjE;AACF,E,CAEA;AACA;;;mBACAtG,mCAAYtH,KAAZ,EAAmB;AACjB,MAAI,KAAKqN,OAAL,IAAgB,IAApB,EAAwB;AAAE,WAAO,IAAP;AAAW;;AACrC,OAAKlU,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4G,KAAK,CAACtF,MAA1B,EAAkCtB,CAAC,EAAnC,EAAqC;AAAE,QAAI,CAAC,KAAKuU,cAAL,CAAoB3N,KAAK,CAAC5G,CAAD,CAAL,CAASgG,IAA7B,CAAL,EAAuC;AAAE,aAAO,KAAP;AAAO;AAAK;;AAC5F,SAAO,IAAP;AACF,E,CAEA;AACA;;;mBACAyO,qCAAa7N,KAAb,EAAoB;AAClB,MAAI,KAAKqN,OAAL,IAAgB,IAApB,EAAwB;AAAE,WAAOrN,KAAP;AAAY;;AACtC7G,MAAI0D,IAAJ1D;;AACA,OAAKA,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4G,KAAK,CAACtF,MAA1B,EAAkCtB,CAAC,EAAnC,EAAuC;AACrC,QAAI,CAAC,KAAKuU,cAAL,CAAoB3N,KAAK,CAAC5G,CAAD,CAAL,CAASgG,IAA7B,CAAL,EAAyC;AACvC,UAAI,CAACvC,IAAL,EAAS;AAAEA,YAAI,GAAGmD,KAAK,CAACrE,KAAN,CAAY,CAAZ,EAAevC,CAAf,CAAP;AAAwB;AACpC,KAFD,MAEO,IAAIyD,IAAJ,EAAU;AACfA,UAAI,CAACR,IAAL,CAAU2D,KAAK,CAAC5G,CAAD,CAAf;AACD;AACF;;AACD,SAAO,CAACyD,IAAD,GAAQmD,KAAR,GAAgBnD,IAAI,CAACnC,MAAL,GAAcmC,IAAd,GAAqBsC,IAAI,CAAC1C,KAAjD;AACF;;AAEA0Q,SAAOzB,OAAP,GAAO,iBAAQ5M,KAAR,EAAeR,MAAf,EAAuB;AAC5BnF,MAAIoD,MAAM,GAAGsE,MAAM,CAACZ,MAAP,CAAc,IAAd,CAAb9G;AACA2F,OAAK,CAACvB,OAAN,CAAa,UAAEsC,IAAF,EAAQ4B,IAAR,EAAY;AAAA,WAAKlF,MAAM,CAACsD,IAAD,CAAN,GAAe,IAAIsN,QAAJ,CAAatN,IAAb,EAAmBvB,MAAnB,EAA2BmD,IAA3B,CAApB;AAAoD,GAA7E;AAEAtI,MAAI2U,OAAO,GAAGxP,MAAM,CAACmD,IAAP,CAAYsM,OAAZ,IAAuB,KAArC5U;;AACA,MAAI,CAACoD,MAAM,CAACuR,OAAD,CAAX,EAAoB;AAAE,UAAM,IAAIzQ,UAAJ,CAAe,2CAA2CyQ,OAA3C,GAAqD,IAApE,CAAN;AAA+E;;AACrG,MAAI,CAACvR,MAAM,CAAC3C,IAAZ,EAAgB;AAAE,UAAM,IAAIyD,UAAJ,CAAe,kCAAf,CAAN;AAAwD;;AAC1E,OAAKlE,IAAI2G,CAAT,IAAcvD,MAAM,CAAC3C,IAAP,CAAYmF,KAA1B,EAA+B;AAAE,UAAM,IAAI1B,UAAJ,CAAe,+CAAf,CAAN;AAAqE;;AAEtG,SAAOd,MAAP;AACF,CAVA;;mEAaF;;AAEA,IAAM2Q,SAAS,GACb,mBAAYc,OAAZ,EAAqB;AACnB,OAAKrB,UAAL,GAAkB9L,MAAM,CAACD,SAAP,CAAiBqN,cAAjB,CAAgCvN,IAAhC,CAAqCsN,OAArC,EAA8C,SAA9C,CAAlB;AACA,OAAKpB,OAAL,GAAeoB,OAAO,CAACpB,OAAvB;AACF,CAJF;;;;;;;;AAME/G,uBAAI4H,UAAJ5H,CAAI1I,GAAJ0I,GAAI,YAAa;AACf,SAAO,CAAC,KAAK8G,UAAb;AACF,CAFA9G;;sEAKF;AAEA;AACA;AACA;AACA;;IACaqI,QAAQ,GACnB,kBAAYrO,IAAZ,EAAkBJ,IAAlB,EAAwBnB,MAAxB,EAAgCmD,IAAhC,EAAsC;AACxC;AACA;AACI,OAAK5B,IAAL,GAAYA,IAAZ,CAHoC,CAKxC;AACA;;AACI,OAAKvB,MAAL,GAAcA,MAAd,CAPoC,CASxC;AACA;;AACI,OAAKmD,IAAL,GAAYA,IAAZ;AAEA,OAAK1C,KAAL,GAAakO,SAAS,CAACxL,IAAI,CAAC1C,KAAN,CAAtB;AAEA,OAAKU,IAAL,GAAYA,IAAZ;AACA,OAAK0O,QAAL,GAAgB,IAAhB;AACAhV,MAAIqT,QAAQ,GAAGrG,YAAY,CAAC,KAAKpH,KAAN,CAA3B5F;AACA,OAAKiV,QAAL,GAAgB5B,QAAQ,IAAI,IAAIrN,IAAJ,CAAS,IAAT,EAAeqN,QAAf,CAA5B;AACF,E,CAEA;AACA;AACA;AACA;;;mBACAvM,yBAAOlB,KAAP,EAAc;AACZ,MAAI,CAACA,KAAD,IAAU,KAAKqP,QAAnB,EAA2B;AAAE,WAAO,KAAKA,QAAZ;AAAoB;;AACjD,SAAO,IAAIjP,IAAJ,CAAS,IAAT,EAAe0N,YAAY,CAAC,KAAK9N,KAAN,EAAaA,KAAb,CAA3B,CAAP;AACF;;AAEAmP,SAAOxC,OAAP,GAAO,iBAAQ1L,KAAR,EAAe1B,MAAf,EAAuB;AAC5BnF,MAAIoD,MAAM,GAAGsE,MAAM,CAACZ,MAAP,CAAc,IAAd,CAAb9G;AAAAA,MAAkCsG,IAAI,GAAG,CAAzCtG;AACA6G,OAAK,CAACzC,OAAN,CAAa,UAAEsC,IAAF,EAAQ4B,IAAR,EAAY;AAAA,WAAKlF,MAAM,CAACsD,IAAD,CAAN,GAAe,IAAIqO,QAAJ,CAAarO,IAAb,EAAmBJ,IAAI,EAAvB,EAA2BnB,MAA3B,EAAmCmD,IAAnC,CAApB;AAA4D,GAArF;AACA,SAAOlF,MAAP;AACF,CAJA,C,CAMA;AACA;AACA;;;mBACAmD,uCAAcJ,GAAd,EAAmB;AACjB,OAAK,IAAIlG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkG,GAAG,CAAC5E,MAAxB,EAAgCtB,CAAC,EAAjC,EAAmC;AAAE,QAAIkG,GAAG,CAAClG,CAAD,CAAH,CAAOgG,IAAP,IAAe,IAAnB,EAAyB;AAC5DE,SAAG,GAAGA,GAAG,CAAC3D,KAAJ,CAAU,CAAV,EAAavC,CAAb,EAAgB2D,MAAhB,CAAuBuC,GAAG,CAAC3D,KAAJ,CAAUvC,CAAC,GAAG,CAAd,CAAvB,CAAN;AACAA,OAAC;AACP;AAAK;;AACD,SAAOkG,GAAP;AACF,E,CAEA;AACA;;;mBACAK,2BAAQL,GAAR,EAAa;AACX,OAAKnG,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkG,GAAG,CAAC5E,MAAxB,EAAgCtB,CAAC,EAAjC,EACJ;AAAM,QAAIkG,GAAG,CAAClG,CAAD,CAAH,CAAOgG,IAAP,IAAe,IAAnB,EAAuB;AAAE,aAAOE,GAAG,CAAClG,CAAD,CAAV;AAAY;AAAC;AAC1C,E,CAEA;AACA;AACA;;;mBACAoG,6BAASzD,KAAT,EAAgB;AACd,SAAO,KAAKoS,QAAL,CAAcxE,OAAd,CAAsB5N,KAAtB,IAA+B,CAAC,CAAvC;AACF,E,CAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;IACasS,MAAM,GAGjB,gBAAY5M,IAAZ,EAAkB;AACpB;AACA;AACA;AACA;AACA;AACA;AACI,OAAKA,IAAL,GAAY,EAAZ;;AACA,OAAKtI,IAAImV,IAAT,IAAiB7M,IAAjB,EAAqB;AAAE,SAAKA,IAAL,CAAU6M,IAAV,IAAkB7M,IAAI,CAAC6M,IAAD,CAAtB;AAA4B;;AACnD,OAAK7M,IAAL,CAAU3C,KAAV,GAAkByP,UAAU,CAAC1T,IAAX,CAAgB4G,IAAI,CAAC3C,KAArB,CAAlB;AACA,OAAK2C,IAAL,CAAUzB,KAAV,GAAkBuO,UAAU,CAAC1T,IAAX,CAAgB4G,IAAI,CAACzB,KAArB,CAAlB,CAVgB,CAYpB;AACA;;AACI,OAAKlB,KAAL,GAAaqO,QAAQ,CAACzB,OAAT,CAAiB,KAAKjK,IAAL,CAAU3C,KAA3B,EAAkC,IAAlC,CAAb,CAdgB,CAgBpB;AACA;;AACI,OAAKkB,KAAL,GAAakO,QAAQ,CAACxC,OAAT,CAAiB,KAAKjK,IAAL,CAAUzB,KAA3B,EAAkC,IAAlC,CAAb;AAEA7G,MAAIqV,gBAAgB,GAAG3N,MAAM,CAACZ,MAAP,CAAc,IAAd,CAAvB9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AAI,CAAC4I,EAAL,EAAO;AAAE,YAAM,IAAInE,WAAJ,CAAgB,yBAAyB7K,KAAK,CAAC5G,CAAD,CAA9B,GAAoC,GAApD,CAAN;AAA8D;AACxE;;AACD,SAAOgE,KAAP;AACF,C,CCtlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;IACa6R,SAAS,GAIpB,mBAAY3Q,MAAZ,EAAoB4Q,KAApB,EAA2B;oBAAA,CAC7B;AACA;;AACI,OAAK5Q,MAAL,GAAcA,MAAd,CAHyB,CAI7B;AACA;AACA;;AACI,OAAK4Q,KAAL,GAAaA,KAAb;AACA,OAAKC,IAAL,GAAY,EAAZ;AACA,OAAKC,MAAL,GAAc,EAAd;AAEAF,OAAK,CAAC3R,OAAN,CAAa,UAAC8R,IAAD,EAAS;AACpB,QAAIA,IAAI,CAACC,GAAT,EAAY;AAAEC,YAAI,CAACJ,IAALI,CAAUlT,IAAVkT,CAAeF,IAAfE;AAAoB,KAAlC,MA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","names":["findDiffStart","a","b","pos","let","i","childCount","childA","child","childB","nodeSize","sameMarkup","isText","text","j","content","size","inner","findDiffEnd","posA","posB","iA","iB","same","minSize","Math","min","length","Fragment","nodesBetween","from","to","f","nodeStart","parent","end","start","max","descendants","textBetween","blockSeparator","leafText","separated","node","slice","isLeaf","isBlock","append","other","last","lastChild","first","firstChild","withText","push","cut","result","cutByIndex","empty","replaceChild","index","current","copy","addToStart","concat","addToEnd","eq","prototypeAccessors","get","found","RangeError","maybeChild","forEach","p","otherPos","findIndex","round","retIndex","curPos","cur","toString","toStringInner","join","toJSON","map","n","fromJSON","schema","value","Array","isArray","nodeFromJSON","fromArray","array","joined","nodes","attrs","const","offset","compareDeep","Mark","type","addToSet","set","placed","excludes","rank","removeFromSet","isInSet","obj","name","_","json","marks","create","sameSet","setFrom","none","sort","ReplaceError","message","err","Error","call","__proto__","prototype","Object","constructor","Slice","openStart","openEnd","insertAt","fragment","insertInto","removeBetween","removeRange","maxOpen","openIsolating","spec","isolating","offsetTo","indexTo","dist","insert","canReplace","replace","$from","$to","depth","replaceOuter","close","replaceTwoWay","parentOffset","prepareSliceForReplace","replaceThreeWay","checkJoin","main","sub","compatibleContent","joinable","$before","$after","addNode","target","addRange","$start","$end","startIndex","endIndex","textOffset","nodeAfter","nodeBefore","validContent","$along","extra","resolveNoCache","ResolvedPos","path","resolveDepth","val","doc","indexAfter","before","after","dOff","posAtIndex","tmp","inclusive","marksAcross","isInline","next","sharedDepth","blockRange","pred","d","inlineContent","NodeRange","sameParent","str","resolve","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","prototypeAccessors$1","emptyAttrs","Node","startPos","textContent","hasMarkup","defaultAttrs","mark","includeParents","nodeAt","childAfter","childBefore","rangeHasMark","isTextblock","isAtom","toDebugString","wrapMarks","contentMatchAt","match","contentMatch","matchFragment","replacement","one","two","validEnd","allowsMarks","canReplaceWith","matchType","canAppend","check","m","markFromJSON","nodeType","TextNode","super","JSON","stringify","base","ContentMatch","wrapCache","parse","string","nodeTypes","stream","TokenStream","expr","parseExpr","dfa","nfa","checkForDeadEnds","frag","defaultType","hasRequiredAttrs","compatible","fillBefore","toEnd","seen","search","types","finished","tp","createAndFill","indexOf","findWrapping","computed","computeWrapping","active","via","shift","reverse","edgeCount","edge","scan","out","inline","tokens","split","pop","eat","tok","SyntaxError","exprs","parseExprSeq","parseExprSubscript","parseExprAtom","parseExprRange","parseNum","test","Number","resolveName","typeName","groups","connect","compile","term","edges","reduce","loop","cmp","nullFrom","labeled","explore","states","known","state","work","dead","defaults","attrName","attr","hasDefault","default","computeAttrs","built","given","undefined","initAttrs","Attribute","NodeType","group","markSet","atom","whitespace","code","isRequired","createChecked","allowsMarkType","markType","allowedMarks","topType","topNode","options","hasOwnProperty","MarkType","excluded","instance","Schema","prop","OrderedMap","contentExprCache","contentExpr","markExpr","gatherMarks","excl","bind","topNodeType","wrappings","ok","DOMParser","rules","tags","styles","rule","tag","this","style","normalizeLists","some","r","dom","context","ParseContext","addAll","finish","parseSlice","matchTag","matches","namespace","namespaceURI","matchesContext","getAttrs","matchStyle","charCodeAt","schemaRules","priority","nextPriority","splice","parseDOM","loop$1","fromSchema","domParser","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","output","pre","section","table","tfoot","ul","ignoreTags","head","object","script","title","listTags","OPT_PRESERVE_WS","OPT_PRESERVE_WS_FULL","OPT_OPEN_LEFT","wsOptionsFor","preserveWhitespace","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","wrap","exec","popFromStashMark","applyPending","nextType","pending","markMayApply","inlineContext","parentNode","nodeName","toLowerCase","parser","open","isOpen","topContext","topOptions","topMatch","find","findPositions","needsBlock","top","addDOM","addTextNode","getAttribute","readStyles","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","insertNode","findInText","findInside","matchAfter","ruleID","normalizeList","ruleFromNode","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","continueAfter","enter","startIn","getContent","contentDOM","contentElement","querySelector","findAround","childNodes","nextSibling","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","topOpen","currentPos","contains","compareDocumentPosition","textNode","parts","option","useRoot","minDepth","part","$context","deflt","findSameMarkInSet","upto","level","lastIndexOf","stashMark","prevItem","appendChild","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","re","trim","v","DOMSerializer","serializeFragment","createDocumentFragment","keep","rendered","spanning","add","markDOM","serializeMark","serializeNodeInner","renderSpec","onContent","serializeNode","toDOM","structure","xmlNS","tagName","space","createElementNS","createElement","setAttributeNS","setAttribute","innerContent","domSerializer","nodesFromSchema","marksFromSchema","gatherToDOM","document","window"],"sources":["/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/diff.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/fragment.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/comparedeep.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/mark.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/replace.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/resolvedpos.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/node.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/content.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/schema.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/from_dom.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-model/src/to_dom.js"],"sourcesContent":["export function findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos\n\n    let childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) return pos\n\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) return inner\n    }\n    pos += childA.nodeSize\n  }\n}\n\nexport function findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : {a: posA, b: posB}\n\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}\n\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) return inner\n    }\n    posA -= size; posB -= size\n  }\n}\n","import {findDiffStart, findDiffEnd} from \"./diff\"\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nexport class Fragment {\n  constructor(content, size) {\n    this.content = content\n    // :: number\n    // The size of the fragment, which is the total of the size of its\n    // content nodes.\n    this.size = size || 0\n    if (size == null) for (let i = 0; i < content.length; i++)\n      this.size += content[i].nodeSize\n  }\n\n  // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes between the given two\n  // positions (relative to start of this fragment). Doesn't descend\n  // into a node when the callback returns `false`.\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n        let start = pos + 1\n        child.nodesBetween(Math.max(0, from - start),\n                           Math.min(child.content.size, to - start),\n                           f, nodeStart + start)\n      }\n      pos = end\n    }\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. The callback\n  // may return `false` to prevent traversal of a given node's children.\n  descendants(f) {\n    this.nodesBetween(0, this.size, f)\n  }\n\n  // :: (number, number, ?string, ?union<string, (leafNode: Node) → string>) → string\n  // Extract the text between `from` and `to`. See the same method on\n  // [`Node`](#model.Node.textBetween).\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n        separated = !blockSeparator\n      } else if (node.isLeaf && leafText) {\n        text += typeof leafText === 'function' ? leafText(node): leafText\n        separated = !blockSeparator\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator\n        separated = true\n      }\n    }, 0)\n    return text\n  }\n\n  // :: (Fragment) → Fragment\n  // Create a new fragment containing the combined content of this\n  // fragment and the other.\n  append(other) {\n    if (!other.size) return this\n    if (!this.size) return other\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text)\n      i = 1\n    }\n    for (; i < other.content.length; i++) content.push(other.content[i])\n    return new Fragment(content, this.size + other.size)\n  }\n\n  // :: (number, ?number) → Fragment\n  // Cut out the sub-fragment between the two given positions.\n  cut(from, to) {\n    if (to == null) to = this.size\n    if (from == 0 && to == this.size) return this\n    let result = [], size = 0\n    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText)\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos))\n          else\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1))\n        }\n        result.push(child)\n        size += child.nodeSize\n      }\n      pos = end\n    }\n    return new Fragment(result, size)\n  }\n\n  cutByIndex(from, to) {\n    if (from == to) return Fragment.empty\n    if (from == 0 && to == this.content.length) return this\n    return new Fragment(this.content.slice(from, to))\n  }\n\n  // :: (number, Node) → Fragment\n  // Create a new fragment in which the node at the given index is\n  // replaced by the given node.\n  replaceChild(index, node) {\n    let current = this.content[index]\n    if (current == node) return this\n    let copy = this.content.slice()\n    let size = this.size + node.nodeSize - current.nodeSize\n    copy[index] = node\n    return new Fragment(copy, size)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by prepending the given node to this\n  // fragment.\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by appending the given node to this\n  // fragment.\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n  }\n\n  // :: (Fragment) → bool\n  // Compare this fragment to another one.\n  eq(other) {\n    if (this.content.length != other.content.length) return false\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i])) return false\n    return true\n  }\n\n  // :: ?Node\n  // The first child of the fragment, or `null` if it is empty.\n  get firstChild() { return this.content.length ? this.content[0] : null }\n\n  // :: ?Node\n  // The last child of the fragment, or `null` if it is empty.\n  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }\n\n  // :: number\n  // The number of child nodes in this fragment.\n  get childCount() { return this.content.length }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raise an error when the\n  // index is out of range.\n  child(index) {\n    let found = this.content[index]\n    if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this)\n    return found\n  }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) {\n    return this.content[index]\n  }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i]\n      f(child, p, i)\n      p += child.nodeSize\n    }\n  }\n\n  // :: (Fragment) → ?number\n  // Find the first position at which this fragment and another\n  // fragment differ, or `null` if they are the same.\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos)\n  }\n\n  // :: (Fragment) → ?{a: number, b: number}\n  // Find the first position, searching from the end, at which this\n  // fragment and the given fragment differ, or `null` if they are the\n  // same. Since this position will not be the same in both nodes, an\n  // object with two separate positions is returned.\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos)\n  }\n\n  // : (number, ?number) → {index: number, offset: number}\n  // Find the index and inner offset corresponding to a given relative\n  // position in this fragment. The result object will be reused\n  // (overwritten) the next time the function is called. (Not public.)\n  findIndex(pos, round = -1) {\n    if (pos == 0) return retIndex(0, pos)\n    if (pos == this.size) return retIndex(this.content.length, pos)\n    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize\n      if (end >= pos) {\n        if (end == pos || round > 0) return retIndex(i + 1, end)\n        return retIndex(i, curPos)\n      }\n      curPos = end\n    }\n  }\n\n  // :: () → string\n  // Return a debugging string that describes this fragment.\n  toString() { return \"<\" + this.toStringInner() + \">\" }\n\n  toStringInner() { return this.content.join(\", \") }\n\n  // :: () → ?Object\n  // Create a JSON-serializeable representation of this fragment.\n  toJSON() {\n    return this.content.length ? this.content.map(n => n.toJSON()) : null\n  }\n\n  // :: (Schema, ?Object) → Fragment\n  // Deserialize a fragment from its JSON representation.\n  static fromJSON(schema, value) {\n    if (!value) return Fragment.empty\n    if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\")\n    return new Fragment(value.map(schema.nodeFromJSON))\n  }\n\n  // :: ([Node]) → Fragment\n  // Build a fragment from an array of nodes. Ensures that adjacent\n  // text nodes with the same marks are joined together.\n  static fromArray(array) {\n    if (!array.length) return Fragment.empty\n    let joined, size = 0\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i]\n      size += node.nodeSize\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined) joined = array.slice(0, i)\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n      } else if (joined) {\n        joined.push(node)\n      }\n    }\n    return new Fragment(joined || array, size)\n  }\n\n  // :: (?union<Fragment, Node, [Node]>) → Fragment\n  // Create a fragment from something that can be interpreted as a set\n  // of nodes. For `null`, it returns the empty fragment. For a\n  // fragment, the fragment itself. For a node or array of nodes, a\n  // fragment containing those nodes.\n  static from(nodes) {\n    if (!nodes) return Fragment.empty\n    if (nodes instanceof Fragment) return nodes\n    if (Array.isArray(nodes)) return this.fromArray(nodes)\n    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                         (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n  }\n}\n\nconst found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n","export function compareDeep(a, b) {\n  if (a === b) return true\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) return false\n  let array = Array.isArray(a)\n  if (Array.isArray(b) != array) return false\n  if (array) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false\n  } else {\n    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false\n    for (let p in b) if (!(p in a)) return false\n  }\n  return true\n}\n","import {compareDeep} from \"./comparedeep\"\n\n// ::- A mark is a piece of information that can be attached to a node,\n// such as it being emphasized, in code font, or a link. It has a type\n// and optionally a set of attributes that provide further information\n// (such as the target of the link). Marks are created through a\n// `Schema`, which controls which types exist and which\n// attributes they have.\nexport class Mark {\n  constructor(type, attrs) {\n    // :: MarkType\n    // The type of this mark.\n    this.type = type\n    // :: Object\n    // The attributes associated with this mark.\n    this.attrs = attrs\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Given a set of marks, create a new set which contains this one as\n  // well, in the right position. If this mark is already in the set,\n  // the set itself is returned. If any marks that are set to be\n  // [exclusive](#model.MarkSpec.excludes) with this mark are present,\n  // those are replaced by this one.\n  addToSet(set) {\n    let copy, placed = false\n    for (let i = 0; i < set.length; i++) {\n      let other = set[i]\n      if (this.eq(other)) return set\n      if (this.type.excludes(other.type)) {\n        if (!copy) copy = set.slice(0, i)\n      } else if (other.type.excludes(this.type)) {\n        return set\n      } else {\n        if (!placed && other.type.rank > this.type.rank) {\n          if (!copy) copy = set.slice(0, i)\n          copy.push(this)\n          placed = true\n        }\n        if (copy) copy.push(other)\n      }\n    }\n    if (!copy) copy = set.slice()\n    if (!placed) copy.push(this)\n    return copy\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Remove this mark from the given set, returning a new set. If this\n  // mark is not in the set, the set itself is returned.\n  removeFromSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i]))\n        return set.slice(0, i).concat(set.slice(i + 1))\n    return set\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether this mark is in the given set of marks.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i])) return true\n    return false\n  }\n\n  // :: (Mark) → bool\n  // Test whether this mark has the same type and attributes as\n  // another mark.\n  eq(other) {\n    return this == other ||\n      (this.type == other.type && compareDeep(this.attrs, other.attrs))\n  }\n\n  // :: () → Object\n  // Convert this mark to a JSON-serializeable representation.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    return obj\n  }\n\n  // :: (Schema, Object) → Mark\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\")\n    let type = schema.marks[json.type]\n    if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`)\n    return type.create(json.attrs)\n  }\n\n  // :: ([Mark], [Mark]) → bool\n  // Test whether two sets of marks are identical.\n  static sameSet(a, b) {\n    if (a == b) return true\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].eq(b[i])) return false\n    return true\n  }\n\n  // :: (?union<Mark, [Mark]>) → [Mark]\n  // Create a properly sorted mark set from null, a single mark, or an\n  // unsorted array of marks.\n  static setFrom(marks) {\n    if (!marks || marks.length == 0) return Mark.none\n    if (marks instanceof Mark) return [marks]\n    let copy = marks.slice()\n    copy.sort((a, b) => a.type.rank - b.type.rank)\n    return copy\n  }\n}\n\n// :: [Mark] The empty set of marks.\nMark.none = []\n","import {Fragment} from \"./fragment\"\n\n// ReplaceError:: class extends Error\n// Error type raised by [`Node.replace`](#model.Node.replace) when\n// given an invalid replacement.\n\nexport function ReplaceError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = ReplaceError.prototype\n  return err\n}\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n\n// ::- A slice represents a piece cut out of a larger document. It\n// stores not only a fragment, but also the depth up to which nodes on\n// both side are ‘open’ (cut through).\nexport class Slice {\n  // :: (Fragment, number, number)\n  // Create a slice. When specifying a non-zero open depth, you must\n  // make sure that there are nodes of at least that depth at the\n  // appropriate side of the fragment—i.e. if the fragment is an empty\n  // paragraph node, `openStart` and `openEnd` can't be greater than 1.\n  //\n  // It is not necessary for the content of open nodes to conform to\n  // the schema's content constraints, though it should be a valid\n  // start/end/middle for such a node, depending on which sides are\n  // open.\n  constructor(content, openStart, openEnd) {\n    // :: Fragment The slice's content.\n    this.content = content\n    // :: number The open depth at the start.\n    this.openStart = openStart\n    // :: number The open depth at the end.\n    this.openEnd = openEnd\n  }\n\n  // :: number\n  // The size this slice would add when inserted into a document.\n  get size() {\n    return this.content.size - this.openStart - this.openEnd\n  }\n\n  insertAt(pos, fragment) {\n    let content = insertInto(this.content, pos + this.openStart, fragment, null)\n    return content && new Slice(content, this.openStart, this.openEnd)\n  }\n\n  removeBetween(from, to) {\n    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)\n  }\n\n  // :: (Slice) → bool\n  // Tests whether this slice is equal to another slice.\n  eq(other) {\n    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd\n  }\n\n  toString() {\n    return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\"\n  }\n\n  // :: () → ?Object\n  // Convert a slice to a JSON-serializable representation.\n  toJSON() {\n    if (!this.content.size) return null\n    let json = {content: this.content.toJSON()}\n    if (this.openStart > 0) json.openStart = this.openStart\n    if (this.openEnd > 0) json.openEnd = this.openEnd\n    return json\n  }\n\n  // :: (Schema, ?Object) → Slice\n  // Deserialize a slice from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) return Slice.empty\n    let openStart = json.openStart || 0, openEnd = json.openEnd || 0\n    if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n      throw new RangeError(\"Invalid input for Slice.fromJSON\")\n    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)\n  }\n\n  // :: (Fragment, ?bool) → Slice\n  // Create a slice from a fragment by taking the maximum possible\n  // open value on both side of the fragment.\n  static maxOpen(fragment, openIsolating=true) {\n    let openStart = 0, openEnd = 0\n    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++\n    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild) openEnd++\n    return new Slice(fragment, openStart, openEnd)\n  }\n}\n\nfunction removeRange(content, from, to) {\n  let {index, offset} = content.findIndex(from), child = content.maybeChild(index)\n  let {index: indexTo, offset: offsetTo} = content.findIndex(to)\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\")\n    return content.cut(0, from).append(content.cut(to))\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\")\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  let {index, offset} = content.findIndex(dist), child = content.maybeChild(index)\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null\n    return content.cut(0, dist).append(insert).append(content.cut(dist))\n  }\n  let inner = insertInto(child.content, dist - offset - 1, insert)\n  return inner && content.replaceChild(index, child.copy(inner))\n}\n\n// :: Slice\n// The empty slice.\nSlice.empty = new Slice(Fragment.empty, 0, 0)\n\nexport function replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    throw new ReplaceError(\"Inserted content deeper than insertion position\")\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    throw new ReplaceError(\"Inconsistent open depths\")\n  return replaceOuter($from, $to, slice, 0)\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  let index = $from.index(depth), node = $from.node(depth)\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    let inner = replaceOuter($from, $to, slice, depth + 1)\n    return node.copy(node.content.replaceChild(index, inner))\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth))\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n    let parent = $from.parent, content = parent.content\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))\n  } else {\n    let {start, end} = prepareSliceForReplace(slice, $from)\n    return close(node, replaceThreeWay($from, start, end, $to, depth))\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name)\n}\n\nfunction joinable($before, $after, depth) {\n  let node = $before.node(depth)\n  checkJoin(node, $after.node(depth))\n  return node\n}\n\nfunction addNode(child, target) {\n  let last = target.length - 1\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    target[last] = child.withText(target[last].text + child.text)\n  else\n    target.push(child)\n}\n\nfunction addRange($start, $end, depth, target) {\n  let node = ($end || $start).node(depth)\n  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount\n  if ($start) {\n    startIndex = $start.index(depth)\n    if ($start.depth > depth) {\n      startIndex++\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target)\n      startIndex++\n    }\n  }\n  for (let i = startIndex; i < endIndex; i++) addNode(node.child(i), target)\n  if ($end && $end.depth == depth && $end.textOffset)\n    addNode($end.nodeBefore, target)\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name)\n  return node.copy(content)\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  let openStart = $from.depth > depth && joinable($from, $start, depth + 1)\n  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1)\n\n  let content = []\n  addRange(null, $from, depth, content)\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd)\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content)\n  } else {\n    if (openStart)\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content)\n    addRange($start, $end, depth, content)\n    if (openEnd)\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  let content = []\n  addRange(null, $from, depth, content)\n  if ($from.depth > depth) {\n    let type = joinable($from, $to, depth + 1)\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content)\n  }\n  addRange($to, null, depth, content)\n  return new Fragment(content)\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  let extra = $along.depth - slice.openStart, parent = $along.node(extra)\n  let node = parent.copy(slice.content)\n  for (let i = extra - 1; i >= 0; i--)\n    node = $along.node(i).copy(Fragment.from(node))\n  return {start: node.resolveNoCache(slice.openStart + extra),\n          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}\n}\n","import {Mark} from \"./mark\"\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nexport class ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    // :: number The position that was resolved.\n    this.pos = pos\n    this.path = path\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root node, it is 0. If it\n    // points into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset\n  }\n\n  resolveDepth(val) {\n    if (val == null) return this.depth\n    if (val < 0) return this.depth + val\n    return val\n  }\n\n  // :: Node\n  // The parent node that the position points into. Note that even if\n  // a position points into a text node, that node is not considered\n  // the parent—text nodes are ‘flat’ in this model, and have no content.\n  get parent() { return this.node(this.depth) }\n\n  // :: Node\n  // The root node in which the position was resolved.\n  get doc() { return this.node(0) }\n\n  // :: (?number) → Node\n  // The ancestor node at the given level. `p.node(p.depth)` is the\n  // same as `p.parent`.\n  node(depth) { return this.path[this.resolveDepth(depth) * 3] }\n\n  // :: (?number) → number\n  // The index into the ancestor at the given level. If this points at\n  // the 3rd node in the 2nd paragraph on the top level, for example,\n  // `p.index(0)` is 1 and `p.index(1)` is 2.\n  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }\n\n  // :: (?number) → number\n  // The index pointing after this position into the ancestor at the\n  // given level.\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth)\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the start of the node at the given\n  // level.\n  start(depth) {\n    depth = this.resolveDepth(depth)\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the end of the node at the given\n  // level.\n  end(depth) {\n    depth = this.resolveDepth(depth)\n    return this.start(depth) + this.node(depth).content.size\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly before the wrapping node at the\n  // given level, or, when `depth` is `this.depth + 1`, the original\n  // position.\n  before(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position before the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly after the wrapping node at the\n  // given level, or the original position when `depth` is `this.depth + 1`.\n  after(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position after the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n  }\n\n  // :: number\n  // When this position points into a text node, this returns the\n  // distance between the position and the start of the text node.\n  // Will be zero for positions that point between nodes.\n  get textOffset() { return this.pos - this.path[this.path.length - 1] }\n\n  // :: ?Node\n  // Get the node directly after the position, if any. If the position\n  // points into a text node, only the part of that node after the\n  // position is returned.\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth)\n    if (index == parent.childCount) return null\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n    return dOff ? parent.child(index).cut(dOff) : child\n  }\n\n  // :: ?Node\n  // Get the node directly before the position, if any. If the\n  // position points into a text node, only the part of that node\n  // before the position is returned.\n  get nodeBefore() {\n    let index = this.index(this.depth)\n    let dOff = this.pos - this.path[this.path.length - 1]\n    if (dOff) return this.parent.child(index).cut(0, dOff)\n    return index == 0 ? null : this.parent.child(index - 1)\n  }\n\n  // :: (number, ?number) → number\n  // Get the position at the given index in the parent node at the\n  // given depth (which defaults to `this.depth`).\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth)\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n    for (let i = 0; i < index; i++) pos += node.child(i).nodeSize\n    return pos\n  }\n\n  // :: () → [Mark]\n  // Get the marks at this position, factoring in the surrounding\n  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n  // position is at the start of a non-empty node, the marks of the\n  // node after it (if any) are returned.\n  marks() {\n    let parent = this.parent, index = this.index()\n\n    // In an empty parent, return the empty array\n    if (parent.content.size == 0) return Mark.none\n\n    // When inside a text node, just return the text node's marks\n    if (this.textOffset) return parent.child(index).marks\n\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index)\n    // If the `after` flag is true of there is no node before, make\n    // the node after this position the main reference.\n    if (!main) { let tmp = main; main = other; other = tmp }\n\n    // Use all marks in the main node, except those that have\n    // `inclusive` set to false and are not present in the other node.\n    let marks = main.marks\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks)\n\n    return marks\n  }\n\n  // :: (ResolvedPos) → ?[Mark]\n  // Get the marks after the current position, if any, except those\n  // that are non-inclusive and not present at position `$end`. This\n  // is mostly useful for getting the set of marks to preserve after a\n  // deletion. Will return `null` if this position is at the end of\n  // its parent node or its parent node isn't a textblock (in which\n  // case no marks should be preserved).\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index())\n    if (!after || !after.isInline) return null\n\n    let marks = after.marks, next = $end.parent.maybeChild($end.index())\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks)\n    return marks\n  }\n\n  // :: (number) → number\n  // The depth up to which this position and the given (non-resolved)\n  // position share the same parent nodes.\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth\n    return 0\n  }\n\n  // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n  // Returns a range based on the place where this position and the\n  // given position diverge around block content. If both point into\n  // the same textblock, for example, a range around that textblock\n  // will be returned. If they point into different blocks, the range\n  // around those blocks in their shared ancestor is returned. You can\n  // pass in an optional predicate that will be called with a parent\n  // node to see if a range into that parent is acceptable.\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos) return other.blockRange(this)\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d)\n  }\n\n  // :: (ResolvedPos) → bool\n  // Query whether the given position shares the same parent node.\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the greater of this and the given position.\n  max(other) {\n    return other.pos > this.pos ? other : this\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the smaller of this and the given position.\n  min(other) {\n    return other.pos < this.pos ? other : this\n  }\n\n  toString() {\n    let str = \"\"\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1)\n    return str + \":\" + this.parentOffset\n  }\n\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\")\n    let path = []\n    let start = 0, parentOffset = pos\n    for (let node = doc;;) {\n      let {index, offset} = node.content.findIndex(parentOffset)\n      let rem = parentOffset - offset\n      path.push(node, index, start + offset)\n      if (!rem) break\n      node = node.child(index)\n      if (node.isText) break\n      parentOffset = rem - 1\n      start += offset + 1\n    }\n    return new ResolvedPos(pos, path, parentOffset)\n  }\n\n  static resolveCached(doc, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i]\n      if (cached.pos == pos && cached.doc == doc) return cached\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n    return result\n  }\n}\n\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nexport class NodeRange {\n  // :: (ResolvedPos, ResolvedPos, number)\n  // Construct a node range. `$from` and `$to` should point into the\n  // same node until at least the given `depth`, since a node range\n  // denotes an adjacent set of nodes in a single parent node.\n  constructor($from, $to, depth) {\n    // :: ResolvedPos A resolved position along the start of the\n    // content. May have a `depth` greater than this object's `depth`\n    // property, since these are the positions that were used to\n    // compute the range, not re-resolved positions directly at its\n    // boundaries.\n    this.$from = $from\n    // :: ResolvedPos A position along the end of the content. See\n    // caveat for [`$from`](#model.NodeRange.$from).\n    this.$to = $to\n    // :: number The depth of the node that this range points into.\n    this.depth = depth\n  }\n\n  // :: number The position at the start of the range.\n  get start() { return this.$from.before(this.depth + 1) }\n  // :: number The position at the end of the range.\n  get end() { return this.$to.after(this.depth + 1) }\n\n  // :: Node The parent node that the range points into.\n  get parent() { return this.$from.node(this.depth) }\n  // :: number The start index of the range in the parent node.\n  get startIndex() { return this.$from.index(this.depth) }\n  // :: number The end index of the range in the parent node.\n  get endIndex() { return this.$to.indexAfter(this.depth) }\n}\n","import {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {Slice, replace} from \"./replace\"\nimport {ResolvedPos} from \"./resolvedpos\"\nimport {compareDeep} from \"./comparedeep\"\n\nconst emptyAttrs = Object.create(null)\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nexport class Node {\n  constructor(type, attrs, content, marks) {\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type\n\n    // :: Object\n    // An object mapping attribute names to values. The kind of\n    // attributes allowed and required are\n    // [determined](#model.NodeSpec.attrs) by the node type.\n    this.attrs = attrs\n\n    // :: Fragment\n    // A container holding the node's children.\n    this.content = content || Fragment.empty\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) applied to this node.\n    this.marks = marks || Mark.none\n  }\n\n  // text:: ?string\n  // For text nodes, this contains the node's text content.\n\n  // :: number\n  // The size of this node, as defined by the integer-based [indexing\n  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n  // amount of characters. For other leaf nodes, it is one. For\n  // non-leaf nodes, it is the size of the content plus two (the start\n  // and end token).\n  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }\n\n  // :: number\n  // The number of children that the node has.\n  get childCount() { return this.content.childCount }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raises an error when the\n  // index is out of range.\n  child(index) { return this.content.child(index) }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) { return this.content.maybeChild(index) }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) { this.content.forEach(f) }\n\n  // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes recursively between\n  // the given two positions that are relative to start of this node's\n  // content. The callback is invoked with the node, its\n  // parent-relative position, its parent node, and its child index.\n  // When the callback returns false for a given node, that node's\n  // children will not be recursed over. The last parameter can be\n  // used to specify a starting position to count from.\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this)\n  }\n\n  // :: ((node: Node, pos: number, parent: Node, index: number) → ?bool)\n  // Call the given callback for every descendant node. Doesn't\n  // descend into a node when the callback returns `false`.\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f)\n  }\n\n  // :: string\n  // Concatenates all the text nodes found in this fragment and its\n  // children.\n  get textContent() { return this.textBetween(0, this.content.size, \"\") }\n\n  // :: (number, number, ?string, ?union<string, ?(leafNode: Node) -> string>) → string\n  // Get all text between positions `from` and `to`. When\n  // `blockSeparator` is given, it will be inserted to separate text\n  // from different block nodes. When `leafText` is given, it'll be\n  // inserted for every non-text leaf node encountered.\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText)\n  }\n\n  // :: ?Node\n  // Returns this node's first child, or `null` if there are no\n  // children.\n  get firstChild() { return this.content.firstChild }\n\n  // :: ?Node\n  // Returns this node's last child, or `null` if there are no\n  // children.\n  get lastChild() { return this.content.lastChild }\n\n  // :: (Node) → bool\n  // Test whether two nodes represent the same piece of document.\n  eq(other) {\n    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n  }\n\n  // :: (Node) → bool\n  // Compare the markup (type, attributes, and marks) of this node to\n  // those of another. Returns `true` if both have the same markup.\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks)\n  }\n\n  // :: (NodeType, ?Object, ?[Mark]) → bool\n  // Check whether this node's markup correspond to the given type,\n  // attributes, and marks.\n  hasMarkup(type, attrs, marks) {\n    return this.type == type &&\n      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n      Mark.sameSet(this.marks, marks || Mark.none)\n  }\n\n  // :: (?Fragment) → Node\n  // Create a new node with the same markup as this node, containing\n  // the given content (or empty, if no content is given).\n  copy(content = null) {\n    if (content == this.content) return this\n    return new this.constructor(this.type, this.attrs, content, this.marks)\n  }\n\n  // :: ([Mark]) → Node\n  // Create a copy of this node, with the given set of marks instead\n  // of the node's own marks.\n  mark(marks) {\n    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n  }\n\n  // :: (number, ?number) → Node\n  // Create a copy of this node with only the content between the\n  // given positions. If `to` is not given, it defaults to the end of\n  // the node.\n  cut(from, to) {\n    if (from == 0 && to == this.content.size) return this\n    return this.copy(this.content.cut(from, to))\n  }\n\n  // :: (number, ?number) → Slice\n  // Cut out the part of the document between the given positions, and\n  // return it as a `Slice` object.\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to) return Slice.empty\n\n    let $from = this.resolve(from), $to = this.resolve(to)\n    let depth = includeParents ? 0 : $from.sharedDepth(to)\n    let start = $from.start(depth), node = $from.node(depth)\n    let content = node.content.cut($from.pos - start, $to.pos - start)\n    return new Slice(content, $from.depth - depth, $to.depth - depth)\n  }\n\n  // :: (number, number, Slice) → Node\n  // Replace the part of the document between the given positions with\n  // the given slice. The slice must 'fit', meaning its open sides\n  // must be able to connect to the surrounding content, and its\n  // content nodes must be valid children for the node they are placed\n  // into. If any of this is violated, an error of type\n  // [`ReplaceError`](#model.ReplaceError) is thrown.\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice)\n  }\n\n  // :: (number) → ?Node\n  // Find the node directly after the given position.\n  nodeAt(pos) {\n    for (let node = this;;) {\n      let {index, offset} = node.content.findIndex(pos)\n      node = node.maybeChild(index)\n      if (!node) return null\n      if (offset == pos || node.isText) return node\n      pos -= offset + 1\n    }\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node after the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childAfter(pos) {\n    let {index, offset} = this.content.findIndex(pos)\n    return {node: this.content.maybeChild(index), index, offset}\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node before the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childBefore(pos) {\n    if (pos == 0) return {node: null, index: 0, offset: 0}\n    let {index, offset} = this.content.findIndex(pos)\n    if (offset < pos) return {node: this.content.child(index), index, offset}\n    let node = this.content.child(index - 1)\n    return {node, index: index - 1, offset: offset - node.nodeSize}\n  }\n\n  // :: (number) → ResolvedPos\n  // Resolve the given position in the document, returning an\n  // [object](#model.ResolvedPos) with information about its context.\n  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }\n\n  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }\n\n  // :: (number, number, union<Mark, MarkType>) → bool\n  // Test whether a given mark or mark type occurs in this document\n  // between the two given positions.\n  rangeHasMark(from, to, type) {\n    let found = false\n    if (to > from) this.nodesBetween(from, to, node => {\n      if (type.isInSet(node.marks)) found = true\n      return !found\n    })\n    return found\n  }\n\n  // :: bool\n  // True when this is a block (non-inline node)\n  get isBlock() { return this.type.isBlock }\n\n  // :: bool\n  // True when this is a textblock node, a block node with inline\n  // content.\n  get isTextblock() { return this.type.isTextblock }\n\n  // :: bool\n  // True when this node allows inline content.\n  get inlineContent() { return this.type.inlineContent }\n\n  // :: bool\n  // True when this is an inline node (a text node or a node that can\n  // appear among text).\n  get isInline() { return this.type.isInline }\n\n  // :: bool\n  // True when this is a text node.\n  get isText() { return this.type.isText }\n\n  // :: bool\n  // True when this is a leaf node.\n  get isLeaf() { return this.type.isLeaf }\n\n  // :: bool\n  // True when this is an atom, i.e. when it does not have directly\n  // editable content. This is usually the same as `isLeaf`, but can\n  // be configured with the [`atom` property](#model.NodeSpec.atom) on\n  // a node's spec (typically used when the node is displayed as an\n  // uneditable [node view](#view.NodeView)).\n  get isAtom() { return this.type.isAtom }\n\n  // :: () → string\n  // Return a string representation of this node for debugging\n  // purposes.\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    let name = this.type.name\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\"\n    return wrapMarks(this.marks, name)\n  }\n\n  // :: (number) → ContentMatch\n  // Get the content match in this node at the given index.\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index)\n    if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\")\n    return match\n  }\n\n  // :: (number, number, ?Fragment, ?number, ?number) → bool\n  // Test whether replacing the range between `from` and `to` (by\n  // child index) with the given replacement fragment (which defaults\n  // to the empty fragment) would leave the node's content valid. You\n  // can optionally pass `start` and `end` indices into the\n  // replacement fragment.\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end)\n    let two = one && one.matchFragment(this.content, to)\n    if (!two || !two.validEnd) return false\n    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false\n    return true\n  }\n\n  // :: (number, number, NodeType, ?[Mark]) → bool\n  // Test whether replacing the range `from` to `to` (by index) with a\n  // node of the given type would leave the node's content valid.\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks)) return false\n    let start = this.contentMatchAt(from).matchType(type)\n    let end = start && start.matchFragment(this.content, to)\n    return end ? end.validEnd : false\n  }\n\n  // :: (Node) → bool\n  // Test whether the given node's content could be appended to this\n  // node. If that node is empty, this will only return true if there\n  // is at least one node type that can appear in both nodes (to avoid\n  // merging completely incompatible nodes).\n  canAppend(other) {\n    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)\n    else return this.type.compatibleContent(other.type)\n  }\n\n  // :: ()\n  // Check whether this node and its descendants conform to the\n  // schema, and raise error when they do not.\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)\n    let copy = Mark.none\n    for (let i = 0; i < this.marks.length; i++) copy = this.marks[i].addToSet(copy)\n    if (!Mark.sameSet(copy, this.marks))\n      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`)\n    this.content.forEach(node => node.check())\n  }\n\n  // :: () → Object\n  // Return a JSON-serializeable representation of this node.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON()\n    if (this.marks.length)\n      obj.marks = this.marks.map(n => n.toJSON())\n    return obj\n  }\n\n  // :: (Schema, Object) → Node\n  // Deserialize a node from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\")\n    let marks = null\n    if (json.marks) {\n      if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\")\n      marks = json.marks.map(schema.markFromJSON)\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\")\n      return schema.text(json.text, marks)\n    }\n    let content = Fragment.fromJSON(schema, json.content)\n    return schema.nodeType(json.type).create(json.attrs, content, marks)\n  }\n}\n\nexport class TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks)\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\")\n\n    this.text = content\n  }\n\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  }\n\n  get textContent() { return this.text }\n\n  textBetween(from, to) { return this.text.slice(from, to) }\n\n  get nodeSize() { return this.text.length }\n\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  }\n\n  withText(text) {\n    if (text == this.text) return this\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  }\n\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length) return this\n    return this.withText(this.text.slice(from, to))\n  }\n\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text\n  }\n\n  toJSON() {\n    let base = super.toJSON()\n    base.text = this.text\n    return base\n  }\n}\n\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\"\n  return str\n}\n","import {Fragment} from \"./fragment\"\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nexport class ContentMatch {\n  constructor(validEnd) {\n    // :: bool\n    // True when this match state represents a valid end of the node.\n    this.validEnd = validEnd\n    this.next = []\n    this.wrapCache = []\n  }\n\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes)\n    if (stream.next == null) return ContentMatch.empty\n    let expr = parseExpr(stream)\n    if (stream.next) stream.err(\"Unexpected trailing text\")\n    let match = dfa(nfa(expr))\n    checkForDeadEnds(match, stream)\n    return match\n  }\n\n  // :: (NodeType) → ?ContentMatch\n  // Match a node type, returning a match after that node if\n  // successful.\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i += 2)\n      if (this.next[i] == type) return this.next[i + 1]\n    return null\n  }\n\n  // :: (Fragment, ?number, ?number) → ?ContentMatch\n  // Try to match a fragment. Returns the resulting match when\n  // successful.\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type)\n    return cur\n  }\n\n  get inlineContent() {\n    let first = this.next[0]\n    return first ? first.isInline : false\n  }\n\n  // :: ?NodeType\n  // Get the first matching node type at this match position that can\n  // be generated.\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i += 2) {\n      let type = this.next[i]\n      if (!(type.isText || type.hasRequiredAttrs())) return type\n    }\n  }\n\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i += 2)\n      for (let j = 0; j < other.next.length; j += 2)\n        if (this.next[i] == other.next[j]) return true\n    return false\n  }\n\n  // :: (Fragment, bool, ?number) → ?Fragment\n  // Try to match the given fragment, and if that fails, see if it can\n  // be made to match by inserting nodes in front of it. When\n  // successful, return a fragment of inserted nodes (which may be\n  // empty if nothing had to be inserted). When `toEnd` is true, only\n  // return a fragment if the resulting match goes to the end of the\n  // content expression.\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this]\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex)\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map(tp => tp.createAndFill()))\n\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i], next = match.next[i + 1]\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next)\n          let found = search(next, types.concat(type))\n          if (found) return found\n        }\n      }\n    }\n\n    return search(this, [])\n  }\n\n  // :: (NodeType) → ?[NodeType]\n  // Find a set of wrapping node types that would allow a node of the\n  // given type to appear at this position. The result may be empty\n  // (when it fits directly) and will be null when no such wrapping\n  // exists.\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]\n    let computed = this.computeWrapping(target)\n    this.wrapCache.push(target, computed)\n    return computed\n  }\n\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{match: this, type: null, via: null}]\n    while (active.length) {\n      let current = active.shift(), match = current.match\n      if (match.matchType(target)) {\n        let result = []\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type)\n        return result.reverse()\n      }\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i]\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n          active.push({match: type.contentMatch, type, via: current})\n          seen[type.name] = true\n        }\n      }\n    }\n  }\n\n  // :: number\n  // The number of outgoing edges this node has in the finite\n  // automaton that describes the content expression.\n  get edgeCount() {\n    return this.next.length >> 1\n  }\n\n  // :: (number) → {type: NodeType, next: ContentMatch}\n  // Get the _n_​th outgoing edge from this node in the finite\n  // automaton that describes the content expression.\n  edge(n) {\n    let i = n << 1\n    if (i >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)\n    return {type: this.next[i], next: this.next[i + 1]}\n  }\n\n  toString() {\n    let seen = []\n    function scan(m) {\n      seen.push(m)\n      for (let i = 1; i < m.next.length; i += 2)\n        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i])\n    }\n    scan(this)\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \"\n      for (let i = 0; i < m.next.length; i += 2)\n        out += (i ? \", \" : \"\") + m.next[i].name + \"->\" + seen.indexOf(m.next[i + 1])\n      return out\n    }).join(\"\\n\")\n  }\n}\n\nContentMatch.empty = new ContentMatch(true)\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string\n    this.nodeTypes = nodeTypes\n    this.inline = null\n    this.pos = 0\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/)\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop()\n    if (this.tokens[0] == \"\") this.tokens.shift()\n  }\n\n  get next() { return this.tokens[this.pos] }\n\n  eat(tok) { return this.next == tok && (this.pos++ || true) }\n\n  err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") }\n}\n\nfunction parseExpr(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSeq(stream)) }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n}\n\nfunction parseExprSeq(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSubscript(stream)) }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream)\n  for (;;) {\n    if (stream.eat(\"+\"))\n      expr = {type: \"plus\", expr}\n    else if (stream.eat(\"*\"))\n      expr = {type: \"star\", expr}\n    else if (stream.eat(\"?\"))\n      expr = {type: \"opt\", expr}\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr)\n    else break\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\")\n  let result = Number(stream.next)\n  stream.pos++\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream)\n    else max = -1\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\")\n  return {type: \"range\", min, max, expr}\n}\n\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name]\n  if (type) return [type]\n  let result = []\n  for (let typeName in types) {\n    let type = types[typeName]\n    if (type.groups.indexOf(name) > -1) result.push(type)\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\")\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream)\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\")\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map(type => {\n      if (stream.inline == null) stream.inline = type.isInline\n      else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\")\n      return {type: \"name\", value: type}\n    })\n    stream.pos++\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\")\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  let nfa = [[]]\n  connect(compile(expr, 0), node())\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    let edge = {term, to}\n    nfa[from].push(edge)\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(edge => edge.to = to) }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])\n    } else if (expr.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr.exprs[i], from)\n        if (i == expr.exprs.length - 1) return next\n        connect(next, from = node())\n      }\n    } else if (expr.type == \"star\") {\n      let loop = node()\n      edge(from, loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      let loop = node()\n      connect(compile(expr.expr, from), loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      let cur = from\n      for (let i = 0; i < expr.min; i++) {\n        let next = node()\n        connect(compile(expr.expr, cur), next)\n        cur = next\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur)\n      } else {\n        for (let i = expr.min; i < expr.max; i++) {\n          let next = node()\n          edge(cur, next)\n          connect(compile(expr.expr, cur), next)\n          cur = next\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  let result = []\n  scan(node)\n  return result.sort(cmp)\n\n  function scan(node) {\n    let edges = nfa[node]\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)\n    result.push(node)\n    for (let i = 0; i < edges.length; i++) {\n      let {term, to} = edges[i]\n      if (!term && result.indexOf(to) == -1) scan(to)\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  let labeled = Object.create(null)\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    let out = []\n    states.forEach(node => {\n      nfa[node].forEach(({term, to}) => {\n        if (!term) return\n        let known = out.indexOf(term), set = known > -1 && out[known + 1]\n        nullFrom(nfa, to).forEach(node => {\n          if (!set) out.push(term, set = [])\n          if (set.indexOf(node) == -1) set.push(node)\n        })\n      })\n    })\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1)\n    for (let i = 0; i < out.length; i += 2) {\n      let states = out[i + 1].sort(cmp)\n      state.next.push(out[i], labeled[states.join(\",\")] || explore(states))\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = []\n    for (let j = 0; j < state.next.length; j += 2) {\n      let node = state.next[j], next = state.next[j + 1]\n      nodes.push(node.name)\n      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false\n      if (work.indexOf(next) == -1) work.push(next)\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\")\n  }\n}\n","import OrderedMap from \"orderedmap\"\n\nimport {Node, TextNode} from \"./node\"\nimport {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {ContentMatch} from \"./content\"\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null)\n  for (let attrName in attrs) {\n    let attr = attrs[attrName]\n    if (!attr.hasDefault) return null\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null)\n  for (let name in attrs) {\n    let given = value && value[name]\n    if (given === undefined) {\n      let attr = attrs[name]\n      if (attr.hasDefault) given = attr.default\n      else throw new RangeError(\"No value supplied for attribute \" + name)\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  let result = Object.create(null)\n  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name])\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nexport class NodeType {\n  constructor(name, schema, spec) {\n    // :: string\n    // The name the node type has in this schema.\n    this.name = name\n\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    this.schema = schema\n\n    // :: NodeSpec\n    // The spec that this type is based on\n    this.spec = spec\n\n    this.groups = spec.group ? spec.group.split(\" \") : []\n    this.attrs = initAttrs(spec.attrs)\n\n    this.defaultAttrs = defaultAttrs(this.attrs)\n\n    // :: ContentMatch\n    // The starting match of the node type's content expression.\n    this.contentMatch = null\n\n    // : ?[MarkType]\n    // The set of marks allowed in this node. `null` means all marks\n    // are allowed.\n    this.markSet = null\n\n    // :: bool\n    // True if this node type has inline content.\n    this.inlineContent = null\n\n    // :: bool\n    // True if this is a block type\n    this.isBlock = !(spec.inline || name == \"text\")\n\n    // :: bool\n    // True if this is the text node type.\n    this.isText = name == \"text\"\n  }\n\n  // :: bool\n  // True if this is an inline type.\n  get isInline() { return !this.isBlock }\n\n  // :: bool\n  // True if this is a textblock type, a block that contains inline\n  // content.\n  get isTextblock() { return this.isBlock && this.inlineContent }\n\n  // :: bool\n  // True for node types that allow no content.\n  get isLeaf() { return this.contentMatch == ContentMatch.empty }\n\n  // :: bool\n  // True when this node is an atom, i.e. when it does not have\n  // directly editable content.\n  get isAtom() { return this.isLeaf || this.spec.atom }\n\n  // :: union<\"pre\", \"normal\">\n  // The node type's [whitespace](#view.NodeSpec.whitespace) option.\n  get whitespace() { return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\") }\n\n  // :: () → bool\n  // Tells you whether this node type has any required attributes.\n  hasRequiredAttrs() {\n    for (let n in this.attrs) if (this.attrs[n].isRequired) return true\n    return false\n  }\n\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch)\n  }\n\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs) return this.defaultAttrs\n    else return computeAttrs(this.attrs, attrs)\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a `Node` of this type. The given attributes are\n  // checked and defaulted (you can pass `null` to use the type's\n  // defaults entirely, if no required attributes exist). `content`\n  // may be a `Fragment`, a node, an array of nodes, or\n  // `null`. Similarly `marks` may be `null` to default to the empty\n  // set of marks.\n  create(attrs, content, marks) {\n    if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\")\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Like [`create`](#model.NodeType.create), but check the given content\n  // against the node type's content restrictions, and throw an error\n  // if it doesn't match.\n  createChecked(attrs, content, marks) {\n    content = Fragment.from(content)\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name)\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n  // Like [`create`](#model.NodeType.create), but see if it is necessary to\n  // add nodes to the start or end of the given fragment to make it\n  // fit the node. If no fitting wrapping can be found, return null.\n  // Note that, due to the fact that required nodes can always be\n  // created, this will always succeed if you pass null or\n  // `Fragment.empty` as content.\n  createAndFill(attrs, content, marks) {\n    attrs = this.computeAttrs(attrs)\n    content = Fragment.from(content)\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content)\n      if (!before) return null\n      content = before.append(content)\n    }\n    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true)\n    if (!after) return null\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n  }\n\n  // :: (Fragment) → bool\n  // Returns true if the given fragment is valid content for this node\n  // type with the given attributes.\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content)\n    if (!result || !result.validEnd) return false\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks)) return false\n    return true\n  }\n\n  // :: (MarkType) → bool\n  // Check whether the given mark type is allowed in this node.\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether the given set of marks are allowed in this node.\n  allowsMarks(marks) {\n    if (this.markSet == null) return true\n    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false\n    return true\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Removes the marks that are not allowed in this node from the given set.\n  allowedMarks(marks) {\n    if (this.markSet == null) return marks\n    let copy\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy) copy = marks.slice(0, i)\n      } else if (copy) {\n        copy.push(marks[i])\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.empty\n  }\n\n  static compile(nodes, schema) {\n    let result = Object.create(null)\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec))\n\n    let topType = schema.spec.topNode || \"doc\"\n    if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\")\n    if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\")\n    for (let _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\")\n\n    return result\n  }\n}\n\n// Attribute descriptors\n\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\")\n    this.default = options.default\n  }\n\n  get isRequired() {\n    return !this.hasDefault\n  }\n}\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nexport class MarkType {\n  constructor(name, rank, schema, spec) {\n    // :: string\n    // The name of the mark type.\n    this.name = name\n\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    this.schema = schema\n\n    // :: MarkSpec\n    // The spec on which the type is based.\n    this.spec = spec\n\n    this.attrs = initAttrs(spec.attrs)\n\n    this.rank = rank\n    this.excluded = null\n    let defaults = defaultAttrs(this.attrs)\n    this.instance = defaults && new Mark(this, defaults)\n  }\n\n  // :: (?Object) → Mark\n  // Create a mark of this type. `attrs` may be `null` or an object\n  // containing only some of the mark's attributes. The others, if\n  // they have defaults, will be added.\n  create(attrs) {\n    if (!attrs && this.instance) return this.instance\n    return new Mark(this, computeAttrs(this.attrs, attrs))\n  }\n\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec))\n    return result\n  }\n\n  // :: ([Mark]) → [Mark]\n  // When there is a mark of this type in the given set, a new set\n  // without it is returned. Otherwise, the input set is returned.\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n      set = set.slice(0, i).concat(set.slice(i + 1))\n      i--\n    }\n    return set\n  }\n\n  // :: ([Mark]) → ?Mark\n  // Tests whether there is a mark of this type in the given set.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this) return set[i]\n  }\n\n  // :: (MarkType) → bool\n  // Queries whether a given mark type is\n  // [excluded](#model.MarkSpec.excludes) by this one.\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1\n  }\n}\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   whitespace:: ?union<\"pre\", \"normal\">\n//   Controls way whitespace in this a node is parsed. The default is\n//   `\"normal\"`, which causes the [DOM parser](#model.DOMParser) to\n//   collapse whitespace in normal mode, and normalize it (replacing\n//   newlines and such with spaces) otherwise. `\"pre\"` causes the\n//   parser to preserve spaces inside the node. When this option isn't\n//   given, but [`code`](#model.NodeSpec.code) is true, `whitespace`\n//   will default to `\"pre\"`. Note that this option doesn't influence\n//   the way the node is rendered—that should be handled by `toDOM`\n//   and/or styling.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nexport class Schema {\n  // :: (SchemaSpec)\n  // Construct a schema from a schema [specification](#model.SchemaSpec).\n  constructor(spec) {\n    // :: SchemaSpec\n    // The [spec](#model.SchemaSpec) on which the schema is based,\n    // with the added guarantee that its `nodes` and `marks`\n    // properties are\n    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n    // (not raw objects).\n    this.spec = {}\n    for (let prop in spec) this.spec[prop] = spec[prop]\n    this.spec.nodes = OrderedMap.from(spec.nodes)\n    this.spec.marks = OrderedMap.from(spec.marks)\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.spec.nodes, this)\n\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.spec.marks, this)\n\n    let contentExprCache = Object.create(null)\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\")\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks\n      type.contentMatch = contentExprCache[contentExpr] ||\n        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))\n      type.inlineContent = type.contentMatch.inlineContent\n      type.markSet = markExpr == \"_\" ? null :\n        markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n        markExpr == \"\" || !type.inlineContent ? [] : null\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"))\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this)\n    this.markFromJSON = this.markFromJSON.bind(this)\n\n    // :: NodeType\n    // The type of the [default top node](#model.SchemaSpec.topNode)\n    // for this schema.\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null)\n    this.cached.wrappings = Object.create(null)\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  node(type, attrs, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type)\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type)\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\")\n\n    return type.createChecked(attrs, content, marks)\n  }\n\n  // :: (string, ?[Mark]) → Node\n  // Create a text node in the schema. Empty text nodes are not\n  // allowed.\n  text(text, marks) {\n    let type = this.nodes.text\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))\n  }\n\n  // :: (union<string, MarkType>, ?Object) → Mark\n  // Create a mark with the given type and attributes.\n  mark(type, attrs) {\n    if (typeof type == \"string\") type = this.marks[type]\n    return type.create(attrs)\n  }\n\n  // :: (Object) → Node\n  // Deserialize a node from its JSON representation. This method is\n  // bound.\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json)\n  }\n\n  // :: (Object) → Mark\n  // Deserialize a mark from its JSON representation. This method is\n  // bound.\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json)\n  }\n\n  nodeType(name) {\n    let found = this.nodes[name]\n    if (!found) throw new RangeError(\"Unknown node type: \" + name)\n    return found\n  }\n}\n\nfunction gatherMarks(schema, marks) {\n  let found = []\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark\n    if (mark) {\n      found.push(mark)\n    } else {\n      for (let prop in schema.marks) {\n        let mark = schema.marks[prop]\n        if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n          found.push(ok = mark)\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\")\n  }\n  return found\n}\n","import {Fragment} from \"./fragment\"\nimport {Slice} from \"./replace\"\nimport {Mark} from \"./mark\"\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nexport class DOMParser {\n  // :: (Schema, [ParseRule])\n  // Create a parser that targets the given schema, using the given\n  // parsing rules.\n  constructor(schema, rules) {\n    // :: Schema\n    // The schema into which the parser parses.\n    this.schema = schema\n    // :: [ParseRule]\n    // The set of [parse rules](#model.ParseRule) that the parser\n    // uses, in order of precedence.\n    this.rules = rules\n    this.tags = []\n    this.styles = []\n\n    rules.forEach(rule => {\n      if (rule.tag) this.tags.push(rule)\n      else if (rule.style) this.styles.push(rule)\n    })\n\n    // Only normalize list elements when lists in the schema can't directly contain themselves\n    this.normalizeLists = !this.tags.some(r => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false\n      let node = schema.nodes[r.node]\n      return node.contentMatch.matchType(node)\n    })\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Node\n  // Parse a document from the content of a DOM node.\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false)\n    context.addAll(dom, null, options.from, options.to)\n    return context.finish()\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Slice\n  // Parses the content of the given DOM node, like\n  // [`parse`](#model.DOMParser.parse), and takes the same set of\n  // options. But unlike that method, which produces a whole node,\n  // this one returns a slice that is open at the sides, meaning that\n  // the schema constraints aren't applied to the start of nodes to\n  // the left of the input and the end of nodes at the end.\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true)\n    context.addAll(dom, null, options.from, options.to)\n    return Slice.maxOpen(context.finish())\n  }\n\n  matchTag(dom, context, after) {\n    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n      let rule = this.tags[i]\n      if (matches(dom, rule.tag) &&\n          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n          (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom)\n          if (result === false) continue\n          rule.attrs = result\n        }\n        return rule\n      }\n    }\n  }\n\n  matchStyle(prop, value, context, after) {\n    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n      let rule = this.styles[i]\n      if (rule.style.indexOf(prop) != 0 ||\n          rule.context && !context.matchesContext(rule.context) ||\n          // Test that the style string either precisely matches the prop,\n          // or has an '=' sign after the prop, followed by the given\n          // value.\n          rule.style.length > prop.length &&\n          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n        continue\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value)\n        if (result === false) continue\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n\n  // : (Schema) → [ParseRule]\n  static schemaRules(schema) {\n    let result = []\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n        if (nextPriority < priority) break\n      }\n      result.splice(i, 0, rule)\n    }\n\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.mark = name\n      })\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.node = name\n      })\n    }\n    return result\n  }\n\n  // :: (Schema) → DOMParser\n  // Construct a DOM parser using the parsing rules listed in a\n  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n  // [priority](#model.ParseRule.priority).\n  static fromSchema(schema) {\n    return schema.cached.domParser ||\n      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n  }\n}\n\n// : Object<bool> The block-level tags in HTML5\nconst blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nconst ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nconst listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4\n\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |\n    (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, pendingMarks, solid, match, options) {\n    this.type = type\n    this.attrs = attrs\n    this.solid = solid\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch)\n    this.options = options\n    this.content = []\n    // Marks applied to this node itself\n    this.marks = marks\n    // Marks applied to its children\n    this.activeMarks = Mark.none\n    // Marks that can't apply here, but will be used in children if possible\n    this.pendingMarks = pendingMarks\n    // Nested Marks with same type\n    this.stashMarks = []\n  }\n\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type) return []\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node))\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill)\n      } else {\n        let start = this.type.contentMatch, wrap\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start\n          return wrap\n        } else {\n          return null\n        }\n      }\n    }\n    return this.match.findWrapping(node.type)\n  }\n\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n      let last = this.content[this.content.length - 1], m\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        if (last.text.length == m[0].length) this.content.pop()\n        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length))\n      }\n    }\n    let content = Fragment.from(this.content)\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true))\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content\n  }\n\n  popFromStashMark(mark) {\n    for (let i = this.stashMarks.length - 1; i >= 0; i--)\n      if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0]\n  }\n\n  applyPending(nextType) {\n    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n      let mark = pending[i]\n      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n          !mark.isInSet(this.activeMarks)) {\n        this.activeMarks = mark.addToSet(this.activeMarks)\n        this.pendingMarks = mark.removeFromSet(this.pendingMarks)\n      }\n    }\n  }\n\n  inlineContext(node) {\n    if (this.type) return this.type.inlineContent\n    if (this.content.length) return this.content[0].isInline\n    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())\n  }\n}\n\nclass ParseContext {\n  // : (DOMParser, Object)\n  constructor(parser, options, open) {\n    // : DOMParser The parser we are using.\n    this.parser = parser\n    // : Object The options passed to this parse.\n    this.options = options\n    this.isOpen = open\n    let topNode = options.topNode, topContext\n    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0)\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                   options.topMatch || topNode.type.contentMatch, topOptions)\n    else if (open)\n      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions)\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions)\n    this.nodes = [topContext]\n    // : [Mark] The current set of marks\n    this.open = 0\n    this.find = options.findPositions\n    this.needsBlock = false\n  }\n\n  get top() {\n    return this.nodes[this.open]\n  }\n\n  // : (dom.Node)\n  // Add a DOM node to the content. Text is inserted as text node,\n  // otherwise, the node is passed to `addElement` or, if it has a\n  // `style` attribute, `addElementWithStyles`.\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom)\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\")\n      let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i])\n      this.addElement(dom)\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i], top)\n    }\n  }\n\n  addTextNode(dom) {\n    let value = dom.nodeValue\n    let top = this.top\n    if (top.options & OPT_PRESERVE_WS_FULL ||\n        top.inlineContext(dom) ||\n        /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \")\n        // If this starts with whitespace, and there is no node before it, or\n        // a hard break, or a text node that ends with whitespace, strip the\n        // leading space.\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1]\n          let domNodeBefore = dom.previousSibling\n          if (!nodeBefore ||\n              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n              (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n            value = value.slice(1)\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \")\n      } else {\n        value = value.replace(/\\r\\n?/g, \"\\n\")\n      }\n      if (value) this.insertNode(this.parser.schema.text(value))\n      this.findInText(dom)\n    } else {\n      this.findInside(dom)\n    }\n  }\n\n  // : (dom.Element, ?ParseRule)\n  // Try to find a handler for the given tag and use that to parse. If\n  // none is found, the element's content nodes are added directly.\n  addElement(dom, matchAfter) {\n    let name = dom.nodeName.toLowerCase(), ruleID\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom)\n    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n        (ruleID = this.parser.matchTag(dom, this, matchAfter))\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom)\n      this.ignoreFallback(dom)\n    } else if (!rule || rule.skip || rule.closeParent) {\n      if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1)\n      else if (rule && rule.skip.nodeType) dom = rule.skip\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true\n        if (!top.type) this.needsBlock = true\n      } else if (!dom.firstChild) {\n        this.leafFallback(dom)\n        return\n      }\n      this.addAll(dom)\n      if (sync) this.sync(top)\n      this.needsBlock = oldNeedsBlock\n    } else {\n      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null)\n    }\n  }\n\n  // Called for leaf DOM nodes that would otherwise be ignored\n  leafFallback(dom) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"))\n  }\n\n  // Called for ignored nodes\n  ignoreFallback(dom) {\n    // Ignored BR nodes should at least create an inline context\n    if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n      this.findPlace(this.parser.schema.text(\"-\"))\n  }\n\n  // Run any style parser associated with the node's styles. Either\n  // return an array of marks, or null to indicate some of the styles\n  // had a rule with `ignore` set.\n  readStyles(styles) {\n    let marks = Mark.none\n    style: for (let i = 0; i < styles.length; i += 2) {\n      for (let after = null;;) {\n        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after)\n        if (!rule) continue style\n        if (rule.ignore) return null\n        marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks)\n        if (rule.consuming === false) after = rule\n        else break\n      }\n    }\n    return marks\n  }\n\n  // : (dom.Element, ParseRule) → bool\n  // Look up a handler for the given node. If none are found, return\n  // false. Otherwise, apply it, use its return value to drive the way\n  // the node's content is wrapped, and return true.\n  addElementByRule(dom, rule, continueAfter) {\n    let sync, nodeType, markType, mark\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node]\n      if (!nodeType.isLeaf) {\n        sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace)\n      } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n        this.leafFallback(dom)\n      }\n    } else {\n      markType = this.parser.schema.marks[rule.mark]\n      mark = markType.create(rule.attrs)\n      this.addPendingMark(mark)\n    }\n    let startIn = this.top\n\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom)\n    } else if (continueAfter) {\n      this.addElement(dom, continueAfter)\n    } else if (rule.getContent) {\n      this.findInside(dom)\n      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node))\n    } else {\n      let contentDOM = rule.contentElement\n      if (typeof contentDOM == \"string\") contentDOM = dom.querySelector(contentDOM)\n      else if (typeof contentDOM == \"function\") contentDOM = contentDOM(dom)\n      if (!contentDOM) contentDOM = dom\n      this.findAround(dom, contentDOM, true)\n      this.addAll(contentDOM, sync)\n    }\n    if (sync) { this.sync(startIn); this.open-- }\n    if (mark) this.removePendingMark(mark, startIn)\n  }\n\n  // : (dom.Node, ?NodeBuilder, ?number, ?number)\n  // Add all child nodes between `startIndex` and `endIndex` (or the\n  // whole node, if not given). If `sync` is passed, use it to\n  // synchronize after every block element.\n  addAll(parent, sync, startIndex, endIndex) {\n    let index = startIndex || 0\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n             end = endIndex == null ? null : parent.childNodes[endIndex];\n         dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index)\n      this.addDOM(dom)\n      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n        this.sync(sync)\n    }\n    this.findAtPoint(parent, index)\n  }\n\n  // Try to find a way to fit the given node type into the current\n  // context. May add intermediate wrappers and/or leave non-solid\n  // nodes that we're in.\n  findPlace(node) {\n    let route, sync\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth]\n      let found = cx.findWrapping(node)\n      if (found && (!route || route.length > found.length)) {\n        route = found\n        sync = cx\n        if (!found.length) break\n      }\n      if (cx.solid) break\n    }\n    if (!route) return false\n    this.sync(sync)\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false)\n    return true\n  }\n\n  // : (Node) → ?Node\n  // Try to insert the given node, adjusting the context when needed.\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext()\n      if (block) this.enterInner(block)\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra()\n      let top = this.top\n      top.applyPending(node.type)\n      if (top.match) top.match = top.match.matchType(node.type)\n      let marks = top.activeMarks\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks)\n      top.content.push(node.mark(marks))\n      return true\n    }\n    return false\n  }\n\n  // : (NodeType, ?Object) → bool\n  // Try to start a node of the given type, adjusting the context when\n  // necessary.\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs))\n    if (ok) this.enterInner(type, attrs, true, preserveWS)\n    return ok\n  }\n\n  // Open a node of the given type\n  enterInner(type, attrs, solid, preserveWS) {\n    this.closeExtra()\n    let top = this.top\n    top.applyPending(type)\n    top.match = top.match && top.match.matchType(type, attrs)\n    let options = wsOptionsFor(type, preserveWS, top.options)\n    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options))\n    this.open++\n  }\n\n  // Make sure all nodes above this.open are finished and added to\n  // their parents\n  closeExtra(openEnd) {\n    let i = this.nodes.length - 1\n    if (i > this.open) {\n      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd))\n      this.nodes.length = this.open + 1\n    }\n  }\n\n  finish() {\n    this.open = 0\n    this.closeExtra(this.isOpen)\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n  }\n\n  sync(to) {\n    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {\n      this.open = i\n      return\n    }\n  }\n\n  get currentPos() {\n    this.closeExtra()\n    let pos = 0\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize\n      if (i) pos++\n    }\n    return pos\n  }\n\n  findAtPoint(parent, offset) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset)\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findInside(parent) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findAround(parent, content, before) {\n    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        let pos = content.compareDocumentPosition(this.find[i].node)\n        if (pos & (before ? 2 : 4))\n          this.find[i].pos = this.currentPos\n      }\n    }\n  }\n\n  findInText(textNode) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode)\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset)\n    }\n  }\n\n  // : (string) → bool\n  // Determines whether the given [context\n  // string](#ParseRule.context) matches this context.\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this)\n\n    let parts = context.split(\"/\")\n    let option = this.options.context\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type)\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1)\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i]\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0) continue\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth)) return true\n          return false\n        } else {\n          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n              : option && depth >= minDepth ? option.node(depth - minDepth).type\n              : null\n          if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n            return false\n          depth--\n        }\n      }\n      return true\n    }\n    return match(parts.length - 1, this.open)\n  }\n\n  textblockFromContext() {\n    let $context = this.options.context\n    if ($context) for (let d = $context.depth; d >= 0; d--) {\n      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt\n    }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name]\n      if (type.isTextblock && type.defaultAttrs) return type\n    }\n  }\n\n  addPendingMark(mark) {\n    let found = findSameMarkInSet(mark, this.top.pendingMarks)\n    if (found) this.top.stashMarks.push(found)\n    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks)\n  }\n\n  removePendingMark(mark, upto) {\n    for (let depth = this.open; depth >= 0; depth--) {\n      let level = this.nodes[depth]\n      let found = level.pendingMarks.lastIndexOf(mark)\n      if (found > -1) {\n        level.pendingMarks = mark.removeFromSet(level.pendingMarks)\n      } else {\n        level.activeMarks = mark.removeFromSet(level.activeMarks)\n        let stashMark = level.popFromStashMark(mark)\n        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n          level.activeMarks = stashMark.addToSet(level.activeMarks)\n      }\n      if (level == upto) break\n    }\n  }\n}\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) result.push(m[1], m[2].trim())\n  return result\n}\n\nfunction copy(obj) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes\n  for (let name in nodes) {\n    let parent = nodes[name]\n    if (!parent.allowsMarkType(markType)) continue\n    let seen = [], scan = match => {\n      seen.push(match)\n      for (let i = 0; i < match.edgeCount; i++) {\n        let {type, next} = match.edge(i)\n        if (type == nodeType) return true\n        if (seen.indexOf(next) < 0 && scan(next)) return true\n      }\n    }\n    if (scan(parent.contentMatch)) return true\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (let i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) return set[i]\n  }\n}\n","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nexport class DOMSerializer {\n  // :: (Object<(node: Node) → DOMOutputSpec>, Object<?(mark: Mark, inline: bool) → DOMOutputSpec>)\n  // Create a serializer. `nodes` should map node names to functions\n  // that take a node and return a description of the corresponding\n  // DOM. `marks` does the same for mark names, but also gets an\n  // argument that tells it whether the mark's content is block or\n  // inline content (for typical use, it'll always be inline). A mark\n  // serializer may be `null` to indicate that marks of that type\n  // should not be serialized.\n  constructor(nodes, marks) {\n    // :: Object<(node: Node) → DOMOutputSpec>\n    // The node serialization functions.\n    this.nodes = nodes || {}\n    // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n    // The mark serialization functions.\n    this.marks = marks || {}\n  }\n\n  // :: (Fragment, ?Object) → dom.DocumentFragment\n  // Serialize the content of this fragment to a DOM fragment. When\n  // not in the browser, the `document` option, containing a DOM\n  // document, should be passed so that the serializer can create\n  // nodes.\n  serializeFragment(fragment, options = {}, target) {\n    if (!target) target = doc(options).createDocumentFragment()\n\n    let top = target, active = null\n    fragment.forEach(node => {\n      if (active || node.marks.length) {\n        if (!active) active = []\n        let keep = 0, rendered = 0\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered]\n          if (!this.marks[next.type.name]) { rendered++; continue }\n          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break\n          keep += 2; rendered++\n        }\n        while (keep < active.length) {\n          top = active.pop()\n          active.pop()\n        }\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++]\n          let markDOM = this.serializeMark(add, node.isInline, options)\n          if (markDOM) {\n            active.push(add, top)\n            top.appendChild(markDOM.dom)\n            top = markDOM.contentDOM || markDOM.dom\n          }\n        }\n      }\n      top.appendChild(this.serializeNodeInner(node, options))\n    })\n\n    return target\n  }\n\n  serializeNodeInner(node, options = {}) {\n    let {dom, contentDOM} =\n        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node))\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\")\n      if (options.onContent)\n        options.onContent(node, contentDOM, options)\n      else\n        this.serializeFragment(node.content, options, contentDOM)\n    }\n    return dom\n  }\n\n  // :: (Node, ?Object) → dom.Node\n  // Serialize this node to a DOM node. This can be useful when you\n  // need to serialize a part of a document, as opposed to the whole\n  // document. To serialize a whole document, use\n  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n  // its [content](#model.Node.content).\n  serializeNode(node, options = {}) {\n    let dom = this.serializeNodeInner(node, options)\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options)\n      if (wrap) {\n        ;(wrap.contentDOM || wrap.dom).appendChild(dom)\n        dom = wrap.dom\n      }\n    }\n    return dom\n  }\n\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name]\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n  }\n\n  // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n  // the spec has a hole (zero) in it, `contentDOM` will point at the\n  // node with the hole.\n  static renderSpec(doc, structure, xmlNS = null) {\n    if (typeof structure == \"string\")\n      return {dom: doc.createTextNode(structure)}\n    if (structure.nodeType != null)\n      return {dom: structure}\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure\n    let tagName = structure[0], space = tagName.indexOf(\" \")\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space)\n      tagName = tagName.slice(space + 1)\n    }\n    let contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName)\n    let attrs = structure[1], start = 1\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2\n      for (let name in attrs) if (attrs[name] != null) {\n        let space = name.indexOf(\" \")\n        if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name])\n        else dom.setAttribute(name, attrs[name])\n      }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i]\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\")\n        return {dom, contentDOM: dom}\n      } else {\n        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child, xmlNS)\n        dom.appendChild(inner)\n        if (innerContent) {\n          if (contentDOM) throw new RangeError(\"Multiple content holes\")\n          contentDOM = innerContent\n        }\n      }\n    }\n    return {dom, contentDOM}\n  }\n\n  // :: (Schema) → DOMSerializer\n  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n  // properties in a schema's node and mark specs.\n  static fromSchema(schema) {\n    return schema.cached.domSerializer ||\n      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n  }\n\n  // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n  // Gather the serializers in a schema's node specs into an object.\n  // This can be useful as a base to build a custom serializer from.\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes)\n    if (!result.text) result.text = node => node.text\n    return result\n  }\n\n  // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n  // Gather the serializers in a schema's mark specs into an object.\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks)\n  }\n}\n\nfunction gatherToDOM(obj) {\n  let result = {}\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM\n    if (toDOM) result[name] = toDOM\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n"]},"metadata":{},"sourceType":"module"}