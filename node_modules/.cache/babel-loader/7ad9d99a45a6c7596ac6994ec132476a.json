{"ast":null,"code":"import { ReplaceError, Slice, Fragment, MarkType } from 'prosemirror-model'; // Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\n\nfunction makeRecover(index, offset) {\n  return index + offset * factor16;\n}\n\nfunction recoverIndex(value) {\n  return value & lower16;\n}\n\nfunction recoverOffset(value) {\n  return (value - (value & lower16)) / factor16;\n} // ::- An object representing a mapped position with extra\n// information.\n\n\nvar MapResult = function MapResult(pos, deleted, recover) {\n  if (deleted === void 0) deleted = false;\n  if (recover === void 0) recover = null; // :: number The mapped version of the position.\n\n  this.pos = pos; // :: bool Tells you whether the position was deleted, that is,\n  // whether the step removed its surroundings from the document.\n\n  this.deleted = deleted;\n  this.recover = recover;\n}; // :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\n\n\nvar StepMap = function StepMap(ranges, inverted) {\n  if (inverted === void 0) inverted = false;\n\n  if (!ranges.length && StepMap.empty) {\n    return StepMap.empty;\n  }\n\n  this.ranges = ranges;\n  this.inverted = inverted;\n};\n\nStepMap.prototype.recover = function recover(value) {\n  var diff = 0,\n      index = recoverIndex(value);\n\n  if (!this.inverted) {\n    for (var i = 0; i < index; i++) {\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n    }\n  }\n\n  return this.ranges[index * 3] + diff + recoverOffset(value);\n}; // : (number, ?number) → MapResult\n\n\nStepMap.prototype.mapResult = function mapResult(pos, assoc) {\n  if (assoc === void 0) assoc = 1;\n  return this._map(pos, assoc, false);\n}; // : (number, ?number) → number\n\n\nStepMap.prototype.map = function map(pos, assoc) {\n  if (assoc === void 0) assoc = 1;\n  return this._map(pos, assoc, true);\n};\n\nStepMap.prototype._map = function _map(pos, assoc, simple) {\n  var diff = 0,\n      oldIndex = this.inverted ? 2 : 1,\n      newIndex = this.inverted ? 1 : 2;\n\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n\n    if (start > pos) {\n      break;\n    }\n\n    var oldSize = this.ranges[i + oldIndex],\n        newSize = this.ranges[i + newIndex],\n        end = start + oldSize;\n\n    if (pos <= end) {\n      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n      var result = start + diff + (side < 0 ? 0 : newSize);\n\n      if (simple) {\n        return result;\n      }\n\n      var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover);\n    }\n\n    diff += newSize - oldSize;\n  }\n\n  return simple ? pos + diff : new MapResult(pos + diff);\n};\n\nStepMap.prototype.touches = function touches(pos, recover) {\n  var diff = 0,\n      index = recoverIndex(recover);\n  var oldIndex = this.inverted ? 2 : 1,\n      newIndex = this.inverted ? 1 : 2;\n\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n\n    if (start > pos) {\n      break;\n    }\n\n    var oldSize = this.ranges[i + oldIndex],\n        end = start + oldSize;\n\n    if (pos <= end && i == index * 3) {\n      return true;\n    }\n\n    diff += this.ranges[i + newIndex] - oldSize;\n  }\n\n  return false;\n}; // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n// Calls the given function on each of the changed ranges included in\n// this map.\n\n\nStepMap.prototype.forEach = function forEach(f) {\n  var oldIndex = this.inverted ? 2 : 1,\n      newIndex = this.inverted ? 1 : 2;\n\n  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i],\n        oldStart = start - (this.inverted ? diff : 0),\n        newStart = start + (this.inverted ? 0 : diff);\n    var oldSize = this.ranges[i + oldIndex],\n        newSize = this.ranges[i + newIndex];\n    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n    diff += newSize - oldSize;\n  }\n}; // :: () → StepMap\n// Create an inverted version of this map. The result can be used to\n// map positions in the post-step document to the pre-step document.\n\n\nStepMap.prototype.invert = function invert() {\n  return new StepMap(this.ranges, !this.inverted);\n};\n\nStepMap.prototype.toString = function toString() {\n  return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n}; // :: (n: number) → StepMap\n// Create a map that moves all positions by offset `n` (which may be\n// negative). This can be useful when applying steps meant for a\n// sub-document to a larger document, or vice-versa.\n\n\nStepMap.offset = function offset(n) {\n  return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n};\n\nStepMap.empty = new StepMap([]); // :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\n\nvar Mapping = function Mapping(maps, mirror, from, to) {\n  // :: [StepMap]\n  // The step maps in this mapping.\n  this.maps = maps || []; // :: number\n  // The starting position in the `maps` array, used when `map` or\n  // `mapResult` is called.\n\n  this.from = from || 0; // :: number\n  // The end position in the `maps` array.\n\n  this.to = to == null ? this.maps.length : to;\n  this.mirror = mirror;\n}; // :: (?number, ?number) → Mapping\n// Create a mapping that maps only through a part of this one.\n\n\nMapping.prototype.slice = function slice(from, to) {\n  if (from === void 0) from = 0;\n  if (to === void 0) to = this.maps.length;\n  return new Mapping(this.maps, this.mirror, from, to);\n};\n\nMapping.prototype.copy = function copy() {\n  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n}; // :: (StepMap, ?number)\n// Add a step map to the end of this mapping. If `mirrors` is\n// given, it should be the index of the step map that is the mirror\n// image of this one.\n\n\nMapping.prototype.appendMap = function appendMap(map, mirrors) {\n  this.to = this.maps.push(map);\n\n  if (mirrors != null) {\n    this.setMirror(this.maps.length - 1, mirrors);\n  }\n}; // :: (Mapping)\n// Add all the step maps in a given mapping to this one (preserving\n// mirroring information).\n\n\nMapping.prototype.appendMapping = function appendMapping(mapping) {\n  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);\n  }\n}; // :: (number) → ?number\n// Finds the offset of the step map that mirrors the map at the\n// given offset, in this mapping (as per the second argument to\n// `appendMap`).\n\n\nMapping.prototype.getMirror = function getMirror(n) {\n  if (this.mirror) {\n    for (var i = 0; i < this.mirror.length; i++) {\n      if (this.mirror[i] == n) {\n        return this.mirror[i + (i % 2 ? -1 : 1)];\n      }\n    }\n  }\n};\n\nMapping.prototype.setMirror = function setMirror(n, m) {\n  if (!this.mirror) {\n    this.mirror = [];\n  }\n\n  this.mirror.push(n, m);\n}; // :: (Mapping)\n// Append the inverse of the given mapping to this one.\n\n\nMapping.prototype.appendMappingInverted = function appendMappingInverted(mapping) {\n  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);\n  }\n}; // :: () → Mapping\n// Create an inverted version of this mapping.\n\n\nMapping.prototype.invert = function invert() {\n  var inverse = new Mapping();\n  inverse.appendMappingInverted(this);\n  return inverse;\n}; // : (number, ?number) → number\n// Map a position through this mapping.\n\n\nMapping.prototype.map = function map(pos, assoc) {\n  if (assoc === void 0) assoc = 1;\n\n  if (this.mirror) {\n    return this._map(pos, assoc, true);\n  }\n\n  for (var i = this.from; i < this.to; i++) {\n    pos = this.maps[i].map(pos, assoc);\n  }\n\n  return pos;\n}; // : (number, ?number) → MapResult\n// Map a position through this mapping, returning a mapping\n// result.\n\n\nMapping.prototype.mapResult = function mapResult(pos, assoc) {\n  if (assoc === void 0) assoc = 1;\n  return this._map(pos, assoc, false);\n};\n\nMapping.prototype._map = function _map(pos, assoc, simple) {\n  var deleted = false;\n\n  for (var i = this.from; i < this.to; i++) {\n    var map = this.maps[i],\n        result = map.mapResult(pos, assoc);\n\n    if (result.recover != null) {\n      var corr = this.getMirror(i);\n\n      if (corr != null && corr > i && corr < this.to) {\n        i = corr;\n        pos = this.maps[corr].recover(result.recover);\n        continue;\n      }\n    }\n\n    if (result.deleted) {\n      deleted = true;\n    }\n\n    pos = result.pos;\n  }\n\n  return simple ? pos : new MapResult(pos, deleted);\n};\n\nfunction TransformError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = TransformError.prototype;\n  return err;\n}\n\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\"; // ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\n\nvar Transform = function Transform(doc) {\n  // :: Node\n  // The current document (the result of applying the steps in the\n  // transform).\n  this.doc = doc; // :: [Step]\n  // The steps in this transform.\n\n  this.steps = []; // :: [Node]\n  // The documents before each of the steps.\n\n  this.docs = []; // :: Mapping\n  // A mapping with the maps for each of the steps in this transform.\n\n  this.mapping = new Mapping();\n};\n\nvar prototypeAccessors = {\n  before: {\n    configurable: true\n  },\n  docChanged: {\n    configurable: true\n  }\n}; // :: Node The starting document.\n\nprototypeAccessors.before.get = function () {\n  return this.docs.length ? this.docs[0] : this.doc;\n}; // :: (step: Step) → this\n// Apply a new step in this transform, saving the result. Throws an\n// error when the step fails.\n\n\nTransform.prototype.step = function step(object) {\n  var result = this.maybeStep(object);\n\n  if (result.failed) {\n    throw new TransformError(result.failed);\n  }\n\n  return this;\n}; // :: (Step) → StepResult\n// Try to apply a step in this transformation, ignoring it if it\n// fails. Returns the step result.\n\n\nTransform.prototype.maybeStep = function maybeStep(step) {\n  var result = step.apply(this.doc);\n\n  if (!result.failed) {\n    this.addStep(step, result.doc);\n  }\n\n  return result;\n}; // :: bool\n// True when the document has been changed (when there are any\n// steps).\n\n\nprototypeAccessors.docChanged.get = function () {\n  return this.steps.length > 0;\n};\n\nTransform.prototype.addStep = function addStep(step, doc) {\n  this.docs.push(this.doc);\n  this.steps.push(step);\n  this.mapping.appendMap(step.getMap());\n  this.doc = doc;\n};\n\nObject.defineProperties(Transform.prototype, prototypeAccessors);\n\nfunction mustOverride() {\n  throw new Error(\"Override me\");\n}\n\nvar stepsByID = Object.create(null); // ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\n\nvar Step = function Step() {};\n\nStep.prototype.apply = function apply(_doc) {\n  return mustOverride();\n}; // :: () → StepMap\n// Get the step map that represents the changes made by this step,\n// and which can be used to transform between positions in the old\n// and the new document.\n\n\nStep.prototype.getMap = function getMap() {\n  return StepMap.empty;\n}; // :: (doc: Node) → Step\n// Create an inverted version of this step. Needs the document as it\n// was before the step as argument.\n\n\nStep.prototype.invert = function invert(_doc) {\n  return mustOverride();\n}; // :: (mapping: Mappable) → ?Step\n// Map this step through a mappable thing, returning either a\n// version of that step with its positions adjusted, or `null` if\n// the step was entirely deleted by the mapping.\n\n\nStep.prototype.map = function map(_mapping) {\n  return mustOverride();\n}; // :: (other: Step) → ?Step\n// Try to merge this step with another one, to be applied directly\n// after it. Returns the merged step when possible, null if the\n// steps can't be merged.\n\n\nStep.prototype.merge = function merge(_other) {\n  return null;\n}; // :: () → Object\n// Create a JSON-serializeable representation of this step. When\n// defining this for a custom subclass, make sure the result object\n// includes the step type's [JSON id](#transform.Step^jsonID) under\n// the `stepType` property.\n\n\nStep.prototype.toJSON = function toJSON() {\n  return mustOverride();\n}; // :: (Schema, Object) → Step\n// Deserialize a step from its JSON representation. Will call\n// through to the step class' own implementation of this method.\n\n\nStep.fromJSON = function fromJSON(schema, json) {\n  if (!json || !json.stepType) {\n    throw new RangeError(\"Invalid input for Step.fromJSON\");\n  }\n\n  var type = stepsByID[json.stepType];\n\n  if (!type) {\n    throw new RangeError(\"No step type \" + json.stepType + \" defined\");\n  }\n\n  return type.fromJSON(schema, json);\n}; // :: (string, constructor<Step>)\n// To be able to serialize steps to JSON, each step needs a string\n// ID to attach to its JSON representation. Use this method to\n// register an ID for your step classes. Try to pick something\n// that's unlikely to clash with steps from other modules.\n\n\nStep.jsonID = function jsonID(id, stepClass) {\n  if (id in stepsByID) {\n    throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n  }\n\n  stepsByID[id] = stepClass;\n  stepClass.prototype.jsonID = id;\n  return stepClass;\n}; // ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\n\n\nvar StepResult = function StepResult(doc, failed) {\n  // :: ?Node The transformed document.\n  this.doc = doc; // :: ?string Text providing information about a failed step.\n\n  this.failed = failed;\n}; // :: (Node) → StepResult\n// Create a successful step result.\n\n\nStepResult.ok = function ok(doc) {\n  return new StepResult(doc, null);\n}; // :: (string) → StepResult\n// Create a failed step result.\n\n\nStepResult.fail = function fail(message) {\n  return new StepResult(null, message);\n}; // :: (Node, number, number, Slice) → StepResult\n// Call [`Node.replace`](#model.Node.replace) with the given\n// arguments. Create a successful result if it succeeds, and a\n// failed one if it throws a `ReplaceError`.\n\n\nStepResult.fromReplace = function fromReplace(doc, from, to, slice) {\n  try {\n    return StepResult.ok(doc.replace(from, to, slice));\n  } catch (e) {\n    if (e instanceof ReplaceError) {\n      return StepResult.fail(e.message);\n    }\n\n    throw e;\n  }\n}; // ::- Replace a part of the document with a slice of new content.\n\n\nvar ReplaceStep = /*@__PURE__*/function (Step) {\n  function ReplaceStep(from, to, slice, structure) {\n    Step.call(this); // :: number\n    // The start position of the replaced range.\n\n    this.from = from; // :: number\n    // The end position of the replaced range.\n\n    this.to = to; // :: Slice\n    // The slice to insert.\n\n    this.slice = slice;\n    this.structure = !!structure;\n  }\n\n  if (Step) ReplaceStep.__proto__ = Step;\n  ReplaceStep.prototype = Object.create(Step && Step.prototype);\n  ReplaceStep.prototype.constructor = ReplaceStep;\n\n  ReplaceStep.prototype.apply = function apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to)) {\n      return StepResult.fail(\"Structure replace would overwrite content\");\n    }\n\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n  };\n\n  ReplaceStep.prototype.getMap = function getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size]);\n  };\n\n  ReplaceStep.prototype.invert = function invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n  };\n\n  ReplaceStep.prototype.map = function map(mapping) {\n    var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n\n    if (from.deleted && to.deleted) {\n      return null;\n    }\n\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n  };\n\n  ReplaceStep.prototype.merge = function merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) {\n      return null;\n    }\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      var slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n      return new ReplaceStep(other.from, this.to, slice$1, this.structure);\n    } else {\n      return null;\n    }\n  };\n\n  ReplaceStep.prototype.toJSON = function toJSON() {\n    var json = {\n      stepType: \"replace\",\n      from: this.from,\n      to: this.to\n    };\n\n    if (this.slice.size) {\n      json.slice = this.slice.toJSON();\n    }\n\n    if (this.structure) {\n      json.structure = true;\n    }\n\n    return json;\n  };\n\n  ReplaceStep.fromJSON = function fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\") {\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n    }\n\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);\n  };\n\n  return ReplaceStep;\n}(Step);\n\nStep.jsonID(\"replace\", ReplaceStep); // ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\n\nvar ReplaceAroundStep = /*@__PURE__*/function (Step) {\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {\n    Step.call(this); // :: number\n    // The start position of the replaced range.\n\n    this.from = from; // :: number\n    // The end position of the replaced range.\n\n    this.to = to; // :: number\n    // The start of preserved range.\n\n    this.gapFrom = gapFrom; // :: number\n    // The end of preserved range.\n\n    this.gapTo = gapTo; // :: Slice\n    // The slice to insert.\n\n    this.slice = slice; // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n\n    this.insert = insert;\n    this.structure = !!structure;\n  }\n\n  if (Step) ReplaceAroundStep.__proto__ = Step;\n  ReplaceAroundStep.prototype = Object.create(Step && Step.prototype);\n  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;\n\n  ReplaceAroundStep.prototype.apply = function apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) {\n      return StepResult.fail(\"Structure gap-replace would overwrite content\");\n    }\n\n    var gap = doc.slice(this.gapFrom, this.gapTo);\n\n    if (gap.openStart || gap.openEnd) {\n      return StepResult.fail(\"Gap is not a flat range\");\n    }\n\n    var inserted = this.slice.insertAt(this.insert, gap.content);\n\n    if (!inserted) {\n      return StepResult.fail(\"Content does not fit in gap\");\n    }\n\n    return StepResult.fromReplace(doc, this.from, this.to, inserted);\n  };\n\n  ReplaceAroundStep.prototype.getMap = function getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n  };\n\n  ReplaceAroundStep.prototype.invert = function invert(doc) {\n    var gap = this.gapTo - this.gapFrom;\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n  };\n\n  ReplaceAroundStep.prototype.map = function map(mapping) {\n    var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n    var gapFrom = mapping.map(this.gapFrom, -1),\n        gapTo = mapping.map(this.gapTo, 1);\n\n    if (from.deleted && to.deleted || gapFrom < from.pos || gapTo > to.pos) {\n      return null;\n    }\n\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n  };\n\n  ReplaceAroundStep.prototype.toJSON = function toJSON() {\n    var json = {\n      stepType: \"replaceAround\",\n      from: this.from,\n      to: this.to,\n      gapFrom: this.gapFrom,\n      gapTo: this.gapTo,\n      insert: this.insert\n    };\n\n    if (this.slice.size) {\n      json.slice = this.slice.toJSON();\n    }\n\n    if (this.structure) {\n      json.structure = true;\n    }\n\n    return json;\n  };\n\n  ReplaceAroundStep.fromJSON = function fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\") {\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n    }\n\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n  };\n\n  return ReplaceAroundStep;\n}(Step);\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\n\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from),\n      dist = to - from,\n      depth = $from.depth;\n\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n\n    while (dist > 0) {\n      if (!next || next.isLeaf) {\n        return true;\n      }\n\n      next = next.firstChild;\n      dist--;\n    }\n  }\n\n  return false;\n}\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n} // :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\n\n\nfunction liftTarget(range) {\n  var parent = range.parent;\n  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n\n  for (var depth = range.depth;; --depth) {\n    var node = range.$from.node(depth);\n    var index = range.$from.index(depth),\n        endIndex = range.$to.indexAfter(depth);\n\n    if (depth < range.depth && node.canReplace(index, endIndex, content)) {\n      return depth;\n    }\n\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) {\n      break;\n    }\n  }\n} // :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\n\n\nTransform.prototype.lift = function (range, target) {\n  var $from = range.$from;\n  var $to = range.$to;\n  var depth = range.depth;\n  var gapStart = $from.before(depth + 1),\n      gapEnd = $to.after(depth + 1);\n  var start = gapStart,\n      end = gapEnd;\n  var before = Fragment.empty,\n      openStart = 0;\n\n  for (var d = depth, splitting = false; d > target; d--) {\n    if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = Fragment.from($from.node(d).copy(before));\n      openStart++;\n    } else {\n      start--;\n    }\n  }\n\n  var after = Fragment.empty,\n      openEnd = 0;\n\n  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {\n    if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {\n      splitting$1 = true;\n      after = Fragment.from($to.node(d$1).copy(after));\n      openEnd++;\n    } else {\n      end++;\n    }\n  }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}; // :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\n\n\nfunction findWrapping(range, nodeType, attrs, innerRange) {\n  if (innerRange === void 0) innerRange = range;\n  var around = findWrappingOutside(range, nodeType);\n  var inner = around && findWrappingInside(innerRange, nodeType);\n\n  if (!inner) {\n    return null;\n  }\n\n  return around.map(withAttrs).concat({\n    type: nodeType,\n    attrs: attrs\n  }).concat(inner.map(withAttrs));\n}\n\nfunction withAttrs(type) {\n  return {\n    type: type,\n    attrs: null\n  };\n}\n\nfunction findWrappingOutside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var around = parent.contentMatchAt(startIndex).findWrapping(type);\n\n  if (!around) {\n    return null;\n  }\n\n  var outer = around.length ? around[0] : type;\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\n\nfunction findWrappingInside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var inner = parent.child(startIndex);\n  var inside = type.contentMatch.findWrapping(inner.type);\n\n  if (!inside) {\n    return null;\n  }\n\n  var lastType = inside.length ? inside[inside.length - 1] : type;\n  var innerMatch = lastType.contentMatch;\n\n  for (var i = startIndex; innerMatch && i < endIndex; i++) {\n    innerMatch = innerMatch.matchType(parent.child(i).type);\n  }\n\n  if (!innerMatch || !innerMatch.validEnd) {\n    return null;\n  }\n\n  return inside;\n} // :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\n\n\nTransform.prototype.wrap = function (range, wrappers) {\n  var content = Fragment.empty;\n\n  for (var i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      var match = wrappers[i].type.contentMatch.matchFragment(content);\n\n      if (!match || !match.validEnd) {\n        throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n      }\n    }\n\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  }\n\n  var start = range.start,\n      end = range.end;\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));\n}; // :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\n\n\nTransform.prototype.setBlockType = function (from, to, type, attrs) {\n  var this$1 = this;\n  if (to === void 0) to = from;\n\n  if (!type.isTextblock) {\n    throw new RangeError(\"Type given to setBlockType should be a textblock\");\n  }\n\n  var mapFrom = this.steps.length;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);\n      var mapping = this$1.mapping.slice(mapFrom);\n      var startM = mapping.map(pos, 1),\n          endM = mapping.map(pos + node.nodeSize, 1);\n      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n      return false;\n    }\n  });\n  return this;\n};\n\nfunction canChangeType(doc, pos, type) {\n  var $pos = doc.resolve(pos),\n      index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type);\n} // :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\n\n\nTransform.prototype.setNodeMarkup = function (pos, type, attrs, marks) {\n  var node = this.doc.nodeAt(pos);\n\n  if (!node) {\n    throw new RangeError(\"No node at given position\");\n  }\n\n  if (!type) {\n    type = node.type;\n  }\n\n  var newNode = type.create(attrs, null, marks || node.marks);\n\n  if (node.isLeaf) {\n    return this.replaceWith(pos, pos + node.nodeSize, newNode);\n  }\n\n  if (!type.validContent(node.content)) {\n    throw new RangeError(\"Invalid content for node type \" + type.name);\n  }\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));\n}; // :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\n\n\nfunction canSplit(doc, pos, depth, typesAfter) {\n  if (depth === void 0) depth = 1;\n  var $pos = doc.resolve(pos),\n      base = $pos.depth - depth;\n  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n\n  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {\n    return false;\n  }\n\n  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    var node = $pos.node(d),\n        index$1 = $pos.index(d);\n\n    if (node.type.spec.isolating) {\n      return false;\n    }\n\n    var rest = node.content.cutByIndex(index$1, node.childCount);\n    var after = typesAfter && typesAfter[i] || node;\n\n    if (after != node) {\n      rest = rest.replaceChild(0, after.type.create(after.attrs));\n    }\n\n    if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest)) {\n      return false;\n    }\n  }\n\n  var index = $pos.indexAfter(base);\n  var baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n} // :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\n\n\nTransform.prototype.split = function (pos, depth, typesAfter) {\n  if (depth === void 0) depth = 1;\n  var $pos = this.doc.resolve(pos),\n      before = Fragment.empty,\n      after = Fragment.empty;\n\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before));\n    var typeAfter = typesAfter && typesAfter[i];\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));\n}; // :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\n\n\nfunction canJoin(doc, pos) {\n  var $pos = doc.resolve(pos),\n      index = $pos.index();\n  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b);\n} // :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\n\n\nfunction joinPoint(doc, pos, dir) {\n  if (dir === void 0) dir = -1;\n  var $pos = doc.resolve(pos);\n\n  for (var d = $pos.depth;; d--) {\n    var before = void 0,\n        after = void 0,\n        index = $pos.index(d);\n\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      index++;\n      after = $pos.node(d).maybeChild(index);\n    } else {\n      before = $pos.node(d).maybeChild(index - 1);\n      after = $pos.node(d + 1);\n    }\n\n    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) {\n      return pos;\n    }\n\n    if (d == 0) {\n      break;\n    }\n\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n} // :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\n\n\nTransform.prototype.join = function (pos, depth) {\n  if (depth === void 0) depth = 1;\n  var step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);\n  return this.step(step);\n}; // :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\n\n\nfunction insertPoint(doc, pos, nodeType) {\n  var $pos = doc.resolve(pos);\n\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) {\n    return pos;\n  }\n\n  if ($pos.parentOffset == 0) {\n    for (var d = $pos.depth - 1; d >= 0; d--) {\n      var index = $pos.index(d);\n\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) {\n        return $pos.before(d + 1);\n      }\n\n      if (index > 0) {\n        return null;\n      }\n    }\n  }\n\n  if ($pos.parentOffset == $pos.parent.content.size) {\n    for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {\n      var index$1 = $pos.indexAfter(d$1);\n\n      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) {\n        return $pos.after(d$1 + 1);\n      }\n\n      if (index$1 < $pos.node(d$1).childCount) {\n        return null;\n      }\n    }\n  }\n} // :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\n\n\nfunction dropPoint(doc, pos, slice) {\n  var $pos = doc.resolve(pos);\n\n  if (!slice.content.size) {\n    return pos;\n  }\n\n  var content = slice.content;\n\n  for (var i = 0; i < slice.openStart; i++) {\n    content = content.firstChild.content;\n  }\n\n  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (var d = $pos.depth; d >= 0; d--) {\n      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      var parent = $pos.node(d),\n          fits = false;\n\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content);\n      } else {\n        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n      }\n\n      if (fits) {\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n\n    if (child.content.size) {\n      child = child.copy(mapFragment(child.content, f, child));\n    }\n\n    if (child.isInline) {\n      child = f(child, parent, i);\n    }\n\n    mapped.push(child);\n  }\n\n  return Fragment.fromArray(mapped);\n} // ::- Add a mark to all inline content between two positions.\n\n\nvar AddMarkStep = /*@__PURE__*/function (Step) {\n  function AddMarkStep(from, to, mark) {\n    Step.call(this); // :: number\n    // The start of the marked range.\n\n    this.from = from; // :: number\n    // The end of the marked range.\n\n    this.to = to; // :: Mark\n    // The mark to add.\n\n    this.mark = mark;\n  }\n\n  if (Step) AddMarkStep.__proto__ = Step;\n  AddMarkStep.prototype = Object.create(Step && Step.prototype);\n  AddMarkStep.prototype.constructor = AddMarkStep;\n\n  AddMarkStep.prototype.apply = function apply(doc) {\n    var this$1 = this;\n    var oldSlice = doc.slice(this.from, this.to),\n        $from = doc.resolve(this.from);\n    var parent = $from.node($from.sharedDepth(this.to));\n    var slice = new Slice(mapFragment(oldSlice.content, function (node, parent) {\n      if (!node.isAtom || !parent.type.allowsMarkType(this$1.mark.type)) {\n        return node;\n      }\n\n      return node.mark(this$1.mark.addToSet(node.marks));\n    }, parent), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice);\n  };\n\n  AddMarkStep.prototype.invert = function invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark);\n  };\n\n  AddMarkStep.prototype.map = function map(mapping) {\n    var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n\n    if (from.deleted && to.deleted || from.pos >= to.pos) {\n      return null;\n    }\n\n    return new AddMarkStep(from.pos, to.pos, this.mark);\n  };\n\n  AddMarkStep.prototype.merge = function merge(other) {\n    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {\n      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n    }\n  };\n\n  AddMarkStep.prototype.toJSON = function toJSON() {\n    return {\n      stepType: \"addMark\",\n      mark: this.mark.toJSON(),\n      from: this.from,\n      to: this.to\n    };\n  };\n\n  AddMarkStep.fromJSON = function fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\") {\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n    }\n\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n  };\n\n  return AddMarkStep;\n}(Step);\n\nStep.jsonID(\"addMark\", AddMarkStep); // ::- Remove a mark from all inline content between two positions.\n\nvar RemoveMarkStep = /*@__PURE__*/function (Step) {\n  function RemoveMarkStep(from, to, mark) {\n    Step.call(this); // :: number\n    // The start of the unmarked range.\n\n    this.from = from; // :: number\n    // The end of the unmarked range.\n\n    this.to = to; // :: Mark\n    // The mark to remove.\n\n    this.mark = mark;\n  }\n\n  if (Step) RemoveMarkStep.__proto__ = Step;\n  RemoveMarkStep.prototype = Object.create(Step && Step.prototype);\n  RemoveMarkStep.prototype.constructor = RemoveMarkStep;\n\n  RemoveMarkStep.prototype.apply = function apply(doc) {\n    var this$1 = this;\n    var oldSlice = doc.slice(this.from, this.to);\n    var slice = new Slice(mapFragment(oldSlice.content, function (node) {\n      return node.mark(this$1.mark.removeFromSet(node.marks));\n    }), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice);\n  };\n\n  RemoveMarkStep.prototype.invert = function invert() {\n    return new AddMarkStep(this.from, this.to, this.mark);\n  };\n\n  RemoveMarkStep.prototype.map = function map(mapping) {\n    var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n\n    if (from.deleted && to.deleted || from.pos >= to.pos) {\n      return null;\n    }\n\n    return new RemoveMarkStep(from.pos, to.pos, this.mark);\n  };\n\n  RemoveMarkStep.prototype.merge = function merge(other) {\n    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {\n      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n    }\n  };\n\n  RemoveMarkStep.prototype.toJSON = function toJSON() {\n    return {\n      stepType: \"removeMark\",\n      mark: this.mark.toJSON(),\n      from: this.from,\n      to: this.to\n    };\n  };\n\n  RemoveMarkStep.fromJSON = function fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\") {\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n    }\n\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n  };\n\n  return RemoveMarkStep;\n}(Step);\n\nStep.jsonID(\"removeMark\", RemoveMarkStep); // :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\n\nTransform.prototype.addMark = function (from, to, mark) {\n  var this$1 = this;\n  var removed = [],\n      added = [],\n      removing = null,\n      adding = null;\n  this.doc.nodesBetween(from, to, function (node, pos, parent) {\n    if (!node.isInline) {\n      return;\n    }\n\n    var marks = node.marks;\n\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      var start = Math.max(pos, from),\n          end = Math.min(pos + node.nodeSize, to);\n      var newSet = mark.addToSet(marks);\n\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i])) {\n            removing.to = end;\n          } else {\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n          }\n        }\n      }\n\n      if (adding && adding.to == start) {\n        adding.to = end;\n      } else {\n        added.push(adding = new AddMarkStep(start, end, mark));\n      }\n    }\n  });\n  removed.forEach(function (s) {\n    return this$1.step(s);\n  });\n  added.forEach(function (s) {\n    return this$1.step(s);\n  });\n  return this;\n}; // :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\n\n\nTransform.prototype.removeMark = function (from, to, mark) {\n  var this$1 = this;\n  if (mark === void 0) mark = null;\n  var matched = [],\n      step = 0;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) {\n      return;\n    }\n\n    step++;\n    var toRemove = null;\n\n    if (mark instanceof MarkType) {\n      var set = node.marks,\n          found;\n\n      while (found = mark.isInSet(set)) {\n        (toRemove || (toRemove = [])).push(found);\n        set = found.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) {\n        toRemove = [mark];\n      }\n    } else {\n      toRemove = node.marks;\n    }\n\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i],\n            found$1 = void 0;\n\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n\n          if (m.step == step - 1 && style.eq(matched[j].style)) {\n            found$1 = m;\n          }\n        }\n\n        if (found$1) {\n          found$1.to = end;\n          found$1.step = step;\n        } else {\n          matched.push({\n            style: style,\n            from: Math.max(pos, from),\n            to: end,\n            step: step\n          });\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) {\n    return this$1.step(new RemoveMarkStep(m.from, m.to, m.style));\n  });\n  return this;\n}; // :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\n\n\nTransform.prototype.clearIncompatible = function (pos, parentType, match) {\n  if (match === void 0) match = parentType.contentMatch;\n  var node = this.doc.nodeAt(pos);\n  var delSteps = [],\n      cur = pos + 1;\n\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i),\n        end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type, child.attrs);\n\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty));\n    } else {\n      match = allowed;\n\n      for (var j = 0; j < child.marks.length; j++) {\n        if (!parentType.allowsMarkType(child.marks[j].type)) {\n          this.step(new RemoveMarkStep(cur, end, child.marks[j]));\n        }\n      }\n    }\n\n    cur = end;\n  }\n\n  if (!match.validEnd) {\n    var fill = match.fillBefore(Fragment.empty, true);\n    this.replace(cur, cur, new Slice(fill, 0, 0));\n  }\n\n  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {\n    this.step(delSteps[i$1]);\n  }\n\n  return this;\n}; // :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\n\n\nfunction replaceStep(doc, from, to, slice) {\n  if (to === void 0) to = from;\n  if (slice === void 0) slice = Slice.empty;\n\n  if (from == to && !slice.size) {\n    return null;\n  }\n\n  var $from = doc.resolve(from),\n      $to = doc.resolve(to); // Optimization -- avoid work if it's obvious that it's not needed.\n\n  if (fitsTrivially($from, $to, slice)) {\n    return new ReplaceStep(from, to, slice);\n  }\n\n  return new Fitter($from, $to, slice).fit();\n} // :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\n\n\nTransform.prototype.replace = function (from, to, slice) {\n  if (to === void 0) to = from;\n  if (slice === void 0) slice = Slice.empty;\n  var step = replaceStep(this.doc, from, to, slice);\n\n  if (step) {\n    this.step(step);\n  }\n\n  return this;\n}; // :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\n\n\nTransform.prototype.replaceWith = function (from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0));\n}; // :: (number, number) → this\n// Delete the content between the given positions.\n\n\nTransform.prototype.delete = function (from, to) {\n  return this.replace(from, to, Slice.empty);\n}; // :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\n\n\nTransform.prototype.insert = function (pos, content) {\n  return this.replaceWith(pos, pos, content);\n};\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);\n} // Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\n\n\nvar Fitter = function Fitter($from, $to, slice) {\n  this.$to = $to;\n  this.$from = $from;\n  this.unplaced = slice;\n  this.frontier = [];\n\n  for (var i = 0; i <= $from.depth; i++) {\n    var node = $from.node(i);\n    this.frontier.push({\n      type: node.type,\n      match: node.contentMatchAt($from.indexAfter(i))\n    });\n  }\n\n  this.placed = Fragment.empty;\n\n  for (var i$1 = $from.depth; i$1 > 0; i$1--) {\n    this.placed = Fragment.from($from.node(i$1).copy(this.placed));\n  }\n};\n\nvar prototypeAccessors$1 = {\n  depth: {\n    configurable: true\n  }\n};\n\nprototypeAccessors$1.depth.get = function () {\n  return this.frontier.length - 1;\n};\n\nFitter.prototype.fit = function fit() {\n  // As long as there's unplaced content, try to place some of it.\n  // If that fails, either increase the open score of the unplaced\n  // slice, or drop nodes from it, and then try again.\n  while (this.unplaced.size) {\n    var fit = this.findFittable();\n\n    if (fit) {\n      this.placeNodes(fit);\n    } else {\n      this.openMore() || this.dropNode();\n    }\n  } // When there's inline content directly after the frontier _and_\n  // directly after `this.$to`, we must generate a `ReplaceAround`\n  // step that pulls that content into the node after the frontier.\n  // That means the fitting must be done to the end of the textblock\n  // node after `this.$to`, not `this.$to` itself.\n\n\n  var moveInline = this.mustMoveInline(),\n      placedSize = this.placed.size - this.depth - this.$from.depth;\n  var $from = this.$from,\n      $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n\n  if (!$to) {\n    return null;\n  } // If closing to `$to` succeeded, create a step\n\n\n  var content = this.placed,\n      openStart = $from.depth,\n      openEnd = $to.depth;\n\n  while (openStart && openEnd && content.childCount == 1) {\n    // Normalize by dropping open parent nodes\n    content = content.firstChild.content;\n    openStart--;\n    openEnd--;\n  }\n\n  var slice = new Slice(content, openStart, openEnd);\n\n  if (moveInline > -1) {\n    return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n  }\n\n  if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n    {\n      return new ReplaceStep($from.pos, $to.pos, slice);\n    }\n}; // Find a position on the start spine of `this.unplaced` that has\n// content that can be moved somewhere on the frontier. Returns two\n// depths, one for the slice and one for the frontier.\n\n\nFitter.prototype.findFittable = function findFittable() {\n  // Only try wrapping nodes (pass 2) after finding a place without\n  // wrapping failed.\n  for (var pass = 1; pass <= 2; pass++) {\n    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n      var fragment = void 0,\n          parent = void 0;\n\n      if (sliceDepth) {\n        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n        fragment = parent.content;\n      } else {\n        fragment = this.unplaced.content;\n      }\n\n      var first = fragment.firstChild;\n\n      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n        var ref = this.frontier[frontierDepth];\n        var type = ref.type;\n        var match = ref.match;\n        var wrap = void 0,\n            inject = void 0; // In pass 1, if the next node matches, or there is no next\n        // node but the parents look compatible, we've found a\n        // place.\n\n        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : type.compatibleContent(parent.type))) {\n          return {\n            sliceDepth: sliceDepth,\n            frontierDepth: frontierDepth,\n            parent: parent,\n            inject: inject\n          };\n        } // In pass 2, look for a set of wrapping nodes that make\n        // `first` fit here.\n        else if (pass == 2 && first && (wrap = match.findWrapping(first.type))) {\n          return {\n            sliceDepth: sliceDepth,\n            frontierDepth: frontierDepth,\n            parent: parent,\n            wrap: wrap\n          };\n        } // Don't continue looking further up if the parent node\n        // would fit here.\n\n\n        if (parent && match.matchType(parent.type)) {\n          break;\n        }\n      }\n    }\n  }\n};\n\nFitter.prototype.openMore = function openMore() {\n  var ref = this.unplaced;\n  var content = ref.content;\n  var openStart = ref.openStart;\n  var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n\n  if (!inner.childCount || inner.firstChild.isLeaf) {\n    return false;\n  }\n\n  this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n  return true;\n};\n\nFitter.prototype.dropNode = function dropNode() {\n  var ref = this.unplaced;\n  var content = ref.content;\n  var openStart = ref.openStart;\n  var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n\n  if (inner.childCount <= 1 && openStart > 0) {\n    var openAtEnd = content.size - openStart <= openStart + inner.size;\n    this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n  } else {\n    this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n  }\n}; // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n// Move content from the unplaced slice at `sliceDepth` to the\n// frontier node at `frontierDepth`. Close that frontier node when\n// applicable.\n\n\nFitter.prototype.placeNodes = function placeNodes(ref) {\n  var sliceDepth = ref.sliceDepth;\n  var frontierDepth = ref.frontierDepth;\n  var parent = ref.parent;\n  var inject = ref.inject;\n  var wrap = ref.wrap;\n\n  while (this.depth > frontierDepth) {\n    this.closeFrontierNode();\n  }\n\n  if (wrap) {\n    for (var i = 0; i < wrap.length; i++) {\n      this.openFrontierNode(wrap[i]);\n    }\n  }\n\n  var slice = this.unplaced,\n      fragment = parent ? parent.content : slice.content;\n  var openStart = slice.openStart - sliceDepth;\n  var taken = 0,\n      add = [];\n  var ref$1 = this.frontier[frontierDepth];\n  var match = ref$1.match;\n  var type = ref$1.type;\n\n  if (inject) {\n    for (var i$1 = 0; i$1 < inject.childCount; i$1++) {\n      add.push(inject.child(i$1));\n    }\n\n    match = match.matchFragment(inject);\n  } // Computes the amount of (end) open nodes at the end of the\n  // fragment. When 0, the parent is open, but no more. When\n  // negative, nothing is open.\n\n\n  var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd); // Scan over the fragment, fitting as many child nodes as\n  // possible.\n\n  while (taken < fragment.childCount) {\n    var next = fragment.child(taken),\n        matches = match.matchType(next.type);\n\n    if (!matches) {\n      break;\n    }\n\n    taken++;\n\n    if (taken > 1 || openStart == 0 || next.content.size) {\n      // Drop empty open nodes\n      match = matches;\n      add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n    }\n  }\n\n  var toEnd = taken == fragment.childCount;\n\n  if (!toEnd) {\n    openEndCount = -1;\n  }\n\n  this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));\n  this.frontier[frontierDepth].match = match; // If the parent types match, and the entire node was moved, and\n  // it's not open, close this frontier node right away.\n\n  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {\n    this.closeFrontierNode();\n  } // Add new frontier nodes for any open nodes at the end.\n\n\n  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {\n    var node = cur.lastChild;\n    this.frontier.push({\n      type: node.type,\n      match: node.contentMatchAt(node.childCount)\n    });\n    cur = node.content;\n  } // Update `this.unplaced`. Drop the entire node from which we\n  // placed it we got to its end, otherwise just drop the placed\n  // nodes.\n\n\n  this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n};\n\nFitter.prototype.mustMoveInline = function mustMoveInline() {\n  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {\n    return -1;\n  }\n\n  var top = this.frontier[this.depth],\n      level;\n\n  if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {\n    return -1;\n  }\n\n  var ref = this.$to;\n  var depth = ref.depth;\n  var after = this.$to.after(depth);\n\n  while (depth > 1 && after == this.$to.end(--depth)) {\n    ++after;\n  }\n\n  return after;\n};\n\nFitter.prototype.findCloseLevel = function findCloseLevel($to) {\n  scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n    var ref = this.frontier[i];\n    var match = ref.match;\n    var type = ref.type;\n    var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n    var fit = contentAfterFits($to, i, type, match, dropInner);\n\n    if (!fit) {\n      continue;\n    }\n\n    for (var d = i - 1; d >= 0; d--) {\n      var ref$1 = this.frontier[d];\n      var match$1 = ref$1.match;\n      var type$1 = ref$1.type;\n      var matches = contentAfterFits($to, d, type$1, match$1, true);\n\n      if (!matches || matches.childCount) {\n        continue scan;\n      }\n    }\n\n    return {\n      depth: i,\n      fit: fit,\n      move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to\n    };\n  }\n};\n\nFitter.prototype.close = function close($to) {\n  var close = this.findCloseLevel($to);\n\n  if (!close) {\n    return null;\n  }\n\n  while (this.depth > close.depth) {\n    this.closeFrontierNode();\n  }\n\n  if (close.fit.childCount) {\n    this.placed = addToFragment(this.placed, close.depth, close.fit);\n  }\n\n  $to = close.move;\n\n  for (var d = close.depth + 1; d <= $to.depth; d++) {\n    var node = $to.node(d),\n        add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n    this.openFrontierNode(node.type, node.attrs, add);\n  }\n\n  return $to;\n};\n\nFitter.prototype.openFrontierNode = function openFrontierNode(type, attrs, content) {\n  var top = this.frontier[this.depth];\n  top.match = top.match.matchType(type);\n  this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n  this.frontier.push({\n    type: type,\n    match: type.contentMatch\n  });\n};\n\nFitter.prototype.closeFrontierNode = function closeFrontierNode() {\n  var open = this.frontier.pop();\n  var add = open.match.fillBefore(Fragment.empty, true);\n\n  if (add.childCount) {\n    this.placed = addToFragment(this.placed, this.frontier.length, add);\n  }\n};\n\nObject.defineProperties(Fitter.prototype, prototypeAccessors$1);\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) {\n    return fragment.cutByIndex(count);\n  }\n\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) {\n    return fragment.append(content);\n  }\n\n  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\n\nfunction contentAt(fragment, depth) {\n  for (var i = 0; i < depth; i++) {\n    fragment = fragment.firstChild.content;\n  }\n\n  return fragment;\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) {\n    return node;\n  }\n\n  var frag = node.content;\n\n  if (openStart > 1) {\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n  }\n\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n\n    if (openEnd <= 0) {\n      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));\n    }\n  }\n\n  return node.copy(frag);\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  var node = $to.node(depth),\n      index = open ? $to.indexAfter(depth) : $to.index(depth);\n\n  if (index == node.childCount && !type.compatibleContent(node.type)) {\n    return null;\n  }\n\n  var fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (var i = start; i < fragment.childCount; i++) {\n    if (!type.allowsMarks(fragment.child(i).marks)) {\n      return true;\n    }\n  }\n\n  return false;\n} // :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\n\n\nTransform.prototype.replaceRange = function (from, to, slice) {\n  if (!slice.size) {\n    return this.deleteRange(from, to);\n  }\n\n  var $from = this.doc.resolve(from),\n      $to = this.doc.resolve(to);\n\n  if (fitsTrivially($from, $to, slice)) {\n    return this.step(new ReplaceStep(from, to, slice));\n  }\n\n  var targetDepths = coveredDepths($from, this.doc.resolve(to)); // Can't replace the whole document, so remove 0 if it's present\n\n  if (targetDepths[targetDepths.length - 1] == 0) {\n    targetDepths.pop();\n  } // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n\n\n  var preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget); // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n\n  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    var spec = $from.node(d).type.spec;\n\n    if (spec.defining || spec.isolating) {\n      break;\n    }\n\n    if (targetDepths.indexOf(d) > -1) {\n      preferredTarget = d;\n    } else if ($from.before(d) == pos) {\n      targetDepths.splice(1, 0, -d);\n    }\n  } // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n\n\n  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n  var leftNodes = [],\n      preferredDepth = slice.openStart;\n\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild;\n    leftNodes.push(node);\n\n    if (i == slice.openStart) {\n      break;\n    }\n\n    content = node.content;\n  } // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n\n\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {\n    preferredDepth -= 1;\n  } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {\n    preferredDepth -= 2;\n  }\n\n  for (var j = slice.openStart; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    var insert = leftNodes[openDepth];\n\n    if (!insert) {\n      continue;\n    }\n\n    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length],\n          expand = true;\n\n      if (targetDepth < 0) {\n        expand = false;\n        targetDepth = -targetDepth;\n      }\n\n      var parent = $from.node(targetDepth - 1),\n          index = $from.index(targetDepth - 1);\n\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks)) {\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n      }\n    }\n  }\n\n  var startSteps = this.steps.length;\n\n  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {\n    this.replace(from, to, slice);\n\n    if (this.steps.length > startSteps) {\n      break;\n    }\n\n    var depth = targetDepths[i$2];\n\n    if (depth < 0) {\n      continue;\n    }\n\n    from = $from.before(depth);\n    to = $to.after(depth);\n  }\n\n  return this;\n};\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n\n  if (depth > newOpen) {\n    var match = parent.contentMatchAt(0);\n    var start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n  }\n\n  return fragment;\n} // :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\n\n\nTransform.prototype.replaceRangeWith = function (from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(this.doc, from, node.type);\n\n    if (point != null) {\n      from = to = point;\n    }\n  }\n\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0));\n}; // :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\n\n\nTransform.prototype.deleteRange = function (from, to) {\n  var $from = this.doc.resolve(from),\n      $to = this.doc.resolve(to);\n  var covered = coveredDepths($from, $to);\n\n  for (var i = 0; i < covered.length; i++) {\n    var depth = covered[i],\n        last = i == covered.length - 1;\n\n    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {\n      return this.delete($from.start(depth), $to.end(depth));\n    }\n\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {\n      return this.delete($from.before(depth), $to.after(depth));\n    }\n  }\n\n  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) {\n      return this.delete($from.before(d), to);\n    }\n  }\n\n  return this.delete(from, to);\n}; // : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\n\n\nfunction coveredDepths($from, $to) {\n  var result = [],\n      minDepth = Math.min($from.depth, $to.depth);\n\n  for (var d = minDepth; d >= 0; d--) {\n    var start = $from.start(d);\n\n    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {\n      break;\n    }\n\n    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) {\n      result.push(d);\n    }\n  }\n\n  return result;\n}\n\nexport { AddMarkStep, MapResult, Mapping, RemoveMarkStep, ReplaceAroundStep, ReplaceStep, Step, StepMap, StepResult, Transform, TransformError, canJoin, canSplit, dropPoint, findWrapping, insertPoint, joinPoint, liftTarget, replaceStep };","map":{"version":3,"mappings":"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","names":["const","lower16","factor16","Math","pow","makeRecover","index","offset","recoverIndex","value","recoverOffset","MapResult","pos","deleted","recover","StepMap","ranges","inverted","length","empty","let","diff","i","mapResult","assoc","_map","map","simple","oldIndex","newIndex","start","oldSize","newSize","end","side","result","touches","forEach","f","oldStart","newStart","invert","toString","JSON","stringify","n","Mapping","maps","mirror","from","to","slice","copy","appendMap","mirrors","push","setMirror","appendMapping","mapping","startSize","mirr","getMirror","m","appendMappingInverted","totalSize","inverse","corr","TransformError","message","err","Error","call","__proto__","prototype","Object","create","constructor","name","Transform","doc","steps","docs","prototypeAccessors","before","get","step","object","maybeStep","failed","apply","addStep","docChanged","getMap","mustOverride","stepsByID","Step","_doc","_mapping","merge","_other","toJSON","fromJSON","schema","json","stepType","RangeError","type","jsonID","id","stepClass","StepResult","ok","fail","fromReplace","replace","e","ReplaceError","ReplaceStep","structure","super","contentBetween","size","max","other","openEnd","openStart","Slice","content","append","ReplaceAroundStep","gapFrom","gapTo","insert","gap","inserted","insertAt","removeBetween","$from","resolve","dist","depth","indexAfter","node","childCount","next","maybeChild","isLeaf","firstChild","canCut","canReplace","liftTarget","range","parent","cutByIndex","startIndex","endIndex","$to","spec","isolating","lift","target","gapStart","gapEnd","after","Fragment","d","splitting","findWrapping","nodeType","attrs","innerRange","around","findWrappingOutside","inner","findWrappingInside","withAttrs","concat","contentMatchAt","outer","canReplaceWith","child","inside","contentMatch","lastType","innerMatch","matchType","validEnd","wrap","wrappers","match","matchFragment","setBlockType","isTextblock","mapFrom","nodesBetween","hasMarkup","canChangeType","this","clearIncompatible","startM","endM","nodeSize","marks","$pos","setNodeMarkup","nodeAt","newNode","replaceWith","validContent","canSplit","typesAfter","base","innerType","rest","replaceChild","baseType","split","typeAfter","canJoin","joinable","nodeBefore","nodeAfter","a","b","canAppend","joinPoint","dir","join","insertPoint","parentOffset","dropPoint","pass","bias","insertPos","fits","wrapping","mapFragment","fragment","mapped","isInline","fromArray","AddMarkStep","mark","oldSlice","sharedDepth","isAtom","allowsMarkType","addToSet","RemoveMarkStep","eq","min","markFromJSON","removeFromSet","addMark","removed","added","removing","adding","isInSet","newSet","s","removeMark","matched","toRemove","MarkType","set","found","style","j","parentType","delSteps","cur","allowed","fill","fillBefore","replaceStep","fitsTrivially","Fitter","fit","delete","unplaced","frontier","placed","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","close","sliceDepth","contentAt","first","frontierDepth","inject","compatibleContent","openAtEnd","dropFromFragment","closeFrontierNode","openFrontierNode","taken","add","openEndCount","matches","closeNodeStart","allowedMarks","toEnd","addToFragment","lastChild","top","level","contentAfterFits","findCloseLevel","scan","dropInner","move","open","pop","count","frag","invalidMarks","allowsMarks","replaceRange","deleteRange","targetDepths","coveredDepths","preferredTarget","unshift","defining","indexOf","splice","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","closeFragment","startSteps","oldOpen","newOpen","replaceRangeWith","point","covered","last","minDepth","inlineContent"],"sources":["/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-transform/src/map.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-transform/src/transform.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-transform/src/step.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-transform/src/replace_step.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-transform/src/structure.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-transform/src/mark_step.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-transform/src/mark.js","/Users/lucasrodriguespereira/Projects/clipping/toastui-test/my-app/node_modules/prosemirror-transform/src/replace.js"],"sourcesContent":["// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    if (!ranges.length && StepMap.empty) return StepMap.empty\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number) → MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number) → number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: () → StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number) → StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number) → Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number) → ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: () → Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number) → number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number) → MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr\n          pos = this.maps[corr].recover(result.recover)\n          continue\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n","import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step) → this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step) → StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n","import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node) → StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: () → StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node) → Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable) → ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step) → ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: () → Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object) → Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node) → StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string) → StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice) → StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n","import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`—the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      let match = wrappers[i].type.contentMatch.matchFragment(content)\n      if (!match || !match.validEnd)\n        throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\")\n    }\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n  }\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      let parent = $pos.node(d), fits = false\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content)\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type)\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0])\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the marked range.\n    this.from = from\n    // :: number\n    // The end of the marked range.\n    this.to = to\n    // :: Mark\n    // The mark to add.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the unmarked range.\n    this.from = from\n    // :: number\n    // The end of the unmarked range.\n    this.to = to\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n","import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let set = node.marks, found\n      while (found = mark.isInSet(set)) {\n        ;(toRemove || (toRemove = [])).push(found)\n        set = found.removeFromSet(set)\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline))\n    if (!$to) return null\n\n    // If closing to `$to` succeeded, create a step\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n    while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n      content = content.firstChild.content\n      openStart--; openEnd--\n    }\n    let slice = new Slice(content, openStart, openEnd)\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n    if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n      return new ReplaceStep($from.pos, $to.pos, slice)\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n    this.frontier[frontierDepth].match = match\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode()\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1))\n      let fit = contentAfterFits($to, i, type, match, dropInner)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return null\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    $to = close.move\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return $to\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    preferredDepth -= 1\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    preferredDepth -= 2\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (depth < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d) ||\n        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n         d && $to.start(d - 1) == start - 1))\n      result.push(d)\n  }\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}